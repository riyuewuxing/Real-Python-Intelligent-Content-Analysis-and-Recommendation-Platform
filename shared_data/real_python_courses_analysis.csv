Title,URL,Date,Course Duration,Keywords,Content
Control Flow Structures in Python,https://realpython.com/python-control-flow/,"May 28, 2025",N/A,"intermediate, python","Table of ContentsGetting to Know Control Flow in PythonUsing Conditional StatementsUsing if to Make DecisionsNesting Conditionals and Using Boolean OperatorsChaining Multiple Conditions With elifRunning a Default Code Block With elseConditional ExpressionsRepeating Code With for and while LoopsThe for Loop to Traverse IterablesThe while Loop for Conditional IterationThe break and continue StatementsThe else Clause in LoopsNested LoopsComprehensionsRepeating Code Through RecursionExploring Other Structures Related to Control FlowThe return StatementThe yield StatementThe raise StatementThe with StatementUsing try … except Blocks to Control FlowHandling Errors With try … except BlocksRunning Post-Success Code With the else ClauseCleaning Up With the finally ClauseMatching Patterns With match … caseCommon Pitfalls and Best PracticesUnintentional Infinite LoopsAlways True or False ConditionsWrong Order of ConditionsToo Broad ExceptionsHard-to-Read Nested ConstructsConclusionFrequently Asked QuestionsRemove adsPython’s control flow structures allow you to dictate the order in which statements execute in your program. You can do this by using structures like conditionals, loops, and others.Normally, your code executes sequentially. You can modify this behavior using control flow structures that let you make decisions, run specific pieces of code in response to certain conditions, repeat a code block several times, and more.Knowing about control flow structures is a fundamental skill for you as a Python developer because they’ll allow you to fine-tune how your programs behave.By the end of this tutorial, you’ll understand that:Control flowin Python refers to the order in which code statements are executed or evaluated.Commoncontrol flow statementsin Python include conditionals with theif,elif,elsekeywords, loops withforandwhile, exception handling withtry…except, and structural pattern matching withmatch…case.Control flow structures in Python let youmake decisions,repeat tasks, andhandle exceptions, enhancing the dynamism and robustness of your code.To dive deeper into Python’s control flow, explore how these constructs allow you to write more dynamic and flexible programs by making decisions and handling repetitive tasks efficiently.Get Your Code:Click here to download the free sample codethat shows you how to use control flow structures in Python.Take the Quiz:Test your knowledge with our interactive “Control Flow Structures in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizControl Flow Structures in PythonIn this quiz, you'll test your understanding of Python control flow structures, which include conditionals, loops, exception handling, and structural pattern matching. Strengthening these skills will help you write more dynamic, smart, and robust Python code.Getting to Know Control Flow in PythonMost programming languages, including Python, execute codesequentiallyfrom the top of the source file to the bottom, line by line. This way of running code is entirely logical. It’s like following a series of steps in order. However, what if you’re solving a problem with two or more action paths that depend on the result of evaluating a given condition?For example, say that you’re building an online store and need to implement a feature that decides whether a customer is eligible for free shipping. You’ve decided that if the order is greater than $150.00, then the customer gets free shipping. In this situation, you have two action paths:If the order is less than $150.00, then the customer doesn’t get free shipping.If the order is equal to or greater than $150.00, then the customer gets free shipping.Now, think of a way you could do this with sequential statements. It isn’t an easy task, right? You’d need something that allows you to check the order and decide what course of action to take. That’s exactly what a conditional statement lets you do:Python>>>order_total=215.00>>>iforder_total>=150:...print(""You got free shipping!"")...else:...print(""The shipping fee is $5.00"")...You got free shipping!Note how the code isn’t executed sequentially. Instead, the execution path depends on the condition’s result. Statements and syntax constructs that allow you to alter the normal execution flow as you did in the example above are known ascontrol flow structures.Note:In programming, the ability of a program to choose between multiple paths of execution based on certain conditions is known asbranching.In programming, the termcontrol flowrefers to the order in which individualstatementsare executed or evaluated within a program. As you already know, the normal flow of execution is sequential. However, you can alter this by using control flow statements, which includeconditionals,loops, and several others.Here’s another example. This time, you need to repeat a task several times. You can do this by duplicating the same line of code as many times as needed:Pythongreeting.pyprint(""Hello!"")print(""Hello!"")print(""Hello!"")This code works. However, repeating the same code several times is error-prone and introducesmaintainabilityissues. Additionally, what if you don’t know the number of repetitions beforehand? In this situation, a loop will save you:Python>>>for_inrange(3):...print(""Hello!"")...Hello!Hello!Hello!In this example, you use aforloopto run the code three times. This code is much more elegant, flexible, and less repetitive.Control flow statements like these let you make decisions, repeat tasks, and handle exceptions, making your code more dynamic and powerful. In short, they let you customize the control flow of your programs. In the rest of this tutorial, you’ll dive into Python’s most commonly used control flow statements.Remove adsUsing Conditional StatementsYou took a quick peek at conditional statements in the previous section. Aconditional statementis a syntax construct that lets you execute certain code blocks only when a specific condition is true, while skipping them when the condition is false. It allows your programs to respond to different situations rather than just running sequentially.Note:To dive deeper into conditionals, check out theConditional Statements in Pythontutorial.Conditional statements are how you make decisions in your code. They let you control the execution flow based on whether a condition is evaluated as true or false. In the following sections, you’ll learn about conditionals and how to use them in your code.Usingifto Make DecisionsTo write a conditional statement in Python, you use theifkeyword. The basic syntax is as shown below:Python Syntaxifcondition:<block>When the execution flow reaches theifheader, the condition is evaluated. If it’s true, then the code block immediately following runs. Otherwise, the execution jumps to the next unindented statement.To illustrate how this works in practice, say that you’re coding an app to control the speed of a smart car. You have a function that reads the speedometer, and you want to write a function that warns you if you exceed the speed limit. Here’s the code:Pythonspeed.pyimportrandomdefcheck_speed_limit(limit=80):speed=read_speedometer()ifspeed>limit:print(""You are over the speed limit! Slow down."")defread_speedometer():speed=random.randint(30,130)print(f""Speedometer reading:{speed}km/h"")returnspeedcheck_speed_limit()Insidecheck_speed_limit(), you first get the speed reading. Then, you use anifstatement to compare the current speed with the limit for the actual road. If the speed exceeds the limit, then theifblock runs, and you get a warning message. If the speed is less than the limit, then nothing happens.Nesting Conditionals and Using Boolean OperatorsSometimes, you need to check multiple conditions. You can do it by nesting multiple conditionals. For example, say that you need to check whether a number falls within the interval from0to10. You can do this with the following nested conditionals:Python>>>number=7>>>ifnumber>0:...ifnumber<10:...print(""The number is between 0 and 10!"")...The number is between 0 and 10!First, you check if the number is greater than0, and then if it’s less than10. When the code runs, both conditions are true because the input number is7. This code works. However, usingBooleanoperators to combine conditions often provides a cleaner solution.For example, you can get the same result using theandoperator to combine the conditions in one:Python>>>ifnumber>0andnumber<10:...print(""The number is between 0 and 10!"")...The number is between 0 and 10!This code works the same, but it’s flatter and cleaner. It aligns with theZen of Python’sprinciple that says:“Flat is better than nested.”Note:The condition in the example above is demonstrative of how to use Boolean operators. For this specific example, the Pythonic and recommended way to write the condition would be the following:Python>>>if0<number<10:...print(""The number is between 0 and 10!"")...The number is between 0 and 10!In this version, the condition uses what’s known asoperator chaining, which provides an elegant way to check whether a value is within a given interval.Logical expressions involvingand,or, andnotbehave as shown in the table below:OperatorSyntaxResultandcondition_0 and condition_1• A truthy value if both conditions areTrue• A falsy value otherwiseorcondition_0 or condition_1• A truthy value if at least one condition isTrue• A falsy value if both areFalsenotnot condition_0• A truthy value if the condition isFalse• A falsy value if the condition isTrueThis table summarizes the truth value of conditions created using logical operators withBooleanoperands. Note that you can chain multiple instances of an operator to create even more complex expressions. You can also combine operators as needed.Consider the following example that simulates a login process:Python>>>username=""jane"">>>password_correct=True>>>two_factor_enabled=True>>>two_factor_passed=True>>>ifpassword_correctand(nottwo_factor_enabledortwo_factor_passed):...print(""Login successful."")...Login successful.In this example, you combine conditions withand,not, andor. Note that you can use parentheses to group conditions and make the whole expression more readable.Note:To dive deeper into Python’s logical operators, check out the following resources:Using the “and” Boolean Operator in PythonUsing the “or” Boolean Operator in PythonUsing the “not” Boolean Operator in PythonAs you can see, Boolean operators let you write concise and straightforward conditions for yourifstatements, improving the decision-making process in your code.Finally, note that when you have overcomplicated conditions with several Boolean operators, using nested conditionals may be the way to go if you want to write readable code.Remove adsChaining Multiple Conditions WithelifOften, it’s useful to check a concrete value or expression against multiple expected values and take different actions depending on which one it matches. Python’selifclause offers a clean way to handle these types of situations.The general syntax for using theelifclause is shown below:Python Syntaxifcondition_0:<block_0>elifcondition_1:<block_1>...elifcondition_n:<block_n>You can have as manyelifclauses as you need. Typically, the conditions in each clause check for a different result on a particular expression. In other words, the conditions are often semantically similar.For example, say that you want to decide which task to execute on a given day of the week. You can use a series ofelifclauses that check the current day, as in the example below:Python>>>day=""Wednesday"">>>ifday==""Monday"":...print(""Work on cool Python content!"")...elifday==""Tuesday"":...print(""Team meeting at 9 AM."")...elifday==""Wednesday"":...print(""Hang out with the community."")...elifday==""Thursday"":...print(""Work on cool Python content!"")...elifday==""Friday"":...print(""Wrap up and reviews."")...elifday==""Saturday"":...print(""Enjoy with your family!"")...elifday==""Sunday"":...print(""Rest and recharge."")...Hang out with the community.In this example, you have a main condition in theifheader that checks for Monday. Then you have multipleelifclauses that check for the remaining days. Each branch runs a different task depending on the current day.The difference between a chain ofelifclauses and multipleifstatements is often a point of confusion. A chain ofelifclauses is suitable for handling a fixed number ofmutually exclusiveconditions, such as checking the current day of the week shown in the example above.In contrast, a chain of pureifstatements lets more than one code block run in case of overlapping or disjoint conditions that can be true at a given time. Consider the following example:Pythontemperature=75humidity=60iftemperature>70:print(""It's warm outside."")ifhumidity>50:print(""It's humid outside."")In this example, both conditions are true, so both code blocks run. If you put the second condition in anelifclause, then the associated code will never run because in theif…elifconstruct, only the first branch with a true condition will run.Running a Default Code Block WithelseAnother common situation when working with conditionals is to have a default code block. In other words, a code block that runs when none of the tested conditions are true. You can implement this default course of action with theelseclause.In this case, the syntax is as follows:Python Syntaxifcondition:<block>else:<default_block>In this construct, if the main condition is false, then theelseblock runs. You can insertelifclauses in this syntax as well. However, theelseclause must always be the last one to ensure that all conditions are checked first. Placing it before anelifclause would cause asyntax error.As a quick example, say that you want to write a conditional statement that checks whether a number is even:Python>>>number=7>>>ifnumber%2==0:...print(""The number is even."")...else:...print(""The number is odd."")...The number is odd.In this example, the condition checks if the current number is even using themodulo operator. If the condition is false, then the execution falls through to theelseblock. This behavior is consistent with the fact that a number can be even or odd. So in this example, being odd is the default course of action.Remove adsConditional ExpressionsPython has a syntax construct known asconditional expressions. This construct is inspired by the ternary operator of programming languages likeC:Ccondition?value_if_true:value_if_falseThis construct evaluates tovalue_if_trueif theconditionis true, and otherwise evaluates tovalue_if_false. The equivalent Python syntax is the following:Python Syntaxvalue_if_trueifconditionelsevalue_if_falseThis returnsvalue_if_trueif theconditionis true andvalue_if_falseotherwise. Consider the following example:Python>>>defcalculate_shipping(order_total):...return0iforder_total>=150elseorder_total*0.05...>>>print(f""Shipping cost: ${calculate_shipping(200)}"")Shipping cost: $0>>>print(f""Shipping cost: ${calculate_shipping(100)}"")Shipping cost: $5.0Incalculate_shipping(), you use a conditional expression to check if the order total is greater than or equal to 150. If that’s the case, the shipping cost is 0. Otherwise, a 5% shipping fee is applied.Repeating Code WithforandwhileLoopsIn programming, repeating a piece of code several times is often useful. This is where loop constructs come into the scene. Loops are a common control flow structure that you’ll find in most programming languages. Python provides two loops:forloopsare mostly used to iterate aknownnumber of times, which is common when you’re processing data collections with a specific number of data items.whileloopsare commonly used to iterate anunknownnumber of times, which is useful when the number of iterations depends on a given condition.In the following sections, you’ll exploreforandwhileloops, how they work, and how to use them effectively. You’ll also learn about statements likebreakandcontinuethat allow you to tweak a loop’s behavior. Finally, you’ll learn about comprehensions, which allow for data processing in a concise way.TheforLoop to Traverse IterablesWhen you need to iterate over the data items in a collection, you typically go with aforloop, which is specifically designed for this task. Python’sforloop works much like theforeach loopin other programming languages. Here’s the basic syntax:Python Syntaxforiteminiterable:<block>You start the loop with theforkeyword. Then, you have the loop variable,item, which holds the current value in the target data collection. Theiterablevariable can hold any Python object that supportsiteration, such aslists,tuples,strings,dictionaries, andsets.In each iteration, the loop pulls a new item from the targetiterable, allowing you to process the item as needed. Once the loop finishes iterating over the data, the execution flow jumps to the next statement after the loop.Note:To learn more aboutforloops, check out thePythonforLoops: The Pythonic Waytutorial.Here’s a quick example of aforloop in Python:Python>>>colors=[""red"",""green"",""blue"",""yellow""]>>>forcolorincolors:...print(color)...redgreenblueyellowIn this example, you use aforloop to traverse a list of color names. The loop body consists of a call toprint()that displays each color name on the screen. Note how readable this loop is. It almost reads as plain English.In practice, you may find several situations where you have an iterable whose name is a plural noun, likecolorsin this example. In those cases, a recommended practice is to use the singular form to name the loop variable—colorin this example.Note:Python also hasasync forloops whose basic syntax is as follows:Python Syntaxasyncforiteminasync_iterable:<block>These loops are useful when you need to iterate over asynchronous iterables in asynchronous code. To learn more about them, check out theAsynchronous Iterators and Iterables in Pythontutorial.Python’sforloop allows you to traverse data collections in a readable and clean way. During the iteration, you can perform actions with the data items, which is often a requirement in programming.Here’s an example of a loop that traverses an iterable of numbers, and computes and prints the square of each number:Python>>>numbers=[2,3,4,5,6]>>>fornumberinnumbers:...print(number**2)...49162536In each iteration, this loop takes the current number, computes its square value, and displays the result to the screen. Here, you’re running a computation with each value in the iterable.Remove adsThewhileLoop for Conditional IterationUnlikeforloops, which are designed for traversing iterables of data,whileloops are appropriate for situations where you need to iterate until a given condition becomes false orwhilethe condition is true. These loops are also useful for potentially infinite loops, such as event loops inGUI applicationsorasynchronouscode.Note:To dive deeper intowhileloops, check out thePythonwhileLoops: Repeating Tasks Conditionallytutorial.The basic syntax of a Pythonwhileloop is shown below:Python Syntaxwhilecondition:<block>You start the loop with thewhilekeyword, followed by a condition. This condition is checked before each iteration, including the very first one. If the condition is true, then the loop’s code block executes. After the block finishes running, the condition is checked again. This cycle continues until the condition evaluates as false, at which point the program exits the loop and proceeds with the next statement.Note:Unlike other programming languages like C, Python doesn’t have a do-while loop construct. However, you can emulate this type of loop using some tricks. To learn about these, check out theHow Can You Emulate Do-While Loops in Python?tutorial.Here’s a quick example of awhileloop:Python>>>user_input="""">>>whileuser_input!=""exit"":...user_input=input(""Type something: "")...print(f""You typed:{user_input}"")...Type something: HelloYou typed: HelloType something: Pythonista!You typed: Pythonista!Type something: exitYou typed: exitIn this example, the loop repeatedly takes user input and prints it to the screen. It repeats its code block until you type inexit, which makes the loop condition become false.Another common use case ofwhileloops is when you need to wait for input or events an undefined number of times. This is common in games and GUI applications where the interface keeps waiting, capturing, and processing user events, like mouse clicks, key presses, and others.For example, here’s a short app that implements a number-guessing game using awhileloop:Pythonnumber_guesser.pyfromrandomimportrandintLOW,HIGH=1,10secret_number=randint(LOW,HIGH)clue=""""# Game loopwhileTrue:guess=input(f""Guess a number between{LOW}and{HIGH}{clue}"")number=int(guess)ifnumber>secret_number:clue=f""(less than{number})""elifnumber<secret_number:clue=f""(greater than{number})""else:breakprint(f""You guessed it! The secret number is{number}"")In this example, you set the loop condition toTrue, which enables the loop to run indefinitely. In this case, you need the loop to run until the user guesses the secret number. The loop’s code block captures the user’s guess and processes it to determine whether it’s a match.Note:A loop with a condition that’s always true represents an infinite loop. To intentionally create this type of loop in Python, you’ll typically use thewhile True:header.In each iteration, the loop gives the user some clues about the secret number. This is the ideal game—you’ll always win unless you press theCtrl+Ckey combination to terminate the code execution with aKeyboardInterruptexception.ThebreakandcontinueStatementsBothforandwhileloops in Python can use thebreakandcontinuestatements, which you typically wrap in a conditional. These statements do the following:breakterminates the loop execution and makes your program jump to the first statement immediately after the loop body.continueskips the remaining code in the current iteration by immediately jumping back to the loop header.Here’s the syntax that you typically use to includebreakandcontinuein aforloop:Python Syntax# General syntax for breakforiteminiterable:[block]ifbreak_condition:[block]break[block]# General syntax for continueforiteminiterable:[block]ifcontinue_condition:[block]continue<block>In the case ofbreak, the code blocks before and after the statement are optional. However, in most cases, you would have at least one of them so that your loop does something apart from breaking out. The square brackets in the syntax express that these code blocks are optional.Thebreakstatement jumps out of the loop, so any code after that statement won’t run, and the loop will terminate early.In contrast, it doesn’t make much sense to have acontinuestatement without a code block after it. In the end, the intention of this statement is to skip some code. So, the code blocks before the statement are optional, and the code block after islogicallyrequired. That’s why the syntax uses the angle brackets, to signal that the code block is needed in practice, even if it’s not strictly enforced by Python.You shouldn’t have code after either of these statements if that code is at the same level of indentation. The reason is that the code you place afterbreakorcontinueat the same level of indentation will never run. It’ll be dead code as you’ll see in a moment.Here’s the syntax for awhileloop that usesbreakandcontinue:Python Syntax# General syntax for breakwhileloop_condition:[block]ifbreak_condition:[block]break[block]# General syntax for continuewhileloop_condition:[block]ifcontinue_condition:[block]continue<block>In this case, the statements work the same way as in aforloop. It’s important to note that you typically won’t include abreakor continue statement right in the loop body without wrapping it in a conditional statement.For example, if you include abreakstatement directly in the loop body, then the loop will run until it finds that statement and terminates immediately:Python>>>foriinrange(5):...print(""Before break"")...break...print(""After break"")...Before breakIn this example, the code beforebreakruns once. The code afterbreaknever runs. It’s unreachable or dead code, and your codelinterwill probably flag it as an issue.So, you’ll have a loop that always runs a single time. Similarly, if you place acontinuestatement directly in the loop body, then the code after that statement will never run:Python>>>foriinrange(5):...print(""Before continue"")...continue...print(""After continue"")...Before continueBefore continueBefore continueBefore continueBefore continueIn this example, the code after thecontinuestatement is again unreachable, or dead code. However, the loop still iterates as many times as you expected.Finally, you can’t have abreakorcontinuestatement outside of a loop:Python>>>break...SyntaxError: 'break' outside loop>>>continue...SyntaxError: 'continue' not properly in loopIn these examples, you try to use the statement outside a loop. In both cases, you get aSyntaxErrorexception with an appropriate error message.Remove adsTheelseClause in LoopsPython’sforandwhileloops have anelseclause similar to theelsein conditional statements. This may be unexpected for people coming from other programming languages. Python might be the only mainstream programming language with anelseclause in its loops.The syntax to add anelseis straightforward, as it’s in a conditional statement:Python Syntaxforiteminiterable:<block>else:<block>whilecondition:<block>else:<block>To add anelseclause to one of your loops, you just need theelsekeywordat the end of the loop body, followed by a colon and an indented code block. Note that theelsekeyword must be at the same indentation level as the loop heading.Now, how does theelseclause work in a loop? The code block under anelsein a loop will run only if the loop terminates naturally without encountering abreakstatement. In aforloop, it executes when the target data is over. In awhileloop, it runs when the condition becomes false.In practice, it doesn’t make much sense to add anelseclause to a loop that doesn’t have abreakstatement. If that’s the case, you’ll get the same result by placing the code right after the loop and at the same indentation level as the loop header.Common use cases of anelseclause in a loop include:Searching for something:Allows you to handle the case when the loop doesn’t find the target item.Doing data validation:Lets you confirm that all data items passed the validation.Handling empty data collections gracefully: Allows you to provide a fallback behavior when the input iterable is empty.Here’s a quick example of aforloop that searches for a value in a list of numbers:Python>>>numbers=[1,3,5,9]>>>target=7>>>fornumberinnumbers:...ifnumber==target:...print(""Found!"")...break...else:...print(""Not found."")...Not found.>>>target=3>>>fornumberinnumbers:...ifnumber==target:...print(""Found!"")...break...else:...print(""Not found."")...Found!In the first loop, the target value is7. Since this value isn’t in the list, the loop terminates naturally, and the code under theelseclause runs, letting you know that the value wasn’t found. In the second loop, the target value is3, which is in the list. In this case, thebreakstatement terminates the loop, and theelseclause doesn’t run.Nested LoopsSometimes, you may need to nest a loop inside another loop.Nested loopsmay be helpful when you need to process lists of lists withforloops. For example, say that you have a matrix of numbers and want to create another matrix containing square values. You can do this using nestedforloops as shown below:Python>>>matrix=[...[9,3,8,3],...[4,5,2,8],...[6,4,3,1],...[1,0,4,5],...]>>>squares=[]>>>forrowinmatrix:...squares_row=[]...fornumberinrow:...squares_row.append(number**2)...squares.append(squares_row)...>>>squares[[81, 9, 64, 9],[16, 25, 4, 64],[36, 16, 9, 1],[1, 0, 16, 25]]In this example, you have an outer loop that iterates over the rows of the matrix. Then, you have a nested loop that squares the numbers in the current row and adds them to a new list. Finally, you add the new list to the matrix of square values.Using nested loops is sometimes a good solution. However, more than two levels of nesting might make your code hard to read and understand.Note:To learn more about using nested loops, check out theNested Loops in Pythontutorial.Apart from the readability issue of nested loops, you also need to know that nested loops can increase thetime complexityof your code, potentially affecting performance. While they aren’t inherently inefficient, you might encounter bottlenecks when each loop involves a large number of iterations.ComprehensionsComprehensionsare a concise way to create lists, dictionaries, and sets in Python. They’re like a compactforloop that builds and returns a new list, dictionary, or set, depending on the type of comprehension you’re using.The general use case of a comprehension is to create transformed data collections from existing ones. To do this, the comprehension allows you to apply a specific operation to each data item.Here’s the syntax for the different types of comprehensions in Python:Python Syntax# List comprehension[expressionforiteminiterable[ifcondition]]# Set comprehension{expressionforiteminiterable[ifcondition]}# Dictionary comprehension{key_expression:value_expressionforiteminiterable[ifcondition]}The three comprehension constructs are syntactically similar. The first part consists of an expression—or two in the case of dictionaries—that transforms the original data to obtain a new item. Then, you have a construct that mimics the header of a regularforloop, which is the part that runs the iteration.Finally, you have an optional condition that you’ll use only when you need to filter your data by checking some condition. Note that this part is pretty similar to the header of anifstatement.Note:To learn more about comprehensions in Python, check out the following tutorials:When to Use a List Comprehension in PythonPython Set Comprehensions: How and When to Use ThemPython Dictionary Comprehensions: How and When to Use ThemTo explore how comprehension works, say that you have a list of email addresses that were stored without validation, and look like the following:Python>>>emails=[..."" alice@example.org "",...""BOB@example.com"",...""charlie@EXAMPLE.com"",...""David@example.net"",..."" bob@example.com"",...""JohnDoe@example.com"",...""DAVID@Example.net""...]You want to clean this list and think of using a list comprehension to apply some transformations to each address usingstring manipulation methods. For example, you can remove leading and trailing spaces and convert all the letters to lowercase:Python>>>clean_emails=[email.strip().lower()foremailinemails]>>>clean_emails['alice@example.org','bob@example.com','charlie@example.com','david@example.net','bob@example.com','johndoe@example.com','david@example.net']In this example, you use a list comprehension to transform your original data using the.strip()and.lower()methods. Your list of emails now looks better. However, you still have an issue. The list has repeated addresses, and you want them to be unique.In this situation, instead of using a list comprehension, you may benefit from using a set comprehension like the following:Python>>>unique_emails={email.strip().lower()foremailinemails}>>>unique_emails{'bob@example.com','david@example.net','alice@example.org','charlie@example.com','johndoe@example.com'}Now you have a completely clean set of email addresses. In this example, you’re taking advantage of the fact that sets are collections of unique elements. Keep in mind that sets are unordered, so the arrangement of the email addresses in your output may vary.Note:To learn more about sets, check out theSets in Pythontutorial.Even though comprehensions are expressions that return collections rather than a classical control flow structure, they iterate over the input data as aforloop would. In some situations, you’ll benefit from replacing aforloop with a comprehension to produce conciser and more Pythonic code.Remove adsRepeating Code Through RecursionRecursionis another resource that you can use to control the execution flow of your Python code. Recursion is a programming technique where a function calls itself to solve smaller instances of the same problem. In a sense, recursion is like iteration because it allows you to repeat a specific code block.Note:To dive deeper into recursion, check out the following tutorials:Recursion in Python: An IntroductionThinking Recursively in PythonWhen writing a recursive function, you need a base case that breaks the recursion and a recursive case that makes the recursive calls. For example, consider the following function that generates a countdown using recursion:Python>>>defcountdown(n):...print(n)...ifn==0:...return# Base case...else:...countdown(n-1)# Recursive case...>>>countdown(5)543210In this function, the base case occurs whennis zero, at which point the function returns and the recursion stops. Next, you have the recursive case, where the function calls itself. The argument isnminus1, so it moves closer to the base case in each recursion.Note that you can get the same result with a loop:Python>>>defcountdown(n):...whilen>=0:...print(n)...n-=1...>>>countdown(5)543210Recursion can be great for navigating nested structures, such asfile systemsandJSONtrees. However, it can be inefficient because recursive calls are costly regarding memory usage and execution time.Python has a default recursion limit of 1000 recursive calls. If you exceed this limit, then you’ll get aRecursionError. This could be an issue if you want to generate a countdown that starts at 2000, for example.Note:You can change the recursion limit if you need to. Here’s how:Python>>>importsys>>>sys.getrecursionlimit()# Check the current limit1000>>>sys.setrecursionlimit(3000)# Update the limit>>>sys.getrecursionlimit()3000In this example, you use thegetrecursionlimit()function to check the current recursion limit. Then, you set the limit to3000recursions using thesetrecursionlimit()function.Finally, recursive functions can be hard to debug because tracing the calls isn’t always straightforward. Multiple function calls are active at once in thecall stack, which can make the execution flow difficult to follow.Exploring Other Structures Related to Control FlowWhile conditionals, loops, and recursion are fundamental control flow constructs in Python, you’ll also find other language features that influence how your programs flow. In this section, you’ll explore the following statements that significantly impact how and when your code runs:returnyieldraisewithEach of these statements helps you control the execution flow of your programs, allowing you to write clearer, safer, more maintainable, and more Pythonic code.ThereturnStatementThereturnstatement immediately exits a function and optionally returns a value. A function can have multiple return statements, but depending on the flow of execution, only one of them will execute in a given function call. Thereturnstatement not only allows the function to return an optional value, but also controls the function’s execution flow by terminating the function early when needed.Note:To learn more aboutreturn, check outThe PythonreturnStatement: Usage and Best Practices.When a function has multiple return paths and the execution goes through one of them, the rest of the paths won’t execute. For example, say you’re practicing for aPython coding interview. You’re implementing a function that tackles theFizzBuzzchallenge, where you returnfizzfor numbers divisible by three,buzzfor those divisible by five, andfizz buzzfor those divisible by both three and five:Python>>>deffizzbuzz(number):...ifnumber%15==0:...return""fizz buzz""...elifnumber%3==0:...return""fizz""...elifnumber%5==0:...return""buzz""...else:...returnnumber...>>>fornumberinrange(5):...fizzbuzz(number)...'fizz buzz'12'fizz'4This function has multiple return paths, each depending on a condition. For example, when the number is only divisible by3, then the second condition is true, and the function returnsfizz. The rest of the code doesn’t run because the function’s execution has terminated.Remove adsTheyieldStatementTheyieldstatement allows you to definegeneratorfunctions that return an iterator. This iteratoryieldsitems on demand. In other words, you can retrieve items from that iterator at different moments in your code’s execution. This is possible because theyieldstatement pauses the item generation until you demand a new item.Generators provide a memory-efficient way to iterate over large datasets because instead of loading all the data into memory, they only load the currently demanded item.Note:To learn more aboutyield, check out theHow to Use Generators andyieldin Pythontutorial.Theyieldstatement also provides a mechanism for controlling the code’s execution flow. For example, say you want to write a function that takes a list of numbers and returns an iterator that yields a message showing the number and whether it’s even or odd.Here’s a possible implementation:Python>>>defodd_even(numbers):...fornumberinnumbers:...ifnumber%2==0:...yieldf""{number}is even""...else:...yieldf""{number}is odd""...>>>numbers=[2,2,3,11,4,5,7,4]>>>generator=odd_even(numbers)>>>next(generator)'2 is even'>>>next(generator)'2 is even'>>>next(generator)'3 is odd'>>>forresultingenerator:...print(result)...11 is odd4 is even5 is odd7 is odd4 is evenTheodd_even()function can take one of two possible execution paths. If the number is even, then it runs theifblock, yielding the appropriate message. If the number is odd, then it runs theelseblock. In any case, theyieldstatement produces a value, pausing the execution until you request another value.You can call the function to obtain a generator object. Using the built-innext()function, you can retrieve items from the generator. After each call, the generator’s execution is paused until you demand another item. Note that theyieldstatement only pauses the item generation—it doesn’t pause the global execution of your code.Using the generator in aforloop causes the loop to request items one by one until the data runs out and the generator is exhausted.TheraiseStatementTheraisestatement interrupts the execution of a piece of code by throwing an exception. It lets you explicitly signal that an error or an unusual condition has occurred in your code. This is also a technique that you can use to control the execution flow of your code.Note:To learn more aboutraise, check out thePython’sraise: Effectively Raising Exceptions in Your Codetutorial.As an example of usingraiseto control the execution flow, say that you want to write a function to determine whether a given number is prime. Here’s a possible implementation:Python>>>frommathimportsqrt>>>defis_prime(number):...ifnotisinstance(number,int):...raiseTypeError(...f""integer number expected, got{type(number).__name__}""...)...ifnumber<2:...raiseValueError(f""integer above 1 expected, got{number}"")...forcandidateinrange(2,int(sqrt(number))+1):...ifnumber%candidate==0:...returnFalse...returnTrue...>>>is_prime(2)True>>>is_prime(1)Traceback (most recent call last):...ValueError:integer above 1 expected, got 1>>>is_prime(10)FalseIn this function, you first check if the input number isn’t an instance ofint, in which case you raise aTypeErrorexception. Then, you check if the input number is less than2, raising aValueErrorif the condition isTrue. Bothifstatements check for conditions that would cause errors during the function’s core functionality, implemented in the loop. In both situations, theraisestatement immediately jumps out of the function.ThewithStatementPython’swithstatement allows you to leverage context managers in your code. Acontext manageris an object that creates a context that lets you control setup and teardown tasks, such as closing open files, releasing network connections, and so on.When you enter the context, the setup tasks run automatically. Similarly, when you exit the context, the teardown tasks run. So, you’re not only sequentially running the code inside the context. You’re also running code defined in a different part of your program.Note:To learn more aboutwith, check out theContext Managers and Python’s with Statementtutorial.Arguably, the most popular use case ofwithis for working with files using the built-inopen()function. The following code creates a file and writes some text into it:Python>>>withopen(""example.txt"",mode=""w"",encoding=""utf-8"")asfile:...file.write(""Hello, World!"")...13Theopen()function returns a context manager. Its setup logic consists of opening the file and assigning the resulting file object to the variable after theaskeyword. Inside the context—represented by the indented code—you write some text to the file.After you finish processing the file, the context manager runs the teardown logic that consists ofclosing the fileand releasing the corresponding resources. The number13that appears in the output is the return value fromfile.write(), indicating the number of characters successfully written to the file.In short, the execution flow of your program jumps to the code of the file object, which is defined somewhere in the Python standard library. Then, it comes back to your code and runs the indented block. Finally, the execution flow jumps again to the code of the file object to properly close the physical file.Remove adsUsingtry…exceptBlocks to Control FlowIn real-world programming, things can go wrong. Files might not exist, user input may be invalid, network connections can fail unexpectedly, and so on. If you don’t handle these situations gracefully, then your code may crash or behave unpredictably.Python’stry…exceptstatement gives you a structured way to handle errors andexceptionswhen they occur. You can catch specific exceptions, take corrective action, or fail gracefully with a helpful message. However, those are only the core tasks that you can do withtry…exceptblocks. In Python, you’ll often use this statement as a control flow structure.Note:Python code often favors theEAFP(easier to ask forgiveness than permission) coding style based on exceptions, over theLBYL(look before you leap) style based on conditionals. This practice may sound weird to people who come from other languages, but you know, Python is different.In general, exceptions should be used to handle truly unexpected situations. For everything else, clear and explicit control flow is the better choice, since using exceptions for control flow can make your code harder to read and understand.This section will show you how to write more robust and reliable programs by anticipating and managing errors in a clean, readable way.Handling Errors Withtry…exceptBlocksThetrystatement is Python’s mechanism that allows you to catch exceptions that can occur in your code and gracefully handle them. The statement’s basic syntax is as shown below:Python Syntaxtry:<main_block>exceptexception_0[aserror_0]:<response_block_0>exceptexception_1[aserror_1]:<response_block_1>...exceptexception_n[aserror_n]:<response_block_n>Thetrykeywordstarts the statement that immediately jumps into an indented block. In this block, you’ll place the error-prone code that could raise an exception under certain conditions. Ideally, this code block should be short, containing only the code that can cause the issue you’re trying to handle.Note:You should keep the code block under thetrykeyword short and focused. If you include code that’s not directly connected with the issue you’re handling, then that code could raise a completely different exception, causing your handling strategy to fail.Theexceptkeyword catches the specified exception type if it occurs during the execution of your error-prone code. You can have as manyexceptclauses as you need, which is useful when your code has the potential to raise multiple different exceptions, and you need to respond differently to each of them.A good example of using thetrystatement to control the execution flow of a program is when you want to work with a file and want to ensure it exists. You can do this with a conditional that checks whether the file exists. However, in some situations, your code can fail because there’s a time gap between the check and the actual file manipulation.In this situation, instead of using a conditional, you can use atrystatement:PythonfrompathlibimportPathfile_path=Path(""/path/to/file.txt"")try:withfile_path.open()asfile:print(file.read())exceptOSErrorase:print(""file not found"")In this example, you wrap the file processing in atry…except. This code jumps directly into the file manipulation tasks, removing the gap between the check and the manipulation. If the file doesn’t exist, then the code will raise anOSErrorexception, which you catch and handle in theexceptcode block by printing an error message to the screen.If the code in question can raise multiple exceptions, and you want to provide specific solutions for each exception, then you can have variousexceptblocks. In this case, you should know that the order of the declared exceptions matters because Python stops at the first matchingexceptclause, even if there are other matching exceptions that follow.In contrast, if the code can raise multiple different exceptions, and you want to respond to all in the same way, then you can use the following syntax:Python Syntaxtry:<main_block>except(exception_0,exception_1,...,exception_n)[aserror]:<response_block>In this case, you use atupleof exceptions afterexcept. If one of these exceptions occurs while your code is running, then you can use a unified solution as a response in theexceptblock.Note:While Python currently requires multiple exception types to be enclosed in parentheses, theparentheses are optionalstarting with Python 3.14.To illustrate, suppose you’re reading product prices from a shopping cart system, and some prices might be wrong:Python>>>cart=[...{""item"":""Book"",""price"":""15""},...{""item"":""Pen"",""price"":""free""},...{""item"":""Notebook"",""price"":None},...]In this data, the prices of pens and notebooks aren’t valid numbers. If you try to make calculations with these values, then you’ll get an error, and your code will fail. You need to handle this situation to ensure the prices are valid integer numbers before proceeding with further processing.In this scenario, you can use the built-inint()function to convert the data into an integer. This function can raise two exceptions:ValueErrorwhen the argument can’t be parsed as an integer, like the""free""string above.TypeErrorwhen the argument’s type isn’t supported, like theNoneobject above.So, you need to catch both exceptions in your code. However, you’ll respond in the same way in both situations—you’ll only display an error on the screen. Here’s the code for this:Python>>>forproductincart:...try:...price=int(product[""price""])...except(ValueError,TypeError)ase:...print(f""Error: '{product['item']}':{e}"")...Error: 'Pen': invalid literal for int() with base 10: 'free'Error: 'Notebook': int() argument must be a string, a bytes-like object⮑ or a real number, not 'NoneType'When your code processes the price of pens, it raises aValueErrorbecauseint()can’t convert the""free""string to a number. Likewise, when the code processes the price of notebooks, it raises aTypeErrorbecauseNoneisn’t a supported type. In both situations, you respond with the same strategy: printing an error message to the screen.Remove adsRunning Post-Success Code With theelseClauseThetrystatement has optionalelseandfinallyclauses as part of its syntax. Theelseclause runs only if no exceptions are raised in thetryblock.Here’s the syntax that you must use if you need anelseclause:Python Syntaxtry:<main_block>exceptexception[aserror]:<response_block>...else:<block>In practice, theelseclause is useful when you need to separate error-handling code from post-success code. Here’s a quick example that processes the user input, makes sure it’s a valid number, and displays messages according to the result:Pythonuser_input.pyuser_input=input(""Enter an integer number: "")try:number=int(user_input)exceptValueErrorase:print(f""Error:{e}"")else:print(f""Success: you entered{number}"")In this example, you use theinput()function to grab the userinputon the command line. Then, you attempt to convert theinput into an integernumber in thetryblock. If this conversion raises aValueError, then you display an error message. If the conversion succeeds, then you print an appropriate message to inform the user.Here’s how the code works:Shell$pythonuser_input.pyEnter an integer number: 42Success: you entered 42$pythonuser_input.pyEnter an integer number: oneError: invalid literal for int() with base 10: 'one'As you can see, theelseclause provides a way for you to perform post-success actions in your code. These actions won’t run if the code fails.Cleaning Up With thefinallyClauseSometimes, you may need to run clean-up actions after the exception handling code. If that’s the case, then you can use thefinallyclause of thetrystatement.The syntax forfinallyis shown below:Python Syntax# Without exception handlingtry:<main_block>finally:<block># With exception handlingtry:<main_block>exceptexception[aserror]:<response_block>...finally:<block>This clause allows you to run clean-up actions because it runs unconditionally. In other words, it runs regardless of whether an exception was raised or not.When you combinefinallywith exception handling, then itmustalways go last. In all cases, thefinallyclause can’t appear more than once.Note:In most cases, you’ll use awithstatement and a context manager to automatically run clean-up actions instead of using afinallyclause in atry…exceptblock. However, there might be situations where you don’t have this option, andfinallymight be the way to go.Here’s an example that illustrates how to usefinally. Suppose you want to create an app that makes HTTP requests to anAPIand needs a key to access it. Your app should take the API key from the user and store it in an environment variable. Once you finish using the app, you’d like to remove the key from your environment.Here’s a toy implementation of this hypothetical app:Pythoncall_api.pyimportosimportrandomdefmain():user_key=input(""Please enter your API key: "")os.environ[""API_KEY""]=user_keyprint(f""Temporary API key set:{os.environ['API_KEY']}"")try:run_api_call(os.environ[""API_KEY""])exceptExceptionase:print(f""Error:{e}"")else:print(""API call completed successfully."")finally:delos.environ[""API_KEY""]print(""API key cleaned up!"")defrun_api_call(api_key):# Simulate an API callifrandom.choice([True,False]):print(f""Running API call with key:{api_key}"")else:raiseException(""API call failed."")if__name__==""__main__"":main()Insidemain(), you ask for the user’s API key using theinput()function. Next, you store the key in theAPI_KEYenvironment variable using theos.environmapping.In thetryblock, you do the API call usingrun_api_call(). If that call raises an exception, then you print an error message to the screen. Otherwise, you display a success message using theelseclause.Thefinallyclause is where you remove the API key from your environment to make sure that it doesn’t remain active after you finish working with the application. This clause will always run, so you can rest assured that the key will be cleaned up when the app terminates.Remove adsMatching Patterns Withmatch…casePython’smatch…caseconstruct is useful forpattern matching, which allows your programs to take different actions based on the result of comparing data against patterns. The first pattern that matches will define the execution path.Note:To dive deeper into thematch…casestatement, check out theStructural Pattern Matching in Pythontutorial.You should consider using amatch…casewhen you want to:Replace long chains ofifandelifconditionalsMatch data against different values, including structures like tuples or dictionariesBuild command dispatchers, parsers, or work with structured data, such as JSON, API responses, orabstract syntax trees (AST).The general syntax of amatch…casestatement in Python is as shown below:Python Syntaxmatchsubject:casepattern_0:<block_0>casepattern_1:<block_1>...casepattern_n:<block_n>case_:<defaultblock>Here’s a breakdown of this syntax:match subject:This line starts the pattern-matching block. Python evaluatessubjectonce and tries to match it against the patterns in eachcase.case pattern:Eachcasecompares a pattern against thesubject. If it matches, then Python runs the indented code block and skips the rest.case _:Thiscaseprovides a wildcard pattern. It matches anything if no earlier patterns succeed.In practice, patterns can match almost any Python object. For example, say that you need to write a function that can read different file formats, such asJSONandCSV. Each file format will demand a different setup.Here’s how you can use amatch…casestatement to deal with this situation gracefully:Pythonfile_reader.pyimportcsvimportjsonfrompathlibimportPathdefread_file(file_path):path=Path(file_path)ifnotpath.exists():print(f""File not found:{file_path}"")returnNonewithpath.open(mode=""r"",encoding=""utf-8"")asfile:matchpath.suffix.lower():case"".json"":data=json.load(file)print(""Loaded JSON data."")returndatacase"".csv"":reader=csv.DictReader(file)data=list(reader)print(""Loaded CSV data."")returndatacase_:print(f""Unsupported file type:{path.suffix}"")returnNoneIn this example, yourread_file()function takes a file path as an argument. It converts the path to apathlib.Pathobject and checks whether the file exists. If the file doesn’t exist, then you get an error message.If the file does exist, then you open it for reading using awithstatement and the.open()method of thePathclass. Thematchstatement grabs the file extension using the.suffixattribute. Then, you have acasethat compares the extension with the"".json""string, and anothercasethat compares it with"".csv"".If the file extension matches"".json"", then you use thejsonmodule to read the file’s content. Similarly, if the file extension matches"".csv"", then you use thecsvmodule to read the file. In both cases, you return the read data.Finally, you have acase _clause to match unsupported file formats. When you call the function with an existing file of an unsupported format, you get an error message.To try this script, you can run the following code:Python>>>fromfile_readerimportread_file>>>forfile_pathin[""test.json"",""test.csv"",""test.toml"",""test.txt""]:...result=read_file(file_path)...print(result)...print()...Loaded JSON data.[{'name': 'John', 'job': 'Software Engineer', 'country': 'USA'},{'name': 'Jane', 'job': 'Data Scientist', 'country': 'Canada'}]Loaded CSV data.[{'name': 'John Doe', 'job': 'Software Engineer', 'country': 'USA'},{'name': 'Jane Doe', 'job': 'Data Scientist', 'country': 'Canada'}]File not found: test.tomlNoneUnsupported file type: .txtNoneNote that this code will work if you have the listed files in your working directory. To test it with some sample data, click theShow/Hidetoggle below and copy the content to the appropriate files in your current working directory.Sample DataShow/HideJSONtest.json[{""name"":""John"",""job"":""Software Engineer"",""country"":""USA""},{""name"":""Jane"",""job"":""Data Scientist"",""country"":""Canada""}]CSVtest.csvname,job,country
John Doe,Software Engineer,USA
Jane Doe,Data Scientist,CanadaTexttest.txtname: John Doe
job: Software Engineer
country: USA

name: Jane Doe
job: Data Scientist
country: CanadaCommon Pitfalls and Best PracticesIn this final section, you’ll learn about some common mistakes that can occur when starting with control flow structures in Python. These include unintended infinite loops, conditions that are always true or false, overly broad exception handling, and deeply nested code. Such issues can lead to bugs, poor performance, and hard-to-read code.In the following sections, you’ll explore these issues and learn how to refactor your code to fix them using Python best practices. You’ll take a look at examples of problematic or buggy code and see how to improve them.Unintentional Infinite LoopsInfinite loops are helpful when you use them intentionally. For example, these loops are the standard when dealing with user events inGUI (graphical user interface)applications and for working withasynchronous code.Sometimes, a piece of code falls into an unintentional infinite loop. This can happen with awhileloop when the loop’s exit condition never becomes false. Consider the following example of a loop that suffers from this issue.🚫Problematic example:Pythoncount=0whilecount<5:print(""Counting..."")This loop might runforeverbecause thecountvariable is never updated inside the loop. Now, take a look at the fixed version of the loop below.✅Fixed example:Pythoncount=0whilecount<5:print(""Counting..."")count+=1When you face unexpected loop behavior like the one in this example, check the loop condition and make sure it’s properly updated. Additionally, check whether the condition will becomeFalseat some point during the execution.AlwaysTrueorFalseConditionsSometimes, you can face a situation where the condition of anifstatement is always true or false due to incorrect logic. Often, this happens because of minor mistakes in the condition itself. Consider the following toy example of a condition that’s always true.🚫Problematic example:Python>>>defuser_accepted_terms():...returnFalse# Simulates a user who doesn't accept the terms...>>>ifuser_accepted_terms:...print(""Access granted."")...else:...print(""Access denied."")...Access granted.In this example, the function that’s used as the condition was never called. So, the condition consists of a function object, which is always considered true in Python. To fix this issue, you need to check the condition and add the calling parentheses.✅Fixed example:Python>>>defuser_accepted_terms():...returnFalse...>>>ifuser_accepted_terms():...print(""Access granted."")...else:...print(""Access denied."")...Access denied.In this example, you fixed the condition by calling the function. When you face a similar situation, ask yourself whether the conditioneverevaluates toTrueorFalse, and double-check your assumptions.Wrong Order of ConditionsSometimes,elifclauses can lead to an issue where you may end up with branches that never run because the conditions are evaluated in the wrong order.For example, remember theFizzBuzzchallenge, where you getfizzfor numbers divisible by three,buzzfor those divisible by five, andfizz buzzfor those divisible by both three and five. Now, say that you follow the instructions in the same order you got them and implement the function as shown below.🚫Problematic example:Python>>>deffizzbuzz(number):...ifnumber%3==0:...return""fizz""...elifnumber%5==0:...return""buzz""...elifnumber%15==0:...return""fizz buzz""...else:...returnnumber...>>>fizzbuzz(3)fizz>>>fizzbuzz(5)buzz>>>fizzbuzz(15)fizzIn this implementation, you use anif…elif…elseconstruct. First, you check if the number is divisible by3, then by5, and finally by3and5(or15), as the problem description stated. However, this order doesn’t work because you getfizzfor15when you should be gettingfizz buzz.How can you fix this issue? Well, you can change the order of conditions as shown in the fixed example below.✅Fixed example:Python>>>deffizzbuzz(number):...ifnumber%15==0:...return""fizz buzz""...elifnumber%3==0:...return""fizz""...elifnumber%5==0:...return""buzz""...else:...returnnumber...>>>fizzbuzz(3)fizz>>>fizzbuzz(5)buzz>>>fizzbuzz(15)fizz buzzIn this new version, you’ve moved the condition that checks for numbers divisible by3and by5to the top of the chain. Now, the function works as expected, returningfizz buzzfor15.Too Broad ExceptionsUsing a bareexceptor catching broad exceptions likeExceptioncan hide bugs, swallow usefultracebacks, and make your code hard to debug. Below is an example of how this issue can affect your code in practice.🚫Problematic example:Python>>>try:...number=int(""abc"")...exceptException:...print(""Conversion error."")...Conversion error.This code works, but it hides what went wrong and prevents you from learning more about the issues that might be affecting your code. For example, say that you callint()withNoneas an argument:Python>>>try:...number=int(None)...exceptExceptionase:...print(""Conversion error."")...Conversion error.In this case, you get the same error message. However, this time, you’re not having a conversion error. It’s a different error because there’s no way to convertNoneinto an integer.A deeper code analysis will reveal that you can have either aValueErroror aTypeErrorexception. Each of them should generate a different error message. Take a look at the example below to learn how using more specific exceptions can help you write more robust code.✅Fixed example:Python>>>try:...number=int(""abc"")...exceptValueError:...print(""Error: value can't be converted to int."")...Error: value can't be converted to int.This time, you use a more specific and helpful exception. Now, what if you callint()withNoneagain? Here’s what you get:Python>>>try:...number=int(None)...exceptValueError:...print(""Error: value can't be converted to int."")...Traceback (most recent call last):...TypeError:int() argument must be a string, a bytes-like object⮑ or a real number, not 'NoneType'In this situation, you get aTypeErrorexception instead of your informative error message. Now you know that your code can raise a different exception. With this knowledge, you can fix the code:Python>>>try:...number=int(None)...exceptValueError:...print(""Error: value can't be converted to int."")...exceptTypeError:...print(""Error: data type doesn't support int conversion"")...Error: data type doesn't support int conversionIn this final version, you have a specific error message for each type of exception. In general, you should catch only what you can handle. Let other exceptions surface naturally. This practice will help you debug your code and make it more robust.Hard-to-Read Nested ConstructsDeeply nested constructs can make your code harder to read, understand, maintain, and debug. Consider the example below, which mimics a user authentication process.🚫Problematic example:Pythondefaccess_account(user):ifuser:ifuser.is_authenticated:ifuser.has_permission(""rw""):print(""Full access granted"")else:print(""Permission denied"")else:print(""Please log in"")else:print(""No user provided"")This function may work correctly. However, its three nesting levels make it hard to follow and obscure the intent. A flatter version will be better.✅Fixed example:Pythondefaccess_account(user):ifnotuser:print(""No user provided"")returnifnotuser.is_authenticated:print(""Please log in"")returnifnotuser.has_permission(""rw""):print(""Permission denied"")returnprint(""Full access granted"")This version uses guard clauses and earlyreturnstatements to improve readability, making the code’s intent more evident and easier to grasp.In practice, you should avoid more than two levels of nesting unless absolutely necessary. This recommendation applies not only to conditionals but especially to loops, where nested loops can make your code less efficient.ConclusionYou’ve explored the fundamental concepts ofcontrol flowin Python, including how to manage the execution order in your programs using conditionals, loops, and exception handling. You also delved into more advanced topics like recursion, comprehensions, and pattern matching withmatch…case.Learning about control flow is essential for you as a Python developer. It allows you to write more flexible, intelligent, and dynamic programs. Understanding these concepts is crucial for developing software that can handle a variety of conditions and respond gracefully to unexpected errors.In this tutorial, you’ve learned how to:Useconditional statementsto makedecisionsin your codeWriteforandwhileloops torepeatcode blocksRespond to errors withtry…exceptblocksUse structural pattern matching withmatch…caseblocksWith these skills, you’re ready to build more sophisticated Python programs that can make decisions, handle repetitive tasks, and manage errors effectively.Get Your Code:Click here to download the free sample codethat shows you how to use control flow structures in Python.Frequently Asked QuestionsNow that you have some experience with control flow structures in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What is control flow in Python?Show/HideControl flow in Python refers to the order in which code statements are executed or evaluated in your program. You can use control flow structures like conditionals and loops to alter the default sequential execution.What are common control flow statements in Python?Show/HideCommon Python control flow statements include conditionals with theif,elif,elsekeywords, loops with theforandwhilekeywords, and exception handling withtry…except. You also have pattern matching withmatch…caseblocks.When should you use flow control structures in Python?Show/HideYou should use flow control structures in Python when you need to make decisions, manage branching logic, repeat tasks, or handle errors and exceptions.Take the Quiz:Test your knowledge with our interactive “Control Flow Structures in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizControl Flow Structures in PythonIn this quiz, you'll test your understanding of Python control flow structures, which include conditionals, loops, exception handling, and structural pattern matching. Strengthening these skills will help you write more dynamic, smart, and robust Python code.Mark as CompletedShare"
The LEGB Rule & Understanding Python Scope,https://realpython.com/courses/legb-rule-python-scope/,"May 27, 2025",33m,"intermediate, python","The concept ofscoperules howvariablesand names are looked up in your code. It determines the visibility of a variable within the code. The scope of a name or variable depends on the place in your code where you create that variable. The Python scope concept is generally presented using a rule known as theLEGB rule.The letters in the acronym LEGB stand forLocal, Enclosing, Global, and Built-inscopes. This summarizes not only the Python scope levels but also the sequence of steps that Python follows when resolving names in a program.In this video course, you’ll learn:Whatscopesare and how they work in PythonWhy it’s important to know aboutPython scopeWhat theLEGB ruleis and how Python uses it to resolve namesHow to modify thestandard behaviorof Python scope usingglobalandnonlocalWhatscope-related toolsPython offers and how you can use themWhat’s Included:9 LessonsVideo Subtitles and Full Transcripts2 Downloadable ResourcesAccompanying Text-Based TutorialQ&A With Python Experts: Ask a QuestionCertificate of CompletionDownloadable Resources:Course Slides (.pdf)Sample Code (.zip)Related Learning Paths:Functional Programming With Python"
"Marimo: A Reactive, Reproducible Notebook",https://realpython.com/marimo-notebook/,"May 26, 2025",N/A,"intermediate, data-science, editors, python, tools","Table of ContentsHow to Get Started in a Marimo NotebookAdding Code and Markdown ContentTaking a First Look at ReactivityHow Marimo’s Reactivity Supports ReproducibilityAdding Code in an Unexpected OrderWorking Out the Cell Running OrderExploring Further Change ReactionsHow Marimo’s User Interface Elements Provide InteractivityCreating a Basic DashboardAdding InteractivityAdding the UI ElementsDisplaying the UI Elements in Your NotebookBringing the UI Elements to LifeTesting Your SkillsHow Marimo Makes Notebooks DistributableManaging the Notebook’s Environment With SandboxingPracticing SandboxingExporting a NotebookRunning a Notebook as a ScriptAdding Some Explanatory MarkdownCreating the ScriptWhy Linear Notebooks Don’t Quite Cut It AnymoreRedefinitionsCell Running OrderExpired Data RetentionConclusionFrequently Asked QuestionsRemove adsMarimo notebooksredefine the notebook experience by offering a reactive environment that addresses the limitations of traditional linear notebooks. With marimo, you can seamlessly reproduce and share content while benefiting from automatic cell updates and a correct execution order. Discover how marimo’s features make it an ideal tool for documenting research and learning activities.By the end of this tutorial, you’ll understand that:Marimo notebooksautomatically update dependent cells, ensuring consistent results across your work.Reactivityallows marimo to determine the correct running order of cells using adirected acyclic graph (DAG).Sandboxingin marimo creates isolated environments for notebooks, preventing package conflicts and ensuring reproducibility.You can addinteractivityto marimo notebooks usingUI elementslike sliders and radio buttons.Traditionallinear notebookshave inherent flaws, such as hidden state issues, that marimo addresses with its reactive design.Before you can get started with marimo, you’ll need to install it. Fortunately, this is quick and easy to do:Shell$python-mpipinstallmarimoYou usepipto install the marimo library on your system. With this done, it’s time to get started, be amazed, and learn all about a different type of notebook.The best way to approach this tutorial is to use the instructions to complete the various examples and try the exercises yourself. If you want copies of the various notebook files created during the tutorial, you’ll find them in your download bundle. TheREADME.mdfile provides further details of what’s in your downloads.Take the Quiz:Test your knowledge with our interactive “Marimo: A Reactive, Reproducible Notebook” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizMarimo: A Reactive, Reproducible NotebookThis quiz is a great way to reinforce and build on what you've learned about marimo notebooks. You'll find most of the answers in the tutorial, but you'll need to do some additional research to find some of the answers.How to Get Started in a Marimo NotebookA notebook is a file where you can write your programming code, run it, and view the output. You can add formatted text to explain how your code works, display charts to clarify results, and even allow your notebook’s users to try out different scenarios using a customized user interface. Once your notebook is complete, you can save everything in a single file and share your creation with others.In this section, you’ll learn to use marimo to create a simple notebook to perform a calculation and clearly display its results.Like many notebooks, marimo notebooks consist of cells. The primary cell types arecode cells, where you enter and run your Python code, andMarkdown cells, where you enter formatted text to augment the code and its output.In this first example, you’ll use a marimo notebook andNumPyto solve a pair ofsimultaneous equations. To do this, you’ll first need to install the NumPy library:Shell$python-mpipinstallnumpyWithNumPyinstalled, you can now create your notebook by typing the following command into your console:Shell$marimoeditsimultaneous_equations.pyWhen you run this command, you’ll most likely create a new notebook namedsimultaneous_equations.pyfor editing. If you already have a marimo notebook with that name, you’ll open it instead. Either way, your notebook will be ready for you to use within your browser.Switch to your web browser, and you’ll see your new notebook. It’ll contain a single cell. Hover your mouse over the cell to reveal a range of icons, each with a tooltip that explains its purpose and shows the associated keyboard shortcuts:Each of the main icons are described in the screenshot above. While most of these are self-explanatory, there are some points you should be aware of:Thered trash canicon shown here won’t appear immediately in your notebook. This is used to delete a cell and will only appear when you add other cells. You can’t see it yet because all notebooks must have at least one cell. Deleting the last cell is impossible.The color of theRun current cellicon is also significant. If this cell is white, as it is in the screenshot, it’s up to date and doesn’t need to be run. Once you start changing cells, you’ll see theirRunicons develop a yellow tinge. This warns you that the cell has becomestale, meaning you must run it to update it.Finally, notice that the numbers to the left of each cell indicate the line numbers of the code within the cell. Unlike most other notebooks, there are no numbers to indicate the running order of the cells. This is because marimo allows you to add code cells in any order. Marimo can work out the correct cell running order for itself. Even so, placing cells in an illogical order should be avoided.When you hover your mouse over some of marimo’s icons, you’ll see their associated keyboard shortcuts. Unfortunately, they don’t work correctly in all browsers. If they don’t work for you, stick to using your mouse. Feel free to try them to find out if they work for you.Remove adsAdding Code and Markdown ContentIt’s time for you to gain experience creating some content in marimo. By following the walk-through, you’ll get hands-on practice with the basics.Although confusing the first time you see it, the single cell that containsimport marimo as mois actually a blank cell. This code allows you to work with themarimo API. However, it’s not in the cell unless you type it in manually.Click inside the cell in your notebook, which looks as though it containsimport marimo as mo, and typeimport marimo as mointo the cell. Now, run the cell by clicking the cell’sRunicon, as shown in the screenshot above. Running this cell is necessary to allow you to work withMarkdownin subsequent cells.Next, add a new cell below this first one by clicking the plus (+) symbol at the bottom left of the existing cell.To allow information to be added into the new cell, click the smallView as Markdownicon. Markdown is good for creating documentation of your code or, in this case, instructions for using it to solve a problem.Enter the following text into your Markdown cell precisely as you see it here:Markdown Text**Problem:**Solve the following simultaneous equations using Python:

$4x + 2y = 34$

$2x - y = 31$As you type in the text, you’ll see the formatted version appear above where you’re typing. There’s no need to run a Markdown cell manually to see its output.Much of what you type appears as plain text. However, you use someMarkdown syntaxto add formatting. To bold the wordProblem:, you enclose it with double asterisks (**). To make both equations look more mathematical, you wrap them with dollar signs ($). Note that Markdown doesn’t recognize a new line, so you separated each line with a blank line to space out the wording the way you want it to appear.If you’ve typed in the code correctly, then your Markdown cell will look like this:If your output looks different from this, closely examine the text you typed and ensure it’s precisely what you intended to type.Next, you’ll solve both equations using thePython NumPylibrary.Add a new cell to your notebook. When you add a new cell, it’ll be a code cell by default. Now, type the following into this third cell:Pythonimportnumpyasnpcoefficients=np.array([[4,2],[2,-1]])results=np.array([34,31])solution=np.linalg.solve(coefficients,results)Your code will solve the simultaneous equations. You need to createarraysto use NumPy to solve a pair of simultaneous equations. Your first array, namedcoefficients, is a two-dimensional array consisting of the coefficients of both equations. In other words, the constants which multiply thexandyvariables. Your second two-dimensional array, namedresults, contains the results of each equation.You use thesolve()function from NumPy’slinalglinear algebra module to solve the equations. You pass both of your arrays intosolve()and receive another back, which you’ve namedsolution, that contains the solution to the equations.You could have seen the solution by addingsolutionas the last line of code, and marimo would have printedarray([12., -7.])above your code cell. The first element tells you thatx = 12, while the second tells you thaty = -7. Unfortunately, this approach isn’t very user-friendly, and there’s a better way.Insert another code cell into your notebook. Within this cell, you’ll display the solution to yourquadratic equationformatted using markup. To do this, type the following code into the newcodecell, then run it:Pythonmo.md(f""""""The solution to these simultaneous equations is:**x ={solution[0]}****y ={solution[1]}**"""""")Because this is a code cell, not a Markdown cell, you must run it to see its output.Note:There’s an important difference between using a Markdown cell, and using Markdown withinmo.md(). You can only type Markdown intoMarkdowncells. The output will appear automatically as you type. In contrast, you usemo.md()within acodecell to embed Python code within Markdown. You must run code cells to see their output.You pass in anf-stringcontaining the content you want to be displayed into marimo’smd()function. This function allows you to combine programming code with Markdown and format your output.Most of what you pass tomd()is text. However, by enclosing thesolution[0]andsolution[1]code within curly braces ({}), you define code to be run. As before, you use double asterisks (**) to apply bold formatting to the solution.In this case, you display the first and second elements of yoursolutionarray containing the answers. The result is now the more readable version shown below:Again, if you see something different, then check your code carefully.To round off this introduction, you’ll see why marimo is called areactivenotebook.Remove adsTaking a First Look at ReactivityEarlier, you learned that marimo is an example of a reactive notebook. This means that their cells react to changes made in other cells. For example, if you change the value of a variable in your notebook, all other cells using that variable will be automatically rerun and updated. If you’ve ever used aspreadsheet packagesuch as Microsoft Excel, then you’ve already seen something similar.To see marimo’s reactive capabilities in practice, update the highlighted code in the third cell of yoursimultaneous_equations.pynotebook to look like this:Pythonimportnumpyasnpcoefficients=np.array([[4,2],[2,-1]])results=np.array([50,23])solution=np.linalg.solve(coefficients,results)Now, run only that cell by clicking the yellowRunbutton in the top right of the cell. When you run the cell, your new code runs as expected. Take a look at the bottom cell in your notebook, and you’ll see that the output there has also changed:Although you did not run this cell manually, marimo ran it automatically because the code in this cell depended on the earlier code change you made. This cross-cell awareness is why marimo is said to be a reactive notebook. Unfortunately, the earlier pure Markdown cell didn’t change because pure Markdown cells are not reactive. For completeness, you might like to update it yourself manually.This tutorial provides many more examples of the power of reactivity. This first example was just a taster of what’s to come.You’ve finished this notebook, but there’s still lots more to learn. Yoursimultaneous_equations.pynotebook has already been saved for you. To close it, click the redXicon at the top right of the notebook, then selectShutdown.Next, you learn how reactivity gives marimo its power.How Marimo’s Reactivity Supports ReproducibilityAlthough cross-cell awareness is the core concept of reactivity, and the previous example of simultaneous equations illustrates its central point, reactivity also supports notebook reproducibility. This allows you to distribute your notebooks to others and be confident that the results they see are what you intend them to see.In this section, you’ll learn how reactivity supports reproducibility.Adding Code in an Unexpected OrderYour next notebook will allow you to calculate the length of a right-angled triangle’s longest side, orhypotenuse.This example is designed to show you that cell order in marimo doesn’t matter. However, arranging cells in this way is considered bad practice. Although the notebook will always produce the expected results even if it were distributed to another user, inserting code in a random order makes your notebook challenging to read.When working with marimo, as elsewhere with Python, it’s best to place your imports at the beginning of your code, and define your functions and variables before they are first used.Use the following code to get your new notebook started:Shell$marimoedithypotenuse_calculator.pyAs before, follow the steps outlined below carefully. Some of these steps will appear counterintuitive if you’ve used linear notebooks previously, but follow them anyway. As you’ll soon see, marimo knows what it’s doing even if it appears that you don’t.Click inside the first notebook cell and type the code shown below into this cell. TheRunicon will turn yellow to show that the cell needs to be run, but don’t run the code just yet:Pythondefcalculate_hypotenuse(opposite,adjacent):returnmath.sqrt(opposite**2+adjacent**2)Yourcalculate_hypotenuse()function calculates the hypotenuse of a right-angled triangle with two side lengths passed as itsoppositeandadjacentparameters. It uses the exponentiation operator (**) to square both lengths before adding them and finally usesmath.sqrt()to produce the answer. In other words, it usesPythagoras’ theorem, which you may remember from school.Now, perform these steps to complete your notebook:Add three new cells to your notebook by clicking theNew cell belowicon three times.Insert the variable declarationsopposite = 3into the first of these cells,adjacent = 4into the second, then the function callcalculate_hypotenuse(opposite, adjacent)into the third blank cell. Again, don’t run any of these cells just yet.Finally, although this may seem strange, add another cell below the four existing cells and insertimport mathinto it. This will allow marimo to use the available built-inmathmodule. Don’t run this cell, either.Before you go any further, make sure your notebook looks like this:As you look through each code cell, you might be wondering why you placed theimport mathcode in a cell long after it’s been needed by yourcalculate_hypotenuse()function. Although the import should have been placed at the top of the notebook for readability, you put it here to learn that marimo isn’t as concerned about cell order as you usually are.You can also see that because you’ve not run the cells yet, theirRunicons are showing as stale, and no output has been calculated. At this point, you could click each of the run icons from first to last in sequence. However, this would generate an error because marimo would attempt to access themath.sqrt()function before theimport mathcode was reached. But marimo has a trick up its sleeve.Look down toward the bottom right of your notebook, and you’ll see a single yellowRunbutton indicating staleness. This button allows you to run all stale cells. Click it now, and you’ll get a surprise:As you can see, your notebook has successfully calculated the hypotenuse to be5units without raising anyexceptions. Marimo has somehow managed to make everything work.Furthermore, if you distribute your notebook to someone, they would get the same results regardless of how the cells are ordered. The notebook is guaranteed to be reproducible. This doesn’t happen with poorly ordered cells in a linear notebook.But how can this be possible? Is it magic? Alas, not quite. However, all will be revealed next!Remove adsWorking Out the Cell Running OrderWhen you clicked theRun all stale cellsbutton, you told marimo to use itslazy modeto run the cells. Despite the derogatory name, lazy mode is one of marimo’s most powerful features.When you run a notebook in lazy mode, each cell is analyzed to determine whether it depends on any other cells and whether any other cells are dependent upon it. Marimo then uses this information to decide a running order for the cells. No cell can run unless everything it depends upon has already been run earlier, and any cells that depend upon others will be scheduled to run afterward.Mathematically, marimo forms adirected acyclic graph, or DAG, which organizes each cell into a specific order so that flow is always linear from an independent cell to a dependent cell, with no loops. Linear notebooks don’t do this—instead, they process cells in the order in which they’re defined.The calculation of the directed acyclic graph, which determines the correct cell running order, is why you can add cells to your notebook in any order you please without causing any problems.If you want to see the results of marimo’s internal DAG, you can use theExplore dependenciestool. You’ll find its icon toward the top left of your notebook:Unfortunately, the display quality within marimo isn’t very clear, so the image you see above has been doctored for display purposes. As you can see, it shows how your notebook has re-organized its cells based on how they relate to one another.If you look atcell-0in the screenshot, you’ll see that it depends oncell-4, as indicated by the arrow pointing toward it fromcell-4. In addition,cell-3is dependent oncell-0, as well ascell-1andcell-2. In other words,cell-3can only run aftercell-0,cell-1, andcell-2have all run successfully.Similarly,cell-0can’t run untilcell-4has been completed. This latter cell must be run first despite being defined last. Remember that this cell contains theimport mathcode.Feel free to explore theVertical TreeandMini Mapdisplay options. Also, try clicking on the cell markers themselves. For example, clickcell-0, and you’ll see it requires themathmodule as input before it can run and produce thecalculate_hypotenuse()function as output. You can explore the others in the same way.Once you’ve finished exploring the dependency information, click the smallXabove theHorizontal Treeview icon to close it and return to your notebook.Next, you’ll learn more about how marimo cells react to change.Exploring Further Change ReactionsWhen you use a notebook for research and experimentation, you’ll frequently want to see output for various inputs. In this section, you’ll see how marimo reacts to updates in cells. First, you’ll see what happens when you try to update a variable by redefining it later in the notebook.Add another cell at the bottom of yourhypotenuse_calculator.pynotebook, by clicking the plus (+) symbol as before. Then, in this new cell, assignadjacentan updated value of10using the codeadjacent = 10. Not unexpectedly, the cell’s run icon has turned yellow. Now, look at what happens when you run the cell using either of the run buttons, which are currently stale. As you can see, things haven’t exactly gone as planned:You can’t run this cell because you’ve already defined theadjacentvariable earlier in the notebook incell-2. Unlike in linear notebooks, when you update a variable that was already created elsewhere, you can’t overwrite the earlier version.Marimo won’t allow you to define the same variable in multiple cells because any cells depending on that variable won’t know which instance to use. Marimo couldn’t create a sensible cell running order with two conflicting cells. This would also ruin reproducibility.Instead, suppose you need to change the value ofadjacent, or any other variable for that matter. In that case, you must either change the cell containing the original variable or delete it and re-create it in another cell.Note:It’s possible to reassign a variablewithin the same cellas often as you please. This allows loop counters and running total calculations to work normally. It also means shortcut operators such as+=and-=can only reference variables in their local cells. If they tried to use aglobal variablefrom another cell, the reassignment would fail.If you want to create a local variable, in other words, one that only exists within one cell, you do so by prefixing its name with anunderscore (_)character. You could, for example, use code like_opposite = 10again and again in as many separate cells as you wish. Each cell would have its copy, but marimo would be happy with this because a version defined in one cell wouldn’t be accessible by code from any other cell.Remove the offending cell that contains the error by clicking its red trash can icon labeledDelete. Then, updateadjacent = 4toadjacent = 10in the original cell. ItsRunicon will once again turn yellow. This time, when you run the cell, reactivity will kick in again:You’ve probably noticed that the cell’s run icon turned white, indicating it’s no longer stale. The update has triggered reactivity in related cells because the hypotenuse’s original value has updated to approximately 10.44 from its previous value.Although only two cells are involved here, changing a cell in your notebook could trigger a chain reaction. Any cells relying upon those cells will be updated, and any cells relying uponthoseupdated cells will also be updated, and so on. It’s even possible that when you update a single cell in your notebook, you end up updating the entire notebook.Next, you’ll see what happens when you delete a cell. In your notebook, select the cell where theopposite = 3variable is assigned, then click the cell’s red trash can icon to delete it. Now, look at what happened this time:Immediately after you delete the cell, marimo raises aNameErrorexception. The cell where you callcalculate_hypotenuse()is feeling lonely because it can no longer access theoppositevariable that you’ve just deleted. The cell is no longer usable unless you either redefine the offending variable elsewhere or use theUndo cell deletionicon—the counter-clockwise arrow—at the bottom right of your notebook.By not allowing you to declare variables twice and highlighting when deletions cause problems, reactivity once again ensures that it’s impossible to distribute a notebook that can reproduce invalid data. This can occur with linear notebooks.Now that you’ve finished this section, you can close your notebook. To do this cleanly, resist the temptation to close the browser’s tab, but instead remember to do it the marimo way.Look down at the right-hand side of your screen, and you’ll see aSave fileicon containing an image of an old-fashioneddisk. If this icon has a yellow tinge, click it to save any unsaved data. Everything will probably already be saved because marimo does this automatically for you every second by default.Next, look for theShutdownicon at the top-right of your screen. It’ll have a red tinge. Click on it, then clickShutdownto close the notebook. When you switch to the terminal where you started marimo, you should see that it’s returned to the command prompt and thanked you for using marimo. In addition to being powerful, marimo is also well-mannered.By this stage, you’ve gained some experience using marimo, and you know why it’s called a reactive notebook. Next, you’ll learn about one of its coolest interactivity features: its UI elements.Remove adsHow Marimo’s User Interface Elements Provide InteractivityIn the hypotenuse calculation you created previously, you hard-coded the initial values of each variable into separate cells. If you wanted to change their values, you updated the cell, and marimo reacted by recalculating their related cells. This is fine if your variables never or only rarely change, and if the notebook recipient has the programming knowledge to make these changes. But what if they don’t?In some cases, you might want to give non-technical users of your notebook the ability to change the values being fed into a calculation to see what results their changes produce. Marimo allows users to make changes interactively using its various interactiveuser interface (UI)elements.Marimo’s UI elements provide users with standard widgets, such as radio buttons, sliders, text boxes, and so on, enabling them to enter and adjust data. Once the user has made changes through a UI element, marimo will react (pun intended) by updating any related cells automatically. What’s more, using UI elements is straightforward.Creating a Basic DashboardTo gain experience using some of the marimo UI elements, you’ll build up a notebook that performs abreak-even analysis. To begin with, you’ll write code that works out the break-even point for a fixed set of input variables. Then, you’ll add in some of marimo’s interactive elements to allow the inputs to be changed.What is a Break-Even Analysis?Show/HideWhen your business manufactures products, yourtotal costof manufacturing these products consists of both afixed costandvariable cost. Fixed costs are costs that don’t change regardless of the quantity of products you make. These include rent, salaries, and machinery. Variable costs vary with the quantity of products you make—for example, the cost of materials required to make each item.Abreak-even analysisreveals thebreak-even point, or the quantity of units your business must sell to recover the cost of production. If the number sold is less than the break-even point, you’ve incurred a loss. However, if your sales exceed the break-even point, you’ve made a profit.Suppose you’re in charge of a company that produces confectionery, like chocolate and ice cream. To set up your factory, you must spend $50,000. This covers the cost of your rent, machinery, and salaries. This is your fixed cost. The price to produce one box of your confectionery is $2, but you’ll sell it for $10. This $2 is your variable cost.You decide to analyze your business using marimo, then use interactive UI elements to investigate different scenarios.To begin with, you’ll useMatplotlibto create a plot displaying a break-even analysis.Run these two commands in your console to both installmatplotliband create a new notebook calledbreak_even_analysis.py:Shell$python-mpipinstallmatplotlib$marimoeditbreak_even_analysis.pyOncematplotlibhas been installed and you’ve run the second command, you should see the new notebook in your browser.This time, don’t delete the empty cell at the top of the notebook. Instead, you’ll use it for your library imports to keep things neat. Type the following code into this top cell:Pythonimportmarimoasmoimportmatplotlib.pyplotaspltFirst of all, you useimport marimo as moto allow you access to the marimo API as before. You won’t use the API yet. You also importmatplotlib.pyplotinto your notebook so you can draw the break-even plot.Now, add a new cell and type in the following code:Pythonfixed_cost=50000unit_cost=2selling_price=10upper_production_quantity=10000Here, you assign sample values to the four main variables used in the calculation. Although not necessary, keeping the variables together in a cell by themselves keeps things neat. Each variable is explained in the table below:VariableMeaningfixed_costThe total fixed costs required for production to commence.unit_costThe cost of making one confectionery item.selling_priceThe selling price of one unit of confectionery.upper_production_quantityThe upper bound of units you can produce.Later, you’ll map each of these variables to one of marimo’s UI elements to allow them to be dynamically adjusted. To begin with, you assign them specific values as test cases.To create the plot with the information you want to see, you’ll next need to perform some preliminary calculations using the variables you created above, then draw the plot using Matplotlib.Add another cell to your notebook and type in this code:Python1break_even_quantity=fixed_cost/(selling_price-unit_cost)2break_even_income=break_even_quantity*selling_price34units=range(0,upper_production_quantity+1,1000)5total_costs=[(unit*unit_cost)+fixed_costforunitinunits]6sales_income=[unit*selling_priceforunitinunits]78plt.plot(units,total_costs,marker=""o"")9plt.plot(units,sales_income,marker=""x"")1011plt.xlabel(""Units Produced"")12plt.ylabel(""($)"")13plt.legend([""Total Costs"",""Total Income""])14plt.title(""Break-Even Analysis"")1516plt.vlines(17break_even_quantity,18ymin=100,19ymax=break_even_income,20linestyles=""dashed"",21)2223plt.text(24x=break_even_quantity+100,25y=int(break_even_income/2),26s=int(break_even_quantity),27)2829plt.grid()30plt.show()Inlines 1 and 2, you perform the calculation that will reveal thebreak_even_quantityand thebreak_even_income. These tell you how many units you must produce to make neither a profit nor a loss, and the income you’ll receive if you make this quantity. You’ll need these figures to help you construct the plot.Line 4defines a Pythonrangeobject, whilelines 5 and 6define twoPython lists, each created with alist comprehension:unitscontains the range of quantities you might consider producing. Its default is10000, meaning your plot will display quantities between zero and ten thousand.total_costscontains your total costs for producing each quantity defined byunits. This includes both your fixed and variable costs.sales_incomecontains the income you’ll receive for each quantity defined byunits. You calculate this by multiplying each quantity sold by its selling price.You need these lists to store the data that you want to plot, which is what the remainder of your code does.Inline 8, you pass theunitsandtotal_costslists intoplot()to draw theTotal Costsline on the plot. Similarly, inline 9, you passunitsandsales_incometo create theTotal Incomeline. You also format your plot lines usingmarkerparameters ofoandx, respectively, for emphasis.To make your plot more straightforward to understand, you usexlabel(),ylabel(),legend(), andtitle()inlines 11 through 14to label the axis, add a title, and produce a legend that allows you to see what each line represents.To highlight the result of the break-even analysis, you add adashedvertical line to the plot using thevlines()function inline 16. This shows you the break-even point. You also adorn this line with thebreak_even_quantityvalue calculated inline 1, using thetext()function inline 23to position and display it.Finally, inlines 29 and 30, you display a grid on the plot and the plot itself.To view the plot, run the cell and it’ll appear as shown:As you can see, your code has displayed a break-even quantity of 6,250 units. If you produce more than this, then you’ll make a profit, but if you produce less, you’ll make a loss. If you produce exactly 6,250 units, you’ll break even.Of course, this result only tells you the situation for one specific set of figures. To see a range of possible answers, you could change the four key variables and rerun the cell each time to see how your changes affect the results. A far more user-friendly way is to use marimo’s user interface elements to help you adjust the values. You’ll do this next.Remove adsAdding InteractivitySuppose you’re reviewing your business options and have come to the following conclusions:Your fixed costs of $50,000 could be trimmed to $40,000 if you cut back elsewhere in the business.You could alter the cost price of your confectionery in increments of $1, between $2 and $5.You could change the selling price of your products to any value.You also want to ensure the plot can display production quantities of up to 15,000 units.To allow you to experiment with each of these combinations and see their effects on the break-even point, you’ll add some of marimo’s UI elements into your notebook. They’re all within its extensiveuser interface elementslibrary.In this example, you’ll use four different UI elements to give you an idea of what’s available. Once you complete this part of the tutorial, you’ll have the skills to work with any of the UI elements.Adding the UI ElementsIf you were starting from scratch with an empty notebook, then you’d need to locate the cell at the top of your notebook that contains the marker codeimport marimo as mo. Remember, this is a blank cell, so this code isn’t present. To use marimo’s UI elements, you need to type this code into a cell. To follow good practice, you type it into this first cell:PythonimportmarimoasmoThis allows you to use the marimo API with its conventional alias ofmo.Next, you need to add some code to alter the fixed costs dynamically to $40,000 or $50,000. One way to do this is to use aradioelement, which produces a set ofmutually exclusivechoices.Add another new cell into your notebook below the cell that contains the plot code, then add the following:Pythonui_fixed_cost=mo.ui.radio(options=[""40000"",""50000""],value=""50000"")First, you create a Python list containing two strings. These will form the option labels next to your radio buttons. You’ll be able to choose either one of them.You create the actual radio buttons usingmo.ui.radio(). You pass a list of possible choices to itsoptionsparameter and set the initial value to $50,000 by passing50000to itsvalueparameter. This means that$50000will be selected by default. You also assign the radio buttons to theui_fixed_costvariable. This is necessary to allow your plotting code to access their values, as you’ll see later.Next, you must alter the confectionary’s cost price in $1 intervals between $2 and $5. You use amo.ui.slider()element for this task. The slider allows you to select a value by sliding a little dot along a trough with your mouse.To create the slider, add the following code to the same cell below your radio buttons:Pythonui_unit_cost=mo.ui.slider(start=2,stop=5,step=1)You create the slider element by passing instartandstopvalues toslider(). These indicate the lower and upper values you can select. In addition, thestep=1parameter allows you to change the slider in increments of 1. In other words, you may use it to select either $2, $3, $4, or $5. This time, you assign theslider()to theui_unit_costvariable.Next, you want to be able to adjust the selling price to any value. To do this, you use amo.ui.text()element. This provides a text box to type in any desired value. Just ensure you enter a number. Otherwise, your code will crash since you won’t implementerror handlingin this exercise.To create the text box, add the following code to the same cell, on a line below your slider:Pythonui_selling_price=mo.ui.text(value=""10"")This time, you decide onvalue=""10"", which gives the text element a default selling price of $10. Text boxes allow you to enter anything you like, as you’ll see later. You assign the text element to theui_selling_pricevariable.The final adjustment you want users to make is to set the plot’s width to display production quantities of up to 15,000 units. You could do this using amo.ui.dropdown()element, which provides an expandable list of values from which you select one.To define your final element, add the following code to your cell:Pythonui_quantity=mo.ui.dropdown(options={""10000"":10000,""12000"":12000,""15000"":15000},value=""10000"",)You create the items you want users to choose from by assigning a dictionary to theoptionsparameter ofmo.ui.dropdown(). Each dictionary key defines the items you want to be selectable, while the values are what gets returned. The default value is""10000"", so it’ll return10000. Although the keys are strings, the values, in this case, are integers, which is what you want. It’s irrelevant here, but the keys and their values could differ.Remove adsDisplaying the UI Elements in Your NotebookTo make the various user interface elements available, you must display them in your notebook. You can do this using themo.md()function you saw earlier. To see this working, enter the following code into your cell below your UI definitions:Pythonmo.md(f""""""Fixed Costs:{ui_fixed_cost}Unit Cost Price:{ui_unit_cost}Selling Price:{ui_selling_price}Maximum Production Quantity:{ui_quantity}"""""")As before, you passmo.md()anf-string, allowing you to embed code within Markdown. Here, your code is the UI element variables you defined above. Again, you refer to them from within curly braces ({}). When you run this cell, the UI elements you created will be shown in a neatly formatted layout:If your output differs, review the code, correct any typos, and rerun its cell.As you can see, the four UI elements you defined are all displayed, although they’re not yet functional. While you can certainly click, type, and slide the UI elements, your plot won’t react to your changes, at least not yet.Bringing the UI Elements to LifeTo make the plot react to changes in the UI elements you’ve just created, you must reference the elements within the code that draws the plot. Then, each time you update an element, marimo reacts to the change by rerunning the plot’s code and displaying a revised version.When you use a UI element, the value you set is assigned to the element’s.valueattribute. So, for example, when you select the40000radio button, theui_fixed_cost.valueattribute gets assigned40000. To read this from within your code, you referenceui_fixed_cost.value.To link the UI elements to your plot’s code, you should update your plot code’s main variable assignments to look like this:Pythonfixed_cost=int(ui_fixed_cost.value)unit_cost=ui_unit_cost.valueselling_price=float(ui_selling_price.value)upper_production_quantity=ui_quantity.valueHere, you assign each UI element’s.valueattribute to the corresponding break-even calculation variable.To correctly populate thefixed_costandselling_pricevariables, youcastthem to anintandfloat, respectively. You did this because both radio buttons and text boxes return strings. These must be converted to allow the plot generation code to understand them. You didn’t cast theslider()ordropdown()elements because these return integers natively.To test your efforts, you must first run the cell containing these updated variable assignments. As always, the yellow tinge on itsRunbutton reminds you to do this. Once you’ve run the cell, you can play with the various UI elements and test your scenarios.Your plot automatically updates each time you adjust. This occurs because each time you change a UI element, the change filters through to its associated variable, causing the plot definition cell to rerun in reaction to your change.This is yet another example of the power of marimo’s reactivity in action. Time for a workout. It’s your turn to shine.Testing Your SkillsNow that you’re familiar with creating a user-friendly notebook, it’s time to test what you’ve learned so far and try the following exercise:Exercise: ""Using a Marimo Notebook""Show/HideSee if you can add the following functionality to your notebook:Add an appropriate UI element that allows users to hide or display the break-even point and its value.Add an appropriate UI element that allows users to select a color for theTotal Costsplot of red, green, or blue.Feel free to look at themarimo documentationfor help. One possible solution is included in thebreak_even_analysis_solution.pynotebook file you’ll find in your downloads.Now, see if you can do this:Exercise: ""Challenge Exercise""Show/HideOpen up thesimultaneous_equations.pynotebook you created earlier. Now, see if you can update it to allow you to insert any coefficients you like into UI elements and display their results.For example, your input area might look like this:Which should produce results that look something like this:Again, feel free to look at the marimo documentation for help. One possible solution is included in thesimultaneous_equations_ui.pynotebook file in your downloads.By now, you know that one of the strengths of marimo is its reproducibility. In the next section, you’ll learn more about how marimo supports notebook distribution. Go ahead and close any open notebooks—you’ll be creating a new one shortly.Remove adsHow Marimo Makes Notebooks DistributableMany everyday use cases for notebooks require them to be shared. Sharing notebooks does have potential problems, one of which is ensuring reproducibility. You’ve already seen how marimo is designed to support reproducibility through its reactivity, but that only solves part of the problem. In this section, you’ll learn more about how marimo makes notebooks easy to distribute.Managing the Notebook’s Environment With SandboxingWhen you distribute a notebook, you assume its recipient knows what additional packages are required to allow your notebook to run. For example, external packages such aspandasand Matplotlib might be needed for data analysis and plotting, respectively. In addition, the notebook may require specific versions of these to run correctly on a recipient’s computer. If the packages aren’t present, the notebook can’t run.Installing these missing packages may cause other issues. If the recipient already uses a different version of a required package, then updating it to run your notebook could break their existing code. Fortunately, marimo takes care of these environment management issues using sandboxing.When you run a notebook in a sandbox, you do two things. First, you create a temporary virtual environment for it to run in. This is similar in concept to thePython virtual environmentsyou may already be familiar with. If a package is installed within a sandbox, regardless of its version, it won’t interfere with anything outside that sandboxed environment.Second, when you create a notebook in a sandbox, marimo will track the required packages and their versions and write this information into the notebook’s underlying Python file. This means that when you share the notebook, a note of the packages required to support it is also included.Furthermore, provided the recipient runs your notebook in a sandbox, these dependent packages will be installed automatically into a virtual environment before the notebook’s code runs. Once the recipient closes your notebook, its sandbox and installed packages disappear. So, once you’ve created your notebook, you can quickly and safely share it with others.Because sandboxing isn’t enabled by default, you must do so manually using the--sandboxflag as follows:marimo edit --sandbox notebook.py:Allows you to create a new notebook or edit an existing one in a sandbox. It also checks the required dependencies and offers to install them if they’re absent. What’s more, marimo continues to maintain package tracking as you update the notebook.marimo run --sandbox notebook.py:Allows you to open an existing notebook in a sandbox, install the required dependencies, and run the notebook in read-only mode.marimo new --sandbox:Allows you to create a new notebook in a sandboxed environment.Note:To use marimo’s sandboxing feature, you must first install theuvpackage manager. You do this usingpython -m pip install uv, which marimo needs to install packages.Next, you’ll learn how to use sandboxes.Practicing SandboxingIn this section, you’ll create a new notebook within a sandbox. You’ll see how this affects its underlying code, then run it in a second sandbox to simulate a notebook’s distribution in a remote user’s environment.To begin with, run the following commands in your terminal to install theuvpackage manager and create a new notebook calledpackages.pywithin a sandbox:Shell$python-mpipinstalluv$marimoedit--sandboxpackages.pyBefore you type any code into your notebook, take a quick look at the packages that are already available to your notebook by clicking theManage packagesicon as shown below:Although marimo comes preinstalled with several packages, pandas isn’t one of them. Next, you’ll write some pandas code, but you won’t install pandas just yet.By default, marimo will install packages usingpip. To register packages within a sandbox, you must instruct marimo to useuv. To set this globally, select theSettingsicon at the top-right of your screen, then chooseUser SettingsandPackage Management. Finally, set theManagerasuv. Click theXto close this window. The screenshot below illustrates this:Once you’ve set upuvas the package manager, you can type the code shown below into the first cell of your notebook, still without installing pandas:Pythonimportpandasaspddata={""rank"":[1,2,3],""language"":[""Python"",""Java"",""JavaScript""]}languages=pd.DataFrame(data)languagesYour code creates and displays a simplepandas DataFrame. Now run your notebook cell. The cell doesn’t run but has raised aModuleNotFoundErrorexception instead. As you can see from the traceback below the cell, it can’t find pandas. Fortunately, help is at hand:Go ahead and click theInstallbutton to install the latest version of pandas into your sandbox usinguv. Once the installation is complete, the cell will now run cleanly. If you click theManage packagesicon twice, you’ll see pandas added to the list of installed packages.When you installed pandas, because you’ve enabled sandboxing, details of the pandas installation were written into the notebook’s underlying Python file in line withPEP 723guidelines. If you openpackages.pyin your favorite Python editor and take a look at the top of the file, you’ll see something like this:Pythonpackages.py# /// script# requires-python = "">=3.13""# dependencies = [#     ""marimo"",#     ""pandas==2.2.3"",# ]# ///Because sandboxing is being used, marimo has written details of the additional packages it needs at the top of the file. This means that when you distribute your notebook, the recipient doesn’t need to know which additional packages are required, or install them in advance, because marimo already knows what it needs. Note that your version numbers may be different from those shown.Note:It’s best if the recipient of the notebook installsuvin their environment to ensure the packages the notebook requires won’t interfere with any existing ones they may already be using.You can simulate distributing your notebook elsewhere by opening it on your computer. First, make sure to deactivate any virtual environment you might have activated. Then, run themarimo run packages.pycommand. You’ll be asked if you want the notebook toRun in a sandboxed venv containing this notebook’s dependencies.AnswerY(es)to this question.Once marimo has started, you only need to wait a short time for the packages to be installed. Your notebook will open in read-only mode because you usedmarimo runinstead ofmarimo edit. Then, once its cells have run, you’ll see the results. When complete, pandas will have been installed into the sandbox without interfering with any other Python environment you may already have.Of course, distributing notebooks in this way is fine if your end user is familiar with them. However, this isn’t always the case. You’ll see how marimo copes with this problem next.Remove adsExporting a NotebookSometimes, you may want to distribute your notebook to someone who doesn’t use marimo or has never had the pleasure of using Python. Fortunately, marimo allows you to export your notebook in various formats. Suppose, for example, you want to download your notebook as anHTMLfile.First, you run the entire notebook and make sure that you can see its results. Then, you select the icon containing three lines in the top-right corner of your screen as shown below:Next, selectDownload, thenDownload as HTML. When you look in your browser’s download folder for the HTML file, you’ll see it named after your notebook, only with an.htmlextension.Unfortunately, your UI elements won’t work. However, if you click theRun or edit this notebookbutton at the top-right corner of your browser screen, you’ll get some advice for running it online usingWebAssembly. Feel free to explore this if it’s of interest to you.Note:In addition to using the graphical user interface (GUI) to export notebooks, you can also export them using commands. For example,marimo export html notebook.py -o notebook.htmlwill perform the same export you performed above. The documentation shows that marimo’sexport capabilitiesare extensive.Next, you’ll learn how to run the underlying marimo Python file as a Python script.Running a Notebook as a ScriptAs you know, marimo notebooks are Python files. They don’t use special formats other than a fewdecoratorsfor their internal use. This means that you can run a notebook file in the same way you run any other Python script file.You might be wondering about code order. If your notebook contains code that’s out of order, marimo can still handle it, but can such a file be run as a script? After all, the order of Python code is essential. You’ll investigate this next.Adding Some Explanatory MarkdownClose any open notebooks and create a fresh one namedquadratic.py. You don’t need to use a sandbox for this example. Typeimport marimo as moin the top cell to ensure Markdown works. Then, look for the row of icons below your notebook’s cell and click the one labeledMarkdown. This will add a new cell for note-taking.Now, very carefully, type the text below into the cell:Markdown TextA quadratic equation is one of the form**$ax^2 + bx + c = 0$**,
where $a$, $b$, and $c$ are constants, and $a \neq$ 0.

You can solve it using the_quadratic formula_:

$$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$

For example, suppose you wanted to solve:**$2x^2 - 3x - 2 = 0$**Remember, unlike Python cells, you don’t need to run Markdown cells because they update themselves as you type. If you’ve typed everything correctly, the output part of your cell should look like the screenshot below. If not, see if you can fix it before you go any further:Much of what you see in the output is what you typed into the cell. However, you’ve also added some Markdown formatting andLaTeXto it.Markdownis a markup language for creating formatted text using a text editor. If you look at the twoquadratic equationsin your output, they display inboldbecause you surrounded them with a pair of double asterisks (**). In other words**$ax^2 + bx + c = 0$**. Toitalicizethe quadratic formula words, you surround them with a single underscore (_).You produce the mathematical content of your output using LaTeX. You type$ax^2 + bx + c = 0$to create the quadratic equation in the first line. By surrounding it with dollar signs ($), you give it a mathematical appearance. You also use dollars for thea,b, andcconstants and the inequality at the end of the sentence for the same reason. Try removing the dollar signs, and you’ll see the difference they make.Most of the characters in your LaTeX equation display directly on the screen, albeit using an algebraic format. For example, the𝑥character is somewhat rounded. You use the caret (^) symbol to display exponentiation, so the2, indicating squaring, appears in superscript. Toward the end of the first sentence, you use\neqwithin$a \neq 0$to produce the inequality symbol commonly used in mathematics.You use the central piece of LaTeX,$$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$, to display thequadratic formula. This time, because you want to display the formula in a line by itself, you enclose it within a pair of dollar signs ($$).You also use\fracto display the equation as afractionso that its numerator, that’s everything enclosed within the outer pair of curly braces ({}), appears in a line above its denominator. You then define the denominator,{2a}, using a second pair of curly braces next to those of the numerator. To display the plus-or-minus symbol, you use\pm, while\sqrtgives you a square root symbol around theb^2 - 4accharacters within the numerator’s inner curly braces.The main point of this section is to see how a notebook containing poorly ordered cells will cope when it’s run as a script. Now that your reader knows what they’ll be doing, you can add the Python code to solve your quadratic equation.Add seven new code cells into your notebook below the Markdown cell and enter the following code into them:Python# Cell 3x1=(-b+math.sqrt(b**2-4*a*c))/(2*a)# Cell 4x2=(-b-math.sqrt(b**2-4*a*c))/(2*a)# Cell 5a=2# Cell 6importmath# Cell 7b=-3# Cell 8c=-2# Cell 9print(f""x ={x1}and{x2}."")Once you’ve completed your coding, cells three through nine in your notebook should look like this:You add code to your notebook’s third and fourth cells to calculate the two possible values of a quadratic equation.You insert variable declarations into the fifth, seventh, and eighth cells, while the sixth cell is where you import the built-inmathmodule. There’s no need to install this module since it ships with Python.Then, you use the ninth cell to call another built-in function, theprint()function, to print the quadratic equation’s solutions. Although thisprint()isn’t necessary in the notebook, you’ll need it when you run your code as a script.Feel free to run your notebook in marimo. Even though you created the cells out of order, marimo has sorted them out for you as you expected. The solutions arex = 2.0 and -0.5.With all the coding complete, you’re ready to create the script.Remove adsCreating the ScriptIn the terminal where yourquadratic.pyfile is saved, run the following command:Shell$marimoexportscriptquadratic.py-oequation.pyThis will extract yourquadratic.pynotebook Python file into anequation.pyscript. Now run it and see what happens:Shell$pythonequation.pyx = 2.0 and -0.5.As you can see, everything has worked perfectly. None of the Markdown has appeared, but the results have. How can this be, given that the calculation code is out of order?Quick! Openequation.pyin your favoritePython code editorand you’ll find out:Pythonequation.py__generated_with=""0.13.6""# %%importmarimoasmo# %%mo.md(r""""""A quadratic equation is one of the form **$ax^2 + bx + c = 0$**,where $a$, $b$, and $c$ are constants, and $a \neq$ 0.You can solve it using the _quadratic formula_:$$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$For example, suppose you wanted to solve: **$2x^2 - 3x - 2 = 0$**"""""")# %%a=2# %%importmath# %%b=-3# %%c=-2# %%x1=(-b+math.sqrt(b**2-4*a*c))/(2*a)# %%x2=(-b-math.sqrt(b**2-4*a*c))/(2*a)# %%print(f""x ={x1}and{x2}."")The file contains Python code. Marimo uses special comments (# %%) to separate the code into different cells.Everything runs perfectly because when it created the script, marimo reordered the code into a sensible running order, in the same way as it does when you run unordered cells in marimo directly. When you look down through the code, you see that the import is placed toward the top, and all variables are declared before they’re used. Python was quite happy to run your code without issue and return the correct result.Note:One of the other advantages of marimo notebooks is that because they’re Python files, you’re simply changing Python code whenever you make a change. This makes them very easy to track on version-tracking systems such asGit or GitHub. Although other notebook formats can be stored on these systems, because such notebooks useJSONor a proprietary format, changes are much harder to track and manually see.To wrap up, you’ll revisit these concepts in a Jupyter Notebook to highlight the advantages of reactive notebooks.Why Linear Notebooks Don’t Quite Cut It AnymoreIn this final section, you’ll learn about some of the problems associated with linear notebooks. Although this section won’t teach you more marimo techniques, it’ll make you appreciate why reactive notebooks outperform their linear ancestors.You’ll need Jupyter Notebook installed on your computer to recreate these examples. To recreate the problems highlighted, you should also have abasic knowledge of Jupyter. Alternatively, you can just read the section passively.RedefinitionsWhen you run code in a linear notebook such as aJupyter Notebook, the code for each notebook is run in a process called itskernel. The kernel is where your notebook stores its variables, function definitions, and any other objects it needs to run—in other words, the program’s state. Unfortunately, this architecture produces something called thehidden state problem.To understand the problems the hidden state can cause, look at the screenshot below. It shows a series of cells in a Jupyter Notebook. The numbers in square brackets ([n]) down the left side show the order in which the cells were run—in other words, linearly. The yellow disks on the right are used to reference the cells from within this tutorial:The code is similar to the Pythagoras code you used in an earlier notebook you created in this tutorial. If you want to recreate your version of this notebook, you can do so by typing up the code as shown. Alternatively, you could use thehidden_state.ipynbfile you’ll find in your downloads.Once you have your notebook, you can ensure everything runs linearly by selecting theKernelmenu, then choosingRestart KernelandRun All Cells. You should see the output shown above.In the first cell, the one annotated with the yellow number one, you import the built-inmathmodule to allow you access to itssqrt()function.In the second cell, you then definecalculate_hypotenuse(), which calculates the hypotenuse of a right-angle triangle when you pass itsoppositeandadjacentside lengths. The function uses the exponentiation operator (**) to square each length, andmath.sqrt()to find the square root of the sum of these squares. This is the hypotenuse.In the third and fourth cells, you define the initial lengths for a triangle’soppositeandadjacentsides. You calculate the hypotenuse of your triangle by callingcalculate_hypotenuse()in cell five. The answer is 5.0 units.Now, take a careful look at cells six and seven. In cell six, you redefine the value ofoppositeas5before using cell seven to recalculate the updated hypotenuse. To calculate, you use your newoppositevalue of5and your existingadjacentvalue of4. This value is still available because it’s stored inside your notebook’s kernel.You then run another version of the calculation by updatingadjacentto12in cell eight, and callingcalculate_hypotenuse()again. This time, your function uses the latestadjacentvalue of12plus the most recentopposite=5value defined in cell six. The hypotenuse now has a length of13.Although everything works as expected, your notebook contains historical data that may confuse you. When you updateoppositefrom3to5in cell six, even though cell seven produces a correctly updated hypotenuse when it’s run, the output produced by the original running of cell five doesn’t change. It still retains the previous value of5.0.While you may be happy with this as a historical record, sometimes it’s preferable that updates in one cell automatically update related cells to keep things consistent.Fortunately, this problem can’t exist in marimo for two reasons. First, marimo doesn’t allow you to declare the same variable in two different cells. Second, marimo’s reactivity means any changes in one cell automatically trigger updates elsewhere.Remove adsCell Running OrderYou may also encounter the hidden state problem when cells run out of order. To see the effect of this, consider this updated version of your notebook:In this version of your notebook, you’ve still defined cells six and seven in their original order. However, you’ve run them in reverse order. You can do this for yourself by performing the following steps:From theJupyterLabor Jupyter Notebook menu, choose theKernelmenu, then selectRestart Kernel and Clear Outputs of All Cells. This will clear all existing content, providing a fresh base from which you can work.Select the cell marked with the yellow one and run it. Then repeat for cells marked with the yellow two, three, four, and five. Because you’ve run these cells in their original order, the results will be the same as earlier.Now run the cell marked with the purple seven, then run the cell marked with the purple six. Note that you’re running these out of order.Next, conveniently forget to run, in other words ignore, the cell marked with the green eight.Finally, run the cell marked with the yellow nine.If you’ve done this correctly, your results should match those in the screenshot. If not, perhaps you’ve missed a step. You’ll need to restart the kernel and clear everything once more.When you run cells out of order in a linear notebook, you can cause problems. Look at the output of cell six. You’ll see it’s incorrect. It hasn’t changed from the previous output you obtained when you ran cell five. You still use the originalopposite=3andadjacent=4values. Theopposite=5value wasn’t used because it only existed in the kernel when you ran cell seven,afteryou ran cell six.A problem like this can make notebooks very difficult todebugand share. You usually run linear notebooks from start to finish without missing any cells. If you sent your linear notebook to someone else, then they might get a different result than you intended when they run it.In its current form, your notebook isn’t reproducible unless you provide instructions on how others should run it. If you’ve genuinely forgotten to run one or more cells, you may even have problems reproducing your earlier results in the future. Furthermore,debuggingthis problem can be difficult when large notebooks are involved.More confusion occurs when you run cell eight. Although this cell now usesopposite=5, because youforgotto run the cell that setadjacent=12, the originaladjacent=4value was again used. Anyone casually reading your notebook would likely think theadjacent=12was being used.Why not rerun the notebook linearly to see the confusion? ChooseKernel, thenRestart Kernel and Run All Cells. You should see the original results, which are what others will see if you don’t explain to them what the correct running order should be.Although it’s possible in a marimo notebook to run cells individually in any order you please and even ignore some of them, neither of the above problems can occur if you run all cells in your notebook. This will highlight any duplicate variable declarations and reorder cells into a single, correct running order for you.Expired Data RetentionAnother issue with the kernel is that it still stores content even after you delete the cells defining it. So, if you were to delete a cell containing a variable assignment or a function definition, cells using these would still function because although they’re unseen, they’re still in the kernel. That’s why you should always restart the kernel after changing anything in a linear notebook. That will clear out expired data permanently.To see this problem, take a look at the screenshot below:The upper left-hand screenshot shows a new Jupyter Notebook being run for the first time. You can simulate this with one of your existing notebooks by choosingRun … Run All Cellsfrom the menus. As you can see, all cells are run in order and produce the expected output.The lower right-hand screenshot shows the same notebook, only with the upper two cells removed. Once again, choosingRun … Run All Cellsgenerates the same result.This can also confuse anyone reading the notebook because it wouldn’t be immediately clear what’s happening based on what’s available. Furthermore, the next time the kernel is restarted or the notebook is passed to another person, it would fail to run because neither the import norcalculate_hypotenuse()code would be present.As you can see, although retaining variables in the kernel allows cells in a notebook to be run without error, their results may not be what you expect. It creates an illusion of incomplete code that’s working mysteriously correctly. This would cause a problem for anyone receiving your notebook.Marimo solves this problem using reactivity. It makes sure that when a cell, or even the content within a cell, is deleted, any cells depending on those deletions raise an error.ConclusionBy now, you not only know how to create a marimo notebook, but also how it can decide for itself the order in which its code should run. You’ve seen various examples of the benefits reactivity brings to your notebook when you alter its cells, add common user-interface elements, or even add confusing duplicate code.Additionally, you’ve seen how marimo supports notebook distribution through sandboxing and how to convert notebooks into alternative formats for use outside the marimo environment. You also understand that the problems associated with traditional notebook environments don’t exist in marimo.In this tutorial, you’ve learned:How tocreatea marimo notebookWhat’s meant byreactivityHow marimomakes senseof unordered code cellsHow to addinteractivityto your notebookHow todistribute notebookseasily and safelyTheinherent flawsof linear notebooksAlthough you’ve had a thorough learning experience with marimo, there’s still lots to learn. You’re encouraged to review the official marimouser guideto learn more.There are also some tutorials available within marimo itself. To see the current list, typemarimo tutorial --helpinto your terminal. If you see a tutorial you fancy, then type inmarimo tutorial, followed by the name of the tutorial you wish to work through.The marimo developers have also made severalexample notebooksavailable for you to learn from.Frequently Asked QuestionsNow that you have some experience with marimo notebooks in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.How do you create a new marimo notebook?Show/HideYou create a new marimo notebook by using the commandmarimo edit <notebook_name>.pyin your terminal.What is the difference between a reactive notebook and a linear notebook?Show/HideIn a reactive notebook, cells automatically update when you change dependent variables, while in a linear notebook, you must manually rerun cells in the correct order.How does a marimo notebook run correctly regardless of cell order?Show/HideMarimo uses a directed acyclic graph (DAG) to determine the correct running order for cells, ensuring the notebook runs correctly even if the cells are added in an unexpected order.What is the purpose of marimo's sandboxing feature?Show/HideMarimo’s sandboxing feature creates a temporary virtual environment for your notebook, ensuring that the required packages are isolated and don’t interfere with other projects.How can you add interactivity to a marimo notebook?Show/HideYou add interactivity to a marimo notebook by using marimo’s user interface elements, like sliders and radio buttons, to allow users to adjust data and see the results immediately.Take the Quiz:Test your knowledge with our interactive “Marimo: A Reactive, Reproducible Notebook” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizMarimo: A Reactive, Reproducible NotebookThis quiz is a great way to reinforce and build on what you've learned about marimo notebooks. You'll find most of the answers in the tutorial, but you'll need to do some additional research to find some of the answers.Mark as CompletedShare"
Nested Loops in Python,https://realpython.com/nested-loops-python/,"May 21, 2025",N/A,"basics, python","Table of ContentsGetting Started With Nested Loops in PythonExploring Practical Examples of Nested LoopsPrinting Patterns With Nested LoopsGenerating a Multiplication TableSumming Elements in Multidimensional ListsCreating Pairwise CombinationsWorking With while Loops in Nested StructuresAvoiding Common Nested Loop PitfallsHandling Variable Scoping IssuesAddressing Poor ReadabilityDealing With Performance BottlenecksOptimizing Nested Loops in PythonUsing break and continueReplacing Nested Loops With List ComprehensionConclusionFrequently Asked QuestionsRemove adsNested loops in Python allow you to place one loop inside another, enabling you to perform repeated actions over multiple sequences. Understanding nested loops helps you write more efficient code, manage complex data structures, and avoid common pitfalls such as poor readability and performance issues.By the end of this tutorial, you’ll understand that:Nested loops in Python involveplacing one loop inside another, enabling iteration over multiple sequences or repeated actions.Situations where nested loops are a good idea includehandling multidimensional data,generating patterns, andperforming repetitive taskswith multiple layers of iteration.You can break out of nested loops by using thebreakstatement, which exits the innermost loop when a condition is met.Disadvantages of nested loopsinclude potential performance bottlenecks, poor readability, and variable scoping issues.This tutorial provides practical examples and optimization techniques for using nested loops effectively in your Python programs.Get Your Code:Click here to download the free sample codethat you’ll use to learn about nested loops in Python.Take the Quiz:Test your knowledge with our interactive “Nested Loops in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizNested Loops in PythonNested loops allow you to perform repeated actions over multiple sequences, but is there more? Test your understanding of nested loops in Python!Getting Started With Nested Loops in PythonLoops are fundamental building blocks in programming, allowing you to iterate through actions efficiently. In Python, there are two primary types of loops: theforloop and thewhileloop. Both serve the same purpose —executing a block of code multiple times—but they differ in how they operate and in their use cases:Aforloopiterates over a sequence, such as alistor arange, and executes a block of code for each item. They’re useful when the number of iterations is known beforehand.Awhileloopruns as long as a specified condition remains true, making it useful when the number of iterations isn’t known in advance.You create a nested loop by placing one loop inside another. This structure is especially helpful when working with multidimensional data, generating patterns, or handling tasks that involve several layers of repetition.In a nested loop, the first loop is called theouter loop, and the loop inside is theinner loop. So, for every iteration of the outer loop, the inner loop runs completely before the outer loop moves to the next iteration.Here’s the basic syntax of a nested loop:Python Syntaxforouter_variableinouter_iterable:forinner_variableininner_iterable:<body>Theouter_iterablemust be alist, adictionary, or some othersequenceof items that you can iterate over. The same applies to theinner_iterable. The<body>inside the inner loop contains the code that runs once for eachforloop step in theinner_iterable. Since the inner loop is nested inside the outer loop, it runs in full for each iteration of the outer loop.A good analogy for a nested loop is the hour and minute hands of a clock. The hour hand moves slowly around the clock, completing one full revolution every twelve hours. Meanwhile, the minute hand moves at a much faster rate, completing a revolution every hour. While both hands rotate at different speeds, they work together, each completing their own cycle within the same clock.Here’s how the clock logic looks in Python code:Python>>>forhourinrange(0,24):...forminuteinrange(0,60):...print(f""{hour:02d}:{minute:02d}"")...00:0000:0100:02⋮23:5723:5823:59As you can see, every time the minute hand completes a cycle, the hour hand moves to the next hour.:02dis aformat specifierthat ensures the number is printed as a two-digit-wide integer value.Now that you’ve been introduced to nested loops, it’s time to explore some practical examples. You’ll become familiar with writing programs using nested loops in the following section.Remove adsExploring Practical Examples of Nested LoopsAs you just learned, nested loops have a number of use cases. Here, you’ll have a look at a few examples. These examples are interesting and practical, allowing you to have fun as you explore their syntax and semantics.Printing Patterns With Nested LoopsBeing able to print any pattern of your choosing is a fascinating feat in programming. One way you can achieve this is by understanding how nested loops work. The code snippet below builds a sail pattern using a few simple symbols. While this may not seem particularly exciting, consider it a first step toward creating something spectacular—like a spaceship:Python1>>>height=62>>>sail_patterns=""*#-x+o""3>>>forrowinrange(height):4...pattern=""""5...spacing="" ""*(height-row)6...forsymbolinsail_patterns:7...pattern+=symbol*row+spacing8...9...print(pattern)10...1112*     #     -     x     +     o13**    ##    --    xx    ++    oo14***   ###   ---   xxx   +++   ooo15****  ####  ----  xxxx  ++++  oooo16***** ##### ----- xxxxx +++++ oooooHere’s what the code does line by line:Line 1:Sets theheightvariable, which is an indication of the size of the ship. It controls the number of rows in the pattern.Line 3:Begins the outerforloop, iterating from0up to, but not including,height.Line 5:Shifts the pattern to the right, decreasing spaces with increasing rows.Line 6:Starts the innerforloop over thesail_patterns. It’s followed by the body of the loop, which updates the pattern.Line 9:Prints the completed pattern.This way, the spaceship is essentially built piece by piece. Adding one piece at a time, you could increase its size or expand its structure.Generating a Multiplication TableMultiplication tables display the results of numbers multiplied by one another. These tables are commonly used in grade school for quick reviews of multiplication operations. Nestedforloops are a great way to generate multiplication tables in Python:Python>>>formultiplicantinrange(1,11):...formultiplierinrange(1,4):...expression=f""{multiplicant:>2d}×{multiplier}""...product=multiplicant*multiplier...print(f""{expression}={product:>2d}"",end=""\t"")...print()1 × 1 =  1      1 × 2 =  2      1 × 3 =  32 × 1 =  2      2 × 2 =  4      2 × 3 =  63 × 1 =  3      3 × 2 =  6      3 × 3 =  9⋮                ⋮               ⋮8 × 1 =  8      8 × 2 = 16      8 × 3 = 249 × 1 =  9      9 × 2 = 18      9 × 3 = 2710 × 1 = 10     10 × 2 = 20     10 × 3 = 30The example above displays the multiplication of numbers. The outer loop iterates through numbers 1 to 10, while the inner loop iterates through numbers 1 to 3.For every iteration of the outer loop, the current value is multiplied by each number in the inner loop. After finishing one row,print()moves to the next line. This creates a structured multiplication table. You could give this a go yourself by using different ranges and printing the result.Note:To learn more about theendkeyword argument, check out theYour Guide to the Python print() Functiontutorial.In the next section, you’ll explore how to use nested loops to sum all the elements in a nested list.Summing Elements in Multidimensional ListsAnother application of nested loops is processing elements in more than one dimension. A multidimensional or nested list is a list that contains other lists as its elements. To sum all elements in a nested list, you can use nested loops.Staying true to the theme of space travel, you can picture nested list summation this way:Python>>>resource_donators=[...[8,6,3],...[9,2,7],...[4,1,5]...]>>>total_resources=0>>>forplanetinresource_donators:...forresourceinplanet:...total_resources+=resource...>>>print(f""All resources gathered for interstellar travels:{total_resources}"")All resources gathered for interstellar travels: 45Here, you use a nestedforloop to handle resource collection from altruistic planets in a star system. Each sublist inresource_donatorsrepresents a planet, and each number in the sublist represents a unit of a resource—say, something known throughout the galaxy asfoodonium. Thetotal_resourcesis initialized to0.The outer loop iterates through each planet, and the inner loop goes through each individual resource, adding it tototal_resources. Suppose that one planet provides8,6, and3units of foodonium. After processing all planets, the final total is printed, and the spaceship can continue on its way.Note:You should know that while this approach is effective, there are more optimized ways to achieve the same result, such as using thesum()function. To learn more about it, you can check out thePython’s sum(): The Pythonic Way to Sum Valuestutorial.Next, you’ll take a look at how you can use nested loops to create pairwise combinations.Remove adsCreating Pairwise CombinationsWhen building programs, you may have to work with datasets that require you to make comparisons or work with data in pairs. In the example below, you’ll find a program that generates all possible matchups between players in a friendly game of space ball:Python>>>players=[""Bonnie"",""Mike"",""Raj"",""Adah""]>>>forplayer1inplayers:...forplayer2inplayers:...print(f""{player1}vs{player2}"")...Bonnie vs BonnieBonnie vs MikeBonnie vs Raj⋮Adah vs BonnieAdah vs MikeAdah vs RajAdah vs AdahWith this approach, you can generate all possible matchups—including self-matchups—demonstrating that pairwise combinations are possible with nested loops. You may have noticed that players are allowed to play against themselves, which you might not want. Click the collapsible section below to learn how to get rid of self matchups in space ball.Getting Rid of Self-Matchups in Space BallShow/HideYou’ll have noticed that space ball allows players to be matched against themselves. Perhaps that’s just the nature of the game, or maybe you’d prefer to prevent that from happening. How could you remove self-matchups from the program above? One solution is to add anifconditionto filter them out, as shown in the code below:Python>>>players=[""Bonnie"",""Mike"",""Raj"",""Adah""]>>>forplayer1inplayers:...forplayer2inplayers:...ifplayer1!=player2:...print(f""{player1}vs{player2}"")...Bonnie vs MikeBonnie vs RajBonnie vs AdahMike vs BonnieMike vs RajMike vs AdahRaj vs BonnieRaj vs MikeRaj vs AdahAdah vs BonnieAdah vs MikeAdah vs RajThis code example shows one way to generate pairwise combinations while filtering out self-matchups. This pattern comes in handy whenever you’re comparing elements in a group.As you’ve seen, nested loops make it easy to create pairwise combinations, whether you’re including or filtering out matches. This isn’t only useful in games, but also in real-world scenarios like comparing data entries. With that under your belt, you’ll now take a look at an example that useswhileloops in nested situations.Working WithwhileLoops in Nested StructuresSo far, you’ve seen several examples usingforloops in nested loops. There are also a number of situations where you’ll prefer to usewhileloops instead. For example, say that you’re building an app that prints each letter of a word:Python>>>whileTrue:...word=input(""Enter a word (or type 'exit' to stop): "")......ifword==""exit"":...break......forletterinword:...print(letter)...Enter a word (or type 'exit' to stop): foodoniumfoodoniumEnter a word (or type 'exit' to stop): exit>>>The example above shows a program that allows a user to type a word at the prompt, with each letter of the word eventually printed to the screen. Abreakkeyword is added to halt the execution of the program whenexitis typed.Note:To learn more about how to usebreak, check out theHow to Exit Loops Early With the Python Break Keywordtutorial.Whether you’re usingforloops orwhileloops in nested loops, you need to be cautious when using them. Poor usage can lead to a number of problems, such as reduced readability and performance issues, as you’ll soon see.Avoiding Common Nested Loop PitfallsWhen used improperly, nested loops can cause more problems than solutions. It’s therefore crucial to be aware of potential pitfalls you may encounter when using them to build programs, including:Variable scoping issuesPoor readabilityPerformance bottlenecksIn the next sections, you’ll have a closer look at each of these pitfalls and investigate ways to prevent them.Handling Variable Scoping IssuesIn Python,variablesdefined within a loop are accessible in theenclosing scope. This means that outer loop variables can be used inside the inner loop. However, unintended side effects may occur when an outer loop variable is modified in the inner loop, or when they both use the same variable.If you forget to keep track of such cases, you may be forced to deal with bugs later on, which could be a real hassle. Consider the following code:Python>>>employees=[(""Dorothy"",""DevOps""),(""Abdel"",""HR""),(""Nataliya"",""DevOps"")]>>>departments=[...{""name"":""DevOps"",""city"":""Berlin""},...{""name"":""HR"",""city"":""Abuja""},...]>>>forname,departmentinemployees:...fordepartmentindepartments:...ifdepartment[""name""]==department:...print(f""{name}works in{department['city']}"")...What you’ll observe here first is thatdepartmentrefers to the department name associated with an employee, as defined by the outerforloop. However, the innerforloop also refers to adepartment, which is a value in a list of dictionaries. The original definition ofdepartmentby the outer loop is overwritten by the inner loop, causing logical errors.One way to solve this is to declare different variable names for inner and outer loops:Python>>>forname,departmentinemployees:...fordeptindepartments:...ifdept[""name""]==department:...print(f""{name}works in{dept['city']}"")...Dorothy works in BerlinAbdel works in AbujaNataliya works in BerlinNow you can be certain thatdepartmentanddeptare handled separately. In order to avoid problems such as this, you should always avoid reusing the same variable name in both outer and inner loops, and be cautious when modifying an outer loop variable inside an inner loop.Remove adsAddressing Poor ReadabilityA major challenge when working with nested loops is poor readability. As the complexity of a program increases, deeply nested loops can make code difficult to read and maintain. While nested loops are sometimes necessary, excessive nesting can make it harder for other developers—or even for you—to understand what’s going on in your code.Consider the following example, which is a search protocol for when an intruder ventures into your ship:Python>>>living_quarters=3>>>sections=2>>>floors=3>>>forfloorinrange(floors):...forsectioninrange(sections):...forliving_quarterinrange(living_quarters):...print(...f""Scanning quarter{living_quarter}in section{section}""...f"" on floor{floor}for the intruder...""...)...Scanning quarter 0 in section 0 on floor 0 for the intruder...Scanning quarter 1 in section 0 on floor 0 for the intruder...Scanning quarter 2 in section 0 on floor 0 for the intruder......Scanning quarter 0 in section 1 on floor 2 for the intruder...Scanning quarter 1 in section 1 on floor 2 for the intruder...Scanning quarter 2 in section 1 on floor 2 for the intruder...At first glance, this code may seem manageable, even though there are several areas to search through. However, you might be taken aback by the number of lines of output in the terminal when you run the program.Now imagine being on an enterprise-level ship, with even more levels of nesting introduced. A piece of code with four or five nested loops can quickly become unreadable and difficult to maintain, makingdebugginga waking nightmare.One reason why nested loops in Python are notorious for poor readability is that Python is an indented language, in contrast to a language likeJavaScriptthat relies on curly brackets to distinguish code blocks. Another challenge is that it can become difficult to keep track of which loop is controlling which part of the logic. These factors combined make readability a crucial consideration when working with nested loops.Another important consideration when it comes to nested loops is how they affect performance. You’ll explore this next.Dealing With Performance BottlenecksTo understand how poorly written nested loops can affect performance, it helps to briefly explore the concept oftime complexity. Time complexity is a way to measure how fast an algorithm runs relative to the rate at which the input size grows, denoted byO(n).TheOrepresentsBigOnotation, wherenis the size of the input. It’s a widely used measure of performance, grouped into complexities, arranged in order from most to least efficient:ComplexityBig ODescriptionConstant TimeO(1)Runtime doesn’t change with input sizeLogarithmic TimeO(log n)Runtime grows slowly as input size increasesLinear TimeO(n)Runtime grows directly with input sizeQuadratic TimeO(n2)Runtime grows with the square of the input sizeExponential TimeO(2n)Runtime doubles with each additional inputFactorial TimeO(n!)Runtime grows extremely fast (factorial growth)A singleforloop runs inO(n) time. While this may not seem too bad for performance, imagine having six layers of nested loops. In that case, the time complexity isO(c × r × a × w × l), where each letter represents a loop. That’ll lead to performance bottlenecks. So you can see why nested loops quickly become inefficient, especially for large programs where each loop increases the time complexity.The example below shows an algorithm for detecting runaway clones aboard your ship—an unfortunate side effect of a well-meaning science experiment:Python>>>crew_ids=[1,2,8,4,5,6,7,8,9,10]>>>fori,first_idinenumerate(crew_ids):...forsecond_idincrew_ids[i+1:]:...iffirst_id==second_id:...print(f""Clone found: id={first_id}is a duplicate."")...Clone found: id=8 is a duplicate.As you can see, there are only twoforloops, so the time complexity may beO(c × r) denoted asO(n2).For a small example like this, you may get away with it, but for a large enough input, it would negatively affect performance. Paying attention to performance would help you write more efficient algorithms.This code has a fun narrative of identifying duplicate clones on a ship. However, in reality, it’s identifying duplicate numbers in a list. It goes through eachfirst_idone by one while keeping track of its location usingenumerate(). If any of the numbers in the list match, then you identify the number as a duplicate. More interestingly, you capture a clone.A solution to such a problem may be to forego nested loops in preference for more optimized techniques. In the example above, you could use aPython setorcollections.Counterinstead of nested loops. In both cases, the time complexity amounts toO(n), which has a better performance thanO(n2).In the code below, you can see how this works with a set:Python>>>crew_ids=[1,2,8,4,5,6,7,8,9,10]>>>detected=set()>>>forcrew_idincrew_ids:...ifcrew_idindetected:...print(f""Clone found: id={crew_id}is a duplicate."")...else:...detected.add(crew_id)...Clone found: id=8 is a duplicate.This next example shows how you can detect duplicates using aCounter:Python>>>fromcollectionsimportCounter>>>crew_ids=[1,2,8,4,5,6,7,8,9,10]>>>detected=Counter(crew_ids)>>>forkey,valueindetected.items():...ifvalue>1:...print(f""Clone found: id={key}is a duplicate."")...Clone found: id=8 is a duplicate.Here,Counterdetects the duplicates for you. Keep in mind that you don’t have to let go of nested loops entirely in some situations. Nested loops can be optimized, and you’ll learn exactly how next.Remove adsOptimizing Nested Loops in PythonAs you’ve seen, nested loops offer powerful capabilities, but like many useful tools, they also have their downsides. You explored some of those limitations in the previous section. In this section, you’ll learn how to optimize nested loops so you can use them more efficiently in your programs.UsingbreakandcontinueUsing nested loops may sometimes result in unnecessary iterations. You can control these iterations better by using thebreakandcontinuestatements.If a nestedforloop were aBLT sandwich, usingbreakwould be like eating the top layers and discarding the rest. Usingcontinue, on the other hand, would be like eating the top layers, skipping the lettuce, then finishing the bottom layers. Thecontinuestatement skips unnecessary iterations, reducing workload and improving performance.In other words, thebreakstatement lets you exit a loop before it finishes, and thecontinuestatement lets you skip iterations that aren’t needed. If you were an astronaut floating in zero gravity who hated lettuce, a program for how you eat a massive BLT sandwich might look like this:Python>>>blt_sandwich=[...[""bread"",""lettuce"",""tomato"",""bacon""],...[""bread"",""bacon"",""lettuce"",""tomato""],...[""bacon"",""bacon"",""tomato"",""lettuce""]...]>>>target=""bacon"">>>found=False>>>forlayerinblt_sandwich:...foringredientinlayer:...ifingredient==target:...print(f""Found the crispy{target}!"")...found=True...break......iffound:...print(""Enjoying the crunch and worth it."")...break...Found the crispy bacon!Enjoying the crunch and worth it.If you were to keep running the program even after finding your target bacon, the program would use up more resources. Thebreakstatement fixes this by terminating the loop early.Nestedforloops can be optimized withcontinuelike in this example:Python>>>blt_sandwich=[...[""bread"",""lettuce"",""tomato"",""bacon""],...[""bread"",""bacon"",""lettuce"",""tomato""],...[""bacon"",""bacon"",""tomato"",""lettuce""]...]>>>target=""bacon"">>>found=False>>>forlayerinblt_sandwich:...foringredientinlayer:...ifingredient!=target:...print(f""This is not bacon. Skipping..."")...continue...print(f""Found the crispy{target}!"")...found=True...break......iffound:...print(""Enjoying the crunch and worth it."")...break...This is not bacon. Skipping...This is not bacon. Skipping...This is not bacon. Skipping...Found the crispy bacon!Enjoying the crunch and worth it.The program skips non-bacon layers in the BLT, reducing unnecessary processing. By handling it this way, the code becomes more efficient and avoids extra workload. Bothbreakandcontinuestatements help improve the efficiency of nested loops, especially in tasks that involve searching or filtering.Replacing Nested Loops With List ComprehensionWithlist comprehensions, you can replace the intimidating hill of nested loops with a more compact and readable expression. While list comprehensions don’t necessarily improve performance or reduce time complexity—especially in nested iterations—they often make your intent clearer and your code easier to understand.The following example illustrates this with a crewmate determined to make towering stacks of pancakes:Python>>>bases=[""plain"",""chocolate"",""blueberry""]>>>toppings=[""honey"",""whipped cream"",""alien syrup""]>>>pancake_stacks=[]>>>forbaseinbases:...fortoppingintoppings:...pancake_stacks.append(f""{base.capitalize()}pancake with{topping}"")......print(pancake_stacks)...['Plain pancake with honey','Plain pancake with whipped cream','Plain pancake with alien syrup','Chocolate pancake with honey','Chocolate pancake with whipped cream','Chocolate pancake with alien syrup','Blueberry pancake with honey','Blueberry pancake with whipped cream','Blueberry pancake with alien syrup']This is an example of a traditional nestedforloop. You’ll notice that the outer and inner loops use different variable names. This is an important detail that helps you avoid the variable scoping issues you learned about earlier.Below, you’ll find the same program, but this time using list comprehension for the nested loops:Python>>>bases=[""plain"",""chocolate"",""blueberry""]>>>toppings=[""honey"",""whipped cream"",""alien syrup""]>>>pancake_stacks=[...f""{base.capitalize()}pancake with{topping}""...forbaseinbases...fortoppingintoppings...]>>>print(pancake_stacks)['Plain pancake with honey','Plain pancake with whipped cream','Plain pancake with alien syrup','Chocolate pancake with honey','Chocolate pancake with whipped cream','Chocolate pancake with alien syrup','Blueberry pancake with honey','Blueberry pancake with whipped cream','Blueberry pancake with alien syrup']Note that whilelist comprehensionsmay look clean and concise, they aren’t always the better choice. Readability can suffer when the logic becomes too complex, especially with nested structures. This goes against theZen of Python, which emphasizes that readability is important.So, the question boils down to whether list comprehension is actually more efficient than nested loops. A good answer to that is this—it depends. For straightforward transformations or filtering, list comprehensions are often ideal. But when your logic involves deep nesting, a traditional loop may be better. Ultimately, the key is to strike a balance between readability and efficiency.The optimization techniques you’ve explored may appear to be minor modifications that make nested loops better, but in larger applications, they can significantly impact performance. That’s why it’s important to recognize when nested loops are unnecessary—and, when you do use them, to manage them thoughtfully and efficiently.Remove adsConclusionNested loops are a powerful tool in Python. With them, you can handle complex iterations and work through difficult algorithms. They’re well-suited for tasks like handling multidimensional data, searching, and returning structured outputs such as custom patterns. However, when used poorly, they can lead to problems with performance, maintainability, and readability.In this tutorial, you’ve learned how to:Write Python programs to handlemultidimensional datausing nested loopsUse nestedforandwhileloopseffectivelyOptimize nested loops by usingbreak,continue, andlist comprehensionin looping structuresSolve practical problems such asprinting patternsandprocessing dataUnderstanding nested loops helps you write more efficient code, manage complex data structures, and avoid common pitfalls such as poor readability and performance issues.Get Your Code:Click here to download the free sample codethat you’ll use to learn about nested loops in Python.Frequently Asked QuestionsNow that you have some experience with nested loops in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What are nested loops in Python?Show/HideYou use nested loops in Python to run a loop inside another loop, allowing you to iterate over multiple sequences or perform repeated actions within each iteration of the outer loop.In which situations are nested loops a good idea?Show/HideYou’ll find nested loops useful for handling multidimensional data, generating patterns, or performing repetitive tasks that require multiple layers of iteration.How can you break out of nested loops?Show/HideYou can break out of nested loops using thebreakstatement to exit the current loop.What are the disadvantages of nested loops?Show/HideNested loops can lead to poor readability, variable scoping issues, and performance bottlenecks, especially when they’re deeply nested or when you’re handling large datasets.Take the Quiz:Test your knowledge with our interactive “Nested Loops in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizNested Loops in PythonNested loops allow you to perform repeated actions over multiple sequences, but is there more? Test your understanding of nested loops in Python!Mark as CompletedShare"
First Steps With LangChain,https://realpython.com/courses/first-steps-langchain/,"May 20, 2025",47m,"intermediate, databases, data-science","You’ve likely interacted with large language models (LLMs), like the ones behind OpenAI’s ChatGPT, and experienced their remarkable ability to answer questions, summarize documents, write code, and much more.While LLMs are remarkable by themselves, with a little programming knowledge, you can leverage libraries likeLangChainto create your own LLM-powered applications that can do just about anything.In this video course, you’ll learn how to:UseLangChainto build LLM-powered applicationsCreate reusable instructions withprompt templatesCreate and extendLangChain chainsDebugwhat happens when a chain executesWhat’s Included:12 LessonsVideo Subtitles and Full Transcripts2 Downloadable ResourcesAccompanying Text-Based TutorialInteractive Quiz to Check Your ProgressQ&A With Python Experts: Ask a QuestionCertificate of CompletionDownloadable Resources:Course Slides (.pdf)Sample Code (.zip)"
How to Group Data Using Polars .group_by(),https://realpython.com/polars-groupby/,"May 19, 2025",N/A,"intermediate, data-science, python","Table of ContentsAggregating DataLearning the BasicsInvestigating Other Aggregation TechniquesTrying Out Your Data Aggregation SkillsGrouping Aggregated Data With Polars .group_by()Learning the BasicsUnderstanding the Power of ExpressionsGrouping and Aggregating by Multiple ColumnsPerforming a Data Sub-GroupingTweaking Your SortingTrying Out Your Data Grouping and Aggregation SkillsGrouping and Aggregating Time Series With .group_by_dynamic()Performing a Time-Series GroupingTrying Out Your Time Series Analysis SkillsGrouping and Aggregating Using Window FunctionsWorking With Window FunctionsTrying Out Your Window Function SkillsGrouping and Aggregating Using Pivot TablesCreating a Pivot TableCustomizing Column OrderDigging Deeper With Your AnalysisTrying Out Your Pivot Table SkillsConclusionFrequently Asked QuestionsRemove adsOne of the most common tasks you’ll encounter when analyzing Polars data is the need to summarize it. You can use the Polars.group_by()method to create groupings based on column values. A related summarization technique is aggregation, where you take a sequence of related values and condense them into a single value.By the end of this tutorial, you’ll understand that:You can summarize data usingaggregation.You can use.filter()to viewspecific data.Using.group_by()allows you to summarizeone or morecolumns of your data.Yourtime seriesdata can be grouped using.group_by_dynamic().You can match summarized data with the original data usingwindow functions.Pivot tablesallow you to group and aggregate rows and columns of data.In this tutorial, you’ll learn how to group data in several ways using the.group_by()method in Polars and apply aggregation to each group.Before you begin, you should be familiar with the basics of working with Polars DataFrames or another DataFrame library likepandas.Note:If you’re familiar with Polars, you’ll know that in addition to DataFrames, Polars also supportsLazyFrames. While this is an efficient tool when working with large datasets, and you’re certainly encouraged to learn how to use them, DataFrames are sufficient for the examples in this tutorial.In addition, you may find it helpful to useJupyter Notebookas you work through many of the examples in this tutorial. Alternatively,JupyterLabwill enhance your notebook experience, but any Python environment you’re comfortable with will work just fine.To get started, you’ll need some data. For the central part of this tutorial, you’ll use the student performance dataset freely available from theUC Irvine Machine Learning Repository. The data in its original form comes in two files:student-mat.csvandstudent-por.csv. These contain data on students taking math and Portuguese language courses.Both files have been altered to include student identification numbers and the subject indicatorsMandP, formatted asmath.parquetandportuguese.parquet. All data has also been merged into a singlecourse.parquetfile. These three files are available in your download bundle, which you can access by clicking the link below:Get Your Code:Click here to download the free sample codethat you’ll use to learn about grouping data with Polars .group_by().The table below shows the fields used in this tutorial:Field NameDescriptionabsencesNumber of absencesageStudent’s agefailuresNumber of failuresG1,G2,G3First, second, and final gradeinternetStudent has home internet accessreasonReason for taking courseschoolSchool attendedsexStudent’s gender (M,F)student_idStudent’s enrollment numbersubjectSubject studied (M,P)The dataset is quite extensive, containing over thirty fields. If you want to experiment, thestudent.txtfile defines every field. This file is also available as part of the tutorial downloads.To use Polars, you first need to install the Polars library into your Python environment. To install Polars from the command prompt, use the following command:Shell$python-mpipinstallpolarsIn a Jupyter Notebook, the command is!python -m pip install polars.With everything set up, it’s time to start using Polars to aggregate and group data.Get Your Code:Click here to download the free sample codethat you’ll use to learn about grouping data with Polars .group_by().Take the Quiz:Test your knowledge with our interactive “How to Group Data Using Polars .group_by()” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizHow to Group Data Using Polars .group_by()Put your Polars .group_by() and aggregation skills to the test. This quiz goes beyond the tutorial, so you'll need to dig deeper to find all the answers.Aggregating DataWhenever you want to aggregate data without grouping it, you apply an aggregation function directly to the column or columns you want to analyze. More often than not, you’ll also want to group your aggregated data. You’ll learn how to do that later—for now, you’ll focus on aggregation.Remove adsLearning the BasicsSuppose you wanted to find the highest number of absences among students in the math class. You can do this as follows:Python>>>importpolarsaspl>>>math_students=pl.read_parquet(""math.parquet"")>>>(...math_students....select(pl.col(""absences"").max())...)shape: (1, 1)┌──────────┐│ absences ││ ---      ││ i64      │╞══════════╡│ 75       │└──────────┘After installing the Polars library earlier, youimportit into your code with the conventional aliasplto access its functionality. This allows you to use theread_parquet()function to read the contents ofmath.parquetinto a Polars DataFrame.With the data now inside a DataFrame, you use its.select()method to select the specific columns you want to work with. In this example, you need data from theabsencescolumn, so you specify it using thepl.col(""absences"")expression. You then use.max()to locate the maximumabsencesvalue in the column. As you can see, the highest number of absences is75.Note:The.select()method is also known as acontext. A context is the name Polars uses for a method you pass a Polars expression to. The same expression will produce different results depending on the context you pass it to.For example, passingpl.col(""student_id"")to the.select()context will include thestudent_idcolumn in the result, whereas using it in the.filter()context will help define which values ofstudent_idyou’ll see in the result.The contexts you’ll use in this tutorial are.select(),.filter(),.group_by(), and.with_columns().Don’t confuse Polars contexts with the more widespread Pythoncontext manager. They’re not the same thing.Although the previous example illustrates that aggregating data produces a single value, it doesn’t provide any background about where that value came from. Suppose, for example, you wanted to know which student, or students, have the worst attendance. You need to know more about where this75came from. To do this, you filter the DataFrame:Python>>>(...math_students....select(pl.col(""student_id"",""absences""))....filter(pl.col(""absences"")==pl.col(""absences"").max())...)shape: (1, 2)┌────────────┬──────────┐│ student_id ┆ absences ││ ---        ┆ ---      ││ i64        ┆ i64      │╞════════════╪══════════╡│ 10277      ┆ 75       │└────────────┴──────────┘This time, you use.select()to select both thestudent_idandabsencescolumns. Although you’re most interested in thestudent_idvalue or values, displaying the associatedabsencescolumn will also give their absence information.To filter the DataFrame so that only information relating to the highest number of absences is displayed, you use.filter(). As a filter condition, you pass inpl.col(""absences"") == pl.col(""absences"").max(). This returns only the student identifier and absences value for those students whose number of absences is equal to the maximum among all math students. In this case, only the student with ID10277meets the filter criteria.Note:Although the code you’ve written to select the maximum value in theabsencescolumn is correct, it’s not the only way you’ll see computations like this written.For example,pl.max(""absences"")will do the same thing. This code issyntactic sugarforpl.col(""absences"").max()to make it look as though you’re using a Polars function, when you’re actually calling a method on an expression object.It’s also possible to use an attribute syntax. For example,pl.col.absencescreates an expression equal topl.col(""absences"").In this tutorial, you’ll use thepl.col(""absences"").max()syntax form, which is more technically correct.Next, you’ll gain an appreciation for some of the different aggregation calculations that Polars supports.Investigating Other Aggregation TechniquesIn the examples so far, you’ve limited your data aggregations to working out maximum values using the.max()method of a Polars expression. But Polars supports a range ofmethodsthat can be used on expressions. It’s also possible to mix and match them within the same.select():Python>>>(...math_students....select(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...)...)shape: (1, 3)┌─────┬─────┬──────────┐│ min ┆ max ┆ mean     ││ --- ┆ --- ┆ ---      ││ i64 ┆ i64 ┆ f64      │╞═════╪═════╪══════════╡│ 0   ┆ 75  ┆ 5.708861 │└─────┴─────┴──────────┘Here, you’ve displayed the lowest, highest, and average absences of math students using the expression methods shown.This time, you passed each expression to.select()bykeyword. The keyword names the column containing the result. For example, you usemean=pl.col(""absences"").mean()to determine the average ofabsencesand assign it to themeancolumn in the output. You can use any word you like as the keyword. It doesn’t have to match the method name, but it’s best to choose a name that’s descriptive of the column’s data.Keywords are necessary in this example because each column name must be unique. The output columns would be named after the data they contain if you didn’t use keyword arguments. So the result ofpl.col(""absences"").mean()would be placed into a column namedabsences. Withoutmin,max, andmean, Polars would raise aDuplicateErrorbecauseabsenceswould be used for more than one column name.Note:It’s also possible to aggregate rows of data. Suppose, you wanted to find the final total and mean of each student’s exam results:Python>>>math_students.select(...""student_id"",""G1"",""G2"",""G3"",...total=pl.sum_horizontal(""G1"",""G2"",""G3""),...mean=pl.mean_horizontal(""G1"",""G2"",""G3""),...)shape: (395, 6)┌────────────┬─────┬─────┬─────┬───────┬───────────┐│ student_id ┆ G1  ┆ G2  ┆ G3  ┆ total ┆ mean      ││ ---        ┆ --- ┆ --- ┆ --- ┆ ---   ┆ ---       ││ i64        ┆ i64 ┆ i64 ┆ i64 ┆ i64   ┆ f64       │╞════════════╪═════╪═════╪═════╪═══════╪═══════════╡│ 10001      ┆ 5   ┆ 6   ┆ 6   ┆ 17    ┆ 5.666667  ││ 10002      ┆ 5   ┆ 5   ┆ 6   ┆ 16    ┆ 5.333333  ││ 10003      ┆ 7   ┆ 8   ┆ 10  ┆ 25    ┆ 8.333333  ││ 10004      ┆ 15  ┆ 14  ┆ 15  ┆ 44    ┆ 14.666667 ││ 10005      ┆ 6   ┆ 10  ┆ 10  ┆ 26    ┆ 8.666667  ││ …          ┆ …   ┆ …   ┆ …   ┆ …     ┆ …         ││ 10391      ┆ 9   ┆ 9   ┆ 9   ┆ 27    ┆ 9.0       ││ 10392      ┆ 14  ┆ 16  ┆ 16  ┆ 46    ┆ 15.333333 ││ 10393      ┆ 10  ┆ 8   ┆ 7   ┆ 25    ┆ 8.333333  ││ 10394      ┆ 11  ┆ 12  ┆ 10  ┆ 33    ┆ 11.0      ││ 10395      ┆ 8   ┆ 9   ┆ 9   ┆ 26    ┆ 8.666667  │└────────────┴─────┴─────┴─────┴───────┴───────────┘To compute the sum and mean of student grades, you use thesum_horizontal()andmean_horizontal()expressions and pass them to.select().To avoid column name clashes, you must pass both expressions as keyword arguments to clearly define the output column headers. For clarity, you also display the columns containing the original grade column data used in each calculation. Thetotalandmeancolumns show the sum and average of the data in columnsG1,G2, andG3.Just before you move on, it’s time to consolidate your learning.Remove adsTrying Out Your Data Aggregation SkillsExercise: ""Comprehension Check""Show/HideTheG3column inmath.parquetcontains the students’ final grades.What’s the median, most frequent value, and variance of theG3results?Solution: ""Comprehension Check""Show/HideOne possible solution could be:Program Output┌───────────────┬──────────────────────┬───────────┐
│ median_result ┆ most_frequent_result ┆ variance  │
│ ---           ┆ ---                  ┆ ---       │
│ f64           ┆ i64                  ┆ f64       │
╞═══════════════╪══════════════════════╪═══════════╡
│ 11.0          ┆ 10                   ┆ 20.989616 │
└───────────────┴──────────────────────┴───────────┘You’ll find the code that produced this result in thesolutions.ipynbfile in your downloads.Now that you’ve been introduced to aggregating data, you’ll focus on grouping it.Grouping Aggregated Data With Polars.group_by()When you need to group data, you often perform the grouping before aggregation. To group data, you split it into separate categories and then aggregate each one. In this section, you’ll start with a basic example, then you’ll move to a more complex example that highlights the real power of the Polars expression syntax.Learning the BasicsSuppose you want to find the minimum, maximum, and average number of absences for students in the math and Portuguese courses. One way would be to analyze both themath.parquetandportuguese.parquetfiles individually:Python>>>importpolarsaspl>>>math_students=pl.read_parquet(""math.parquet"")>>>portuguese_students=pl.read_parquet(""portuguese.parquet"")>>>(...math_students....select(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...)...)shape: (1, 3)┌─────┬─────┬──────────┐│ min ┆ max ┆ mean     ││ --- ┆ --- ┆ ---      ││ i64 ┆ i64 ┆ f64      │╞═════╪═════╪══════════╡│ 0   ┆ 75  ┆ 5.708861 │└─────┴─────┴──────────┘>>>(...portuguese_students....select(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...)...)shape: (1, 3)┌─────┬─────┬──────────┐│ min ┆ max ┆ mean     ││ --- ┆ --- ┆ ---      ││ i64 ┆ i64 ┆ f64      │╞═════╪═════╪══════════╡│ 0   ┆ 32  ┆ 3.659476 │└─────┴─────┴──────────┘This code is very similar to the earlier example, except this time, you’ve applied it to the contents of both yourmath.parquetandportuguese.parquetfiles. You’ll recognize the first set of results from before, but the additional analysis reveals higher absenteeism in mathematics than in Portuguese. However, some keen students in both classes have never missed a lesson.While running the same code multiple times certainly gives you the correct answer, it only works because each file contains data for a single subject. Suppose that instead, the data for both classes was presented to you in a single file. The above code would still work, but the results you’d see would be those from the combined data. To analyze this composite file for each of the subjects within the file, you can use.group_by():Python>>>all_students=pl.read_parquet(""course.parquet"")>>>(...all_students....group_by(""subject"")....agg(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...)...)shape: (2, 4)┌─────────┬─────┬─────┬──────────┐│ subject ┆ min ┆ max ┆ mean     ││ ---     ┆ --- ┆ --- ┆ ---      ││ str     ┆ i64 ┆ i64 ┆ f64      │╞═════════╪═════╪═════╪══════════╡│ M       ┆ 0   ┆ 75  ┆ 5.708861 ││ P       ┆ 0   ┆ 32  ┆ 3.659476 │└─────────┴─────┴─────┴──────────┘This time, you’ve computed both result sets using.group_by(). When you passsubjectinto.group_by(), you return aGroupByobject that groups the data according to the different values in thesubjectcolumn. There will be two groups: one for math students, denoted by the letterM, and another for Portuguese students, denoted byP.Note:Polars.group_by()doesn’t care about the order of the data it encounters. You can place theMandPdata rows in any order you please withincourse.parquet, and the output of the code will be the same. There’s no need to sort the data bysubjectbeforehand.Once you have yourGroupByobject, you can use its.agg()method to perform an aggregation. In this case, because you want the minimum, maximum, and average values for each of the two groups, you pass in the same expressions as before, again with keywords to avoid name conflicts.This time, your results show you’ve applied.min(),.max(), and.mean()to each of the two groups separately and not to the complete dataset.Understanding the Power of ExpressionsOne of the powerful features of passing expressions into.agg()is that they’re calculated based on the groups defined within theGroupByobject created with.group_by(). As long as you can formulate your aggregation into an expression, you can use it in.agg()and apply it to groupings. This makes writing complex grouped aggregations more logical.For example, suppose you wanted to analyze attendance a little deeper. You want to find out how many math students with a greater than mean absence for their age still managed to pass the subject. A student has passed if their overall grade—G3—is13or higher.To begin with, you need to group theG3data byage. You decide to write some intermediate code to see how this looks:Python>>>math_students=pl.read_parquet(""math.parquet"")>>>(...math_students....group_by(""age"")....agg(...passes=pl.col(""G3""),...)...)shape: (8, 2)┌─────┬───────────────┐│ age ┆ passes        ││ --- ┆ ---           ││ i64 ┆ list[i64]     │╞═════╪═══════════════╡│ 17  ┆ [6, 6, … 16]  ││ 21  ┆ [7]           ││ 20  ┆ [18, 15, 9]   ││ 15  ┆ [10, 15, … 7] ││ 16  ┆ [10, 15, … 8] ││ 22  ┆ [8]           ││ 19  ┆ [9, 0, … 9]   ││ 18  ┆ [6, 0, … 10]  │└─────┴───────────────┘To group the math students by their age, you passageinto.group_by(). To specify the data you want aggregated, you pass theG3column into.agg(), since it contains the students’ overall grades. The aggregated data for each value in theagecolumn is output as a list because you haven’t specified any aggregation computations to be carried out.Currently, thepassescolumn contains all the aggregated data. Since you’re only interested in the data of passing students with an above average absence for their age, you’ll need to add some filters:Python>>>(...math_students....group_by(""age"")....agg(...passes=pl.col(""G3"").filter(...pl.col(""absences"")>pl.col(""absences"").mean(),...pl.col(""G3"")>=13,...)...)...)shape: (8, 2)┌─────┬────────────────┐│ age ┆ passes         ││ --- ┆ ---            ││ i64 ┆ list[i64]      │╞═════╪════════════════╡│ 18  ┆ [14, 18, … 13] ││ 20  ┆ []             ││ 16  ┆ [15, 14, … 18] ││ 15  ┆ [15, 13, … 15] ││ 22  ┆ []             ││ 21  ┆ []             ││ 19  ┆ [13, 13, … 13] ││ 17  ┆ [13, 18, … 15] │└─────┴────────────────┘The filters you apply ensure that only students with above-average absences and aG3score of13or higher are included in thepassescolumn. As you can see, the lists now reflect this. However, the specific marks don’t interest you. Instead, you want to see a count of the successes. You can use the.count()method for this:Python>>>(...math_students....group_by(""age"")....agg(...passes=pl.col(""G3"").filter(...pl.col(""absences"")>pl.col(""absences"").mean(),...pl.col(""G3"")>=13...).count(),...poor_attenders=pl.col(""G3"").filter(...pl.col(""absences"")>pl.col(""absences"").mean()...).count(),...)....select(...pl.col(""age"",""passes"",""poor_attenders""),...percentage=pl.col(""passes"")/pl.col(""poor_attenders"")*100,...)....with_columns(...pl.col(""percentage"").replace(float(""NaN""),0)...).sort(""age"")...)shape: (8, 4)┌─────┬────────┬────────────────┬────────────┐│ age ┆ passes ┆ poor_attenders ┆ percentage ││ --- ┆ ---    ┆ ---            ┆ ---        ││ i64 ┆ u32    ┆ u32            ┆ f64        │╞═════╪════════╪════════════════╪════════════╡│ 15  ┆ 15     ┆ 32             ┆ 46.875     ││ 16  ┆ 11     ┆ 39             ┆ 28.205128  ││ 17  ┆ 8      ┆ 29             ┆ 27.586207  ││ 18  ┆ 11     ┆ 31             ┆ 35.483871  ││ 19  ┆ 4      ┆ 10             ┆ 40.0       ││ 20  ┆ 0      ┆ 1              ┆ 0.0        ││ 21  ┆ 0      ┆ 0              ┆ 0.0        ││ 22  ┆ 0      ┆ 0              ┆ 0.0        │└─────┴────────┴────────────────┴────────────┘Next, you add a column namedpoor_attendersto the aggregation. This column contains a count of all students whose attendance was below the average for their age.In addition to theage,passes, andpoor_attenderscolumns, you also define a column namedpercentagethat contains the percentage of passes for each student involved in the analysis. You use.select()to make sure all four of these columns are displayed.Whenpoor_attendersis zero, yourpercentagecolumn displaysNaN. To deal with thisunsightly data, you passpl.col(""percentage"").replace(float(""NaN""), 0)into.with_columns(). This causes the original column to be replaced with a new one, also namedpercentage, but without theNaNvalues.Finally, you use.sort()to sort the column by age. By default, the sort is in ascending order. If you wanted to reverse this, you’d adddescending=True.You also conclude that students with a high number of absences don’t perform well on their exams. While many may have valid reasons for missing class and might be working independently, the overall pass rates are low.Note:On rare occasions, you may want to display your output so that the order of the data groupings is the same as in the original data. To do this, you can passmaintain_order=Trueto.group_by().In the previous example, removing.sort()and using.group_by(""age"", maintain_order=True)would display the grouped data in its original age order as opposed to sorting it. By default,maintain_orderis set toFalsebecause setting it toTruecauses a performance hit. Fortunately, this isn’t something you’ll use very often, but it’s available if you need it.In addition, settingmaintain_order=Truealso blocks the possibility of usingstreaming, which may cause resource problems if your dataset is large.Now that you’ve practiced grouping by a single column, you’ll learn how to group multiple columns of data.Remove adsGrouping and Aggregating by Multiple ColumnsYou’ve grouped your data using a single column in the examples so far. While this is certainly a useful thing to do, Polars allows you to group data by multiple columns. This is often referred to assub-groupingand can allow you to make more sense of the results.Performing a Data Sub-GroupingSuppose you want to find the lowest, highest, and average absence figures for both subjects again, but this time you want to analyze the students’ reasons for choosing the course. To do this, you can pass both columns into.group_by()in a Python list:Python>>>importpolarsaspl>>>all_students=pl.read_parquet(""course.parquet"")>>>(...all_students....group_by([""subject"",""reason""])....agg(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...).sort(""subject"")...)shape: (8, 5)┌─────────┬────────────┬─────┬─────┬──────────┐│ subject ┆ reason     ┆ min ┆ max ┆ mean     ││ ---     ┆ ---        ┆ --- ┆ --- ┆ ---      ││ str     ┆ str        ┆ i64 ┆ i64 ┆ f64      │╞═════════╪════════════╪═════╪═════╪══════════╡│ M       ┆ course     ┆ 0   ┆ 23  ┆ 3.972414 ││ M       ┆ other      ┆ 0   ┆ 20  ┆ 5.611111 ││ M       ┆ home       ┆ 0   ┆ 75  ┆ 7.146789 ││ M       ┆ reputation ┆ 0   ┆ 56  ┆ 6.647619 ││ P       ┆ home       ┆ 0   ┆ 30  ┆ 4.456376 ││ P       ┆ other      ┆ 0   ┆ 16  ┆ 2.777778 ││ P       ┆ reputation ┆ 0   ┆ 32  ┆ 3.811189 ││ P       ┆ course     ┆ 0   ┆ 26  ┆ 3.389474 │└─────────┴────────────┴─────┴─────┴──────────┘This time, the data is first grouped bysubjectand then, within each subject, it’s sub-grouped byreason. Finally, the various calculations are performed for each subject-reason combination.Interestingly, the highest mean absences for both subjects correspond to those students who chose the course because it was delivered closest to their home.If you look closely at the output, you might notice that the values within thereasoncolumn are in a different order for each subject. To address this, you can do some sub-sorting:Python>>>(...all_students....group_by([""subject"",""reason""])....agg(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...).sort(""subject"",""reason"")...)shape: (8, 5)┌─────────┬────────────┬─────┬─────┬──────────┐│ subject ┆ reason     ┆ min ┆ max ┆ mean     ││ ---     ┆ ---        ┆ --- ┆ --- ┆ ---      ││ str     ┆ str        ┆ i64 ┆ i64 ┆ f64      │╞═════════╪════════════╪═════╪═════╪══════════╡│ M       ┆ course     ┆ 0   ┆ 23  ┆ 3.972414 ││ M       ┆ home       ┆ 0   ┆ 75  ┆ 7.146789 ││ M       ┆ other      ┆ 0   ┆ 20  ┆ 5.611111 ││ M       ┆ reputation ┆ 0   ┆ 56  ┆ 6.647619 ││ P       ┆ course     ┆ 0   ┆ 26  ┆ 3.389474 ││ P       ┆ home       ┆ 0   ┆ 30  ┆ 4.456376 ││ P       ┆ other      ┆ 0   ┆ 16  ┆ 2.777778 ││ P       ┆ reputation ┆ 0   ┆ 32  ┆ 3.811189 │└─────────┴────────────┴─────┴─────┴──────────┘This time, the data are sorted first bysubject, and then byreasonwithin each subject. To do this, you pass both thesubjectandreasoncolumns into.sort(). If you wanted to sort them the other way around, then you’d pass the columns in the reverse order.Tweaking Your SortingBy default, sorting is done in ascending order. In other words, alphabetically and in order from lowest to highest numerically. Suppose you wanted the various reasons to be sorted in descending order. You can do this by chaining two.sort()calls together:Python>>>(...all_students....group_by([""subject"",""reason""])....agg(...min=pl.col(""absences"").min(),...max=pl.col(""absences"").max(),...mean=pl.col(""absences"").mean(),...)....sort(""reason"",descending=True)....sort(""subject"")...)shape: (8, 5)┌─────────┬────────────┬─────┬─────┬──────────┐│ subject ┆ reason     ┆ min ┆ max ┆ mean     ││ ---     ┆ ---        ┆ --- ┆ --- ┆ ---      ││ str     ┆ str        ┆ i64 ┆ i64 ┆ f64      │╞═════════╪════════════╪═════╪═════╪══════════╡│ M       ┆ reputation ┆ 0   ┆ 56  ┆ 6.647619 ││ M       ┆ other      ┆ 0   ┆ 20  ┆ 5.611111 ││ M       ┆ home       ┆ 0   ┆ 75  ┆ 7.146789 ││ M       ┆ course     ┆ 0   ┆ 23  ┆ 3.972414 ││ P       ┆ reputation ┆ 0   ┆ 32  ┆ 3.811189 ││ P       ┆ other      ┆ 0   ┆ 16  ┆ 2.777778 ││ P       ┆ home       ┆ 0   ┆ 30  ┆ 4.456376 ││ P       ┆ course     ┆ 0   ┆ 26  ┆ 3.389474 │└─────────┴────────────┴─────┴─────┴──────────┘When adding in chained calls to.sort(), you need to take care with their order. To make sure you sort by reason within subject,.sort(""reason"")must be called before.sort( ""subject""). This is the reverse of when you passed both columns to a single.sort()earlier. To sort thereasoncolumn’s data in descending order, you must passdescending=Trueto it as well.As the updated output shows, thesubjectcolumn is in the same ascending order as before, but thereasoncolumn is now in descending order within each of the two subjects.Just before you move on, it’s time for another round of learning consolidation.Trying Out Your Data Grouping and Aggregation SkillsExercise: ""Comprehension Check""Show/HideTheinternetcolumn incourse.parquetindicates if the student has home internet access. You’ve been asked to investigate how many students taking each subject have access and if this affects their pass rates. Remember, if theirG3score is13or higher, a student has passed.Display details of the total students, number of passes, and percentage of passes for each subject for those who either have home internet access or don’t.As an extra challenge, see if you can format the percentages using the percent (%) sign.Solution: ""Comprehension Check""Show/HideOne possible solution could be:Program Output┌─────────┬──────────┬───────┬────────┬────────────┐
│ subject ┆ internet ┆ total ┆ passes ┆ percentage │
│ ---     ┆ ---      ┆ ---   ┆ ---    ┆ ---        │
│ str     ┆ str      ┆ u32   ┆ u32    ┆ str        │
╞═════════╪══════════╪═══════╪════════╪════════════╡
│ M       ┆ no       ┆ 66    ┆ 14     ┆ 21.21%     │
│ M       ┆ yes      ┆ 329   ┆ 117    ┆ 35.56%     │
│ P       ┆ no       ┆ 151   ┆ 45     ┆ 29.8%      │
│ P       ┆ yes      ┆ 498   ┆ 231    ┆ 46.39%     │
└─────────┴──────────┴───────┴────────┴────────────┘You’ll find the code that produced this result in thesolutions.ipynbfile in your downloads.Next, you’ll learn a little about grouping time series data.Remove adsGrouping and Aggregating Time Series With.group_by_dynamic()Time series analysis is a major part of everyday data analysis. Polars has its own grouping method,.group_by_dynamic(),which is dedicated to grouping data based on time values.In this section, you’ll use a file namedmath_classes.parquetthat contains details of absence rates for a six-month semester of algebra, geometry, and calculus classes. The file is included in the downloadable materials and contains the following fields:FieldDescriptionclass_startStart date and time of the classclass_subjectSubject name: algebra, geometry, or calculusabsencesNumber of student absenceslecturer_initialsInitials of the lecturer teaching the classBefore you begin, you decide to take a look at a part of the data:Python>>>importpolarsaspl>>>math_attendance=pl.read_parquet(""math_classes.parquet"")>>>math_attendance.head()shape: (5, 4)┌─────────────────────┬───────────────┬──────────┬───────────────────┐│ class_start         ┆ class_subject ┆ absences ┆ lecturer_initials ││ ---                 ┆ ---           ┆ ---      ┆ ---               ││ datetime[μs]        ┆ str           ┆ i64      ┆ str               │╞═════════════════════╪═══════════════╪══════════╪═══════════════════╡│ 2024-01-03 09:00:00 ┆ algebra       ┆ 3        ┆ DH                ││ 2024-01-04 13:30:00 ┆ geometry      ┆ 4        ┆ PS                ││ 2024-01-05 10:00:00 ┆ calculus      ┆ 3        ┆ LM                ││ 2024-01-10 09:00:00 ┆ algebra       ┆ 2        ┆ DH                ││ 2024-01-11 13:30:00 ┆ geometry      ┆ 7        ┆ PS                │└─────────────────────┴───────────────┴──────────┴───────────────────┘The file contains a row for each weekly class in the three mathematical subjects. Each class runs once a week. The semester starts in January and continues through to the end of June. You usedmath_attendance.head()to view only the first five rows.Performing a Time-Series GroupingSuppose you’re reviewing the absences from the course. You’d like to see the total and mean absences for each week. You do this using.group_by_dynamic():Python>>>(...math_attendance....group_by_dynamic(...index_column=""class_start"",...every=""1w"",...closed=""both"",...)....agg(...total_absences=pl.col(""absences"").sum(),...mean_absences=pl.col(""absences"").mean(),...)...)shape: (26, 3)┌─────────────────────┬────────────────┬───────────────┐│ class_start         ┆ total_absences ┆ mean_absences ││ ---                 ┆ ---            ┆ ---           ││ datetime[μs]        ┆ i64            ┆ f64           │╞═════════════════════╪════════════════╪═══════════════╡│ 2024-01-01 00:00:00 ┆ 10             ┆ 3.333333      ││ 2024-01-08 00:00:00 ┆ 10             ┆ 3.333333      ││ 2024-01-15 00:00:00 ┆ 11             ┆ 3.666667      ││ 2024-01-22 00:00:00 ┆ 10             ┆ 3.333333      ││ 2024-01-29 00:00:00 ┆ 4              ┆ 1.333333      ││ …                   ┆ …              ┆ …             ││ 2024-05-27 00:00:00 ┆ 15             ┆ 5.0           ││ 2024-06-03 00:00:00 ┆ 12             ┆ 4.0           ││ 2024-06-10 00:00:00 ┆ 17             ┆ 5.666667      ││ 2024-06-17 00:00:00 ┆ 6              ┆ 2.0           ││ 2024-06-24 00:00:00 ┆ 14             ┆ 4.666667      │└─────────────────────┴────────────────┴───────────────┘The.group_by__dynamic()method allows you to group data based on a time value. Here, you use it to calculate the total and mean weekly absences. Here’s a breakdown of the arguments you used:First, you setindex_column=""class_start""to tell.group_by_dynamic()to use this column for grouping.Next, you passevery=""1w""to group theclass_startvalues into weekly intervals. The""1w""string starts each week on Monday by default.The final parameter you pass isclosed=""both""to ensure that both the first and last weeks are included in the output.The expressions you pass to.agg()are similar to the ones you used earlier. Once again, you define the column headings for the results using keywords to avoid naming conflicts and make the results easy to read.Your output contains a row for each week’s data. Each row of thetotal_absencescolumn contains the total absences for each week, while themean_absencescolumn contains their average.Suppose you want to dig deeper and find the total absences for each quarter, but group the data by each subject. The code you use to do this is as follows:Python>>>(...math_attendance....group_by_dynamic(...index_column=""class_start"",...every=""1q"",...closed=""both"",...group_by=""class_subject"",...)....agg(pl.col(""absences"").sum())...)shape: (6, 3)┌───────────────┬─────────────────────┬──────────┐│ class_subject ┆ class_start         ┆ absences ││ ---           ┆ ---                 ┆ ---      ││ str           ┆ datetime[μs]        ┆ i64      │╞═══════════════╪═════════════════════╪══════════╡│ algebra       ┆ 2024-01-01 00:00:00 ┆ 56       ││ algebra       ┆ 2024-04-01 00:00:00 ┆ 44       ││ geometry      ┆ 2024-01-01 00:00:00 ┆ 35       ││ geometry      ┆ 2024-04-01 00:00:00 ┆ 40       ││ calculus      ┆ 2024-01-01 00:00:00 ┆ 41       ││ calculus      ┆ 2024-04-01 00:00:00 ┆ 39       │└───────────────┴─────────────────────┴──────────┘Your code here isn’t too different from the previous version. You assign1qto theeveryparameter to group the output into quarterly intervals.To specify that you want to group by each subject within each quarter, you assignclass_subjectto thegroup_byparameter of.group_by_dynamic(). You also pass thepl.col(""absences"").sum()expression to.agg().This time, your output contains a separate row for each quarter for each of the three subjects. The first and second quarters start on January 1st and April 1st, respectively. The final column shows the total absences for each subject and quarter.Before you move on, it’s time for some more practice.Trying Out Your Time Series Analysis SkillsExercise: ""Comprehension Check""Show/HideUsing the data inmath_classes.parquet, find each lecturer’s monthly average studentabsences.Solution: ""Comprehension Check""Show/HideOne possible solution could be:Program Output┌───────────────────┬─────────────────────┬──────────┐
│ lecturer_initials ┆ class_start         ┆ absences │
│ ---               ┆ ---                 ┆ ---      │
│ str               ┆ datetime[μs]        ┆ f64      │
╞═══════════════════╪═════════════════════╪══════════╡
│ DH                ┆ 2024-01-01 00:00:00 ┆ 4.0      │
│ DH                ┆ 2024-02-01 00:00:00 ┆ 3.4      │
│ DH                ┆ 2024-03-01 00:00:00 ┆ 4.25     │
│ DH                ┆ 2024-04-01 00:00:00 ┆ 2.5      │
│ DH                ┆ 2024-05-01 00:00:00 ┆ 2.0      │
│ …                 ┆ …                   ┆ …        │
│ LM                ┆ 2024-02-01 00:00:00 ┆ 3.0      │
│ LM                ┆ 2024-03-01 00:00:00 ┆ 3.4      │
│ LM                ┆ 2024-04-01 00:00:00 ┆ 3.8      │
│ LM                ┆ 2024-05-01 00:00:00 ┆ 3.666667 │
│ LM                ┆ 2024-06-01 00:00:00 ┆ 4.6      │
└───────────────────┴─────────────────────┴──────────┘You’ll find the code that produced this result in thesolutions.ipynbfile in your downloads.Next up, you’ll learn about Polars window functions.Remove adsGrouping and Aggregating Using Window FunctionsWindow functions allow you to perform more complex aggregations within.select().In the grouping examples you’ve seen, the resulting output contained a single row for each data grouping. For example, previously, you grouped the records by reason within subject, so your result contained a separate row for each subject-reason combination.Window functions also perform aggregations over groups. However, they apply their results toeachof the original rows within the group. So, the resulting DataFrame will contain the same number of rows as the original, but with an aggregated value assigned to each row.Working With Window FunctionsTo use a window function, you use an aggregation function just like you did before. This time, however, you apply the function to the column expression within.select(), and then use.over()to apply the results over each group member.This is best understood by example. To gauge student motivation, suppose you want to see how the actual absence figure foreach studentcompares to the mean value for each reason within school within subject. This is where window functions can help:Python>>>all_students=pl.read_parquet(""course.parquet"")>>>all_students.select(...pl.col(""subject"",""school"",""student_id"",""reason"",""absences""),...mean_absences=(...pl.col(""absences"")....mean()....over(""subject"",""school"",""reason"")...)...)shape: (1_044, 6)┌─────────┬────────┬────────────┬────────┬──────────┬───────────────┐│ subject ┆ school ┆ student_id ┆ reason ┆ absences ┆ mean_absences ││ ---     ┆ ---    ┆ ---        ┆ ---    ┆ ---      ┆ ---           ││ str     ┆ str    ┆ i64        ┆ str    ┆ i64      ┆ f64           │╞═════════╪════════╪════════════╪════════╪══════════╪═══════════════╡│ M       ┆ GP     ┆ 10001      ┆ course ┆ 6        ┆ 4.104839      ││ M       ┆ GP     ┆ 10002      ┆ course ┆ 4        ┆ 4.104839      ││ M       ┆ GP     ┆ 10003      ┆ other  ┆ 10       ┆ 6.518519      ││ M       ┆ GP     ┆ 10004      ┆ home   ┆ 2        ┆ 7.397959      ││ M       ┆ GP     ┆ 10005      ┆ home   ┆ 4        ┆ 7.397959      ││ …       ┆ …      ┆ …          ┆ …      ┆ …        ┆ …             ││ P       ┆ MS     ┆ 10645      ┆ course ┆ 4        ┆ 2.627119      ││ P       ┆ MS     ┆ 10646      ┆ course ┆ 4        ┆ 2.627119      ││ P       ┆ MS     ┆ 10647      ┆ course ┆ 6        ┆ 2.627119      ││ P       ┆ MS     ┆ 10648      ┆ course ┆ 6        ┆ 2.627119      ││ P       ┆ MS     ┆ 10649      ┆ course ┆ 4        ┆ 2.627119      │└─────────┴────────┴────────────┴────────┴──────────┴───────────────┘You created your new column usingpl.col(""absences"").mean()to indicate that you want the mean of the original absences. This time, instead of using it within.agg(), you call.over(""subject"", ""school"", ""reason"")to calculate the mean of each reason within school within subject grouping, and to apply the mean value to each row of the associated original data. In other words, you’ve applied the corresponding mean value to each student’s row.For example, look at themean_absencesfigures in the highlighted lines. These both contain7.397959because this is the mean absence value corresponding to theM-GP-homecombination. Students10004and10005each belong to this grouping.Similarly, the bottom five rows in the output also contain identical mean absences because they all belong to the same grouping. In this case, it’sP-MS-course.Looking at the output, you notice that some students—such as student10001—have a higher-than-average number of absences compared to others who are taking the same course, at the same school, for the same reason. If you’re only interested in students with above-average absences, then you can filter by the new column:Python>>>all_students.select(...pl.col(""subject"",""school"",""student_id"",""reason"",""absences""),...mean_absences=(...pl.col(""absences"")....mean()....over(""subject"",""school"",""reason"")...)...).filter(pl.col(""absences"")>pl.col(""mean_absences""))shape: (381, 6)┌─────────┬────────┬────────────┬────────────┬──────────┬───────────────┐│ subject ┆ school ┆ student_id ┆ reason     ┆ absences ┆ mean_absences ││ ---     ┆ ---    ┆ ---        ┆ ---        ┆ ---      ┆ ---           ││ str     ┆ str    ┆ i64        ┆ str        ┆ i64      ┆ f64           │╞═════════╪════════╪════════════╪════════════╪══════════╪═══════════════╡│ M       ┆ GP     ┆ 10001      ┆ course     ┆ 6        ┆ 4.104839      ││ M       ┆ GP     ┆ 10003      ┆ other      ┆ 10       ┆ 6.518519      ││ M       ┆ GP     ┆ 10006      ┆ reputation ┆ 10       ┆ 6.72          ││ M       ┆ GP     ┆ 10019      ┆ course     ┆ 16       ┆ 4.104839      ││ M       ┆ GP     ┆ 10026      ┆ home       ┆ 14       ┆ 7.397959      ││ …       ┆ …      ┆ …          ┆ …          ┆ …        ┆ …             ││ P       ┆ MS     ┆ 10645      ┆ course     ┆ 4        ┆ 2.627119      ││ P       ┆ MS     ┆ 10646      ┆ course     ┆ 4        ┆ 2.627119      ││ P       ┆ MS     ┆ 10647      ┆ course     ┆ 6        ┆ 2.627119      ││ P       ┆ MS     ┆ 10648      ┆ course     ┆ 6        ┆ 2.627119      ││ P       ┆ MS     ┆ 10649      ┆ course     ┆ 4        ┆ 2.627119      │└─────────┴────────┴────────────┴────────────┴──────────┴───────────────┘The filter expression is similar to those you used earlier. You usepl.col(""absences"") > pl.col(""mean_absences"")to make sure only thoseabsencesgreater than themean_absencesare included in the results.Before moving on, it’s time for yet another exercise:Trying Out Your Window Function SkillsExercise: ""Comprehension Check""Show/HideUsing thecourse.parquetdata, work out the mean values of the first (G1) and second (G2) period grades for eachreasonwithinsubject. Your output should include the following columns, in this order:subject,reason,G1,mean_G1,G2, andmean_G2. Display only the rows where bothG1andG2are above their group’s mean.Solution: ""Comprehension Check""Show/HideOne possible solution could be:Program Output┌─────────┬────────────┬─────┬───────────┬─────┬───────────┐
│ subject ┆ reason     ┆ G1  ┆ mean_G1   ┆ G2  ┆ mean_G2   │
│ ---     ┆ ---        ┆ --- ┆ ---       ┆ --- ┆ ---       │
│ str     ┆ str        ┆ i64 ┆ f64       ┆ i64 ┆ f64       │
╞═════════╪════════════╪═════╪═══════════╪═════╪═══════════╡
│ M       ┆ home       ┆ 15  ┆ 10.816514 ┆ 14  ┆ 10.743119 │
│ M       ┆ reputation ┆ 15  ┆ 11.457143 ┆ 15  ┆ 11.257143 │
│ M       ┆ home       ┆ 12  ┆ 10.816514 ┆ 12  ┆ 10.743119 │
│ M       ┆ home       ┆ 16  ┆ 10.816514 ┆ 18  ┆ 10.743119 │
│ M       ┆ home       ┆ 14  ┆ 10.816514 ┆ 15  ┆ 10.743119 │
│ …       ┆ …          ┆ …   ┆ …         ┆ …   ┆ …         │
│ P       ┆ home       ┆ 17  ┆ 11.657718 ┆ 18  ┆ 11.785235 │
│ P       ┆ home       ┆ 14  ┆ 11.657718 ┆ 15  ┆ 11.785235 │
│ P       ┆ other      ┆ 14  ┆ 10.694444 ┆ 17  ┆ 10.777778 │
│ P       ┆ course     ┆ 15  ┆ 10.982456 ┆ 15  ┆ 11.147368 │
│ P       ┆ course     ┆ 11  ┆ 10.982456 ┆ 12  ┆ 11.147368 │
└─────────┴────────────┴─────┴───────────┴─────┴───────────┘You’ll find the code that produced this result in thesolutions.ipynbfile in your downloads.The final section of your journey through aggregation and grouping will show you how to create pivot tables in Polars.Grouping and Aggregating Using Pivot TablesApivot tableis a data analysis tool that allows you to take columns of raw data from a DataFrame, summarize them, and then analyze the summary data. This summarization may include several statistical calculations, such as sums, averages, and so on, revealing insights previously hidden within the original data.Note:Polars pivot tables will only work on DataFrames, not LazyFrames. This is because all data needs to be available to allow them to determine what columns are required in their output.In this section, you’ll learn how pivot tables allow you to group and aggregate data.Remove adsCreating a Pivot TableSuppose you wanted to analyze the average number of failures and absences for each subject at each school to see if there were any patterns between the two. One way of doing this would be to reuse the techniques you’ve already seen:Python>>>importpolarsaspl>>>all_students=pl.read_parquet(""course.parquet"")>>>(...all_students....group_by([""subject"",""school""])....agg(...mean_absence=pl.col(""absences"").mean(),...mean_failure=pl.col(""failures"").mean(),...)...)shape: (4, 4)┌─────────┬────────┬──────────────┬──────────────┐│ subject ┆ school ┆ mean_absence ┆ mean_failure ││ ---     ┆ ---    ┆ ---          ┆ ---          ││ str     ┆ str    ┆ f64          ┆ f64          │╞═════════╪════════╪══════════════╪══════════════╡│ M       ┆ GP     ┆ 5.965616     ┆ 0.318052     ││ M       ┆ MS     ┆ 3.76087      ┆ 0.456522     ││ P       ┆ MS     ┆ 2.619469     ┆ 0.314159     ││ P       ┆ GP     ┆ 4.21513      ┆ 0.172577     │└─────────┴────────┴──────────────┴──────────────┘The output shows the data grouped by school within each subject. For each grouping, the mean absence and failure figures are shown.As an alternative, you could create a pivot table of the data using.pivot():Python>>>(...all_students.pivot(...on=""school"",...index=""subject"",...values=[""absences"",""failures""],...aggregate_function=""mean""...)...)shape: (2, 5)┌─────────┬─────────────┬─────────────┬─────────────┬─────────────┐│ subject ┆ absences_GP ┆ absences_MS ┆ failures_GP ┆ failures_MS ││ ---     ┆ ---         ┆ ---         ┆ ---         ┆ ---         ││ str     ┆ f64         ┆ f64         ┆ f64         ┆ f64         │╞═════════╪═════════════╪═════════════╪═════════════╪═════════════╡│ M       ┆ 5.965616    ┆ 3.76087     ┆ 0.318052    ┆ 0.456522    ││ P       ┆ 4.21513     ┆ 2.619469    ┆ 0.172577    ┆ 0.314159    │└─────────┴─────────────┴─────────────┴─────────────┴─────────────┘To create your pivot table, you pass several parameters to.pivot(). By passingon=""school"", you tell Polars to aggregate the data for each school. In this dataset, they’re annotated byGPandMS, and each school will have a separate set of results. Passing in a list of columns is possible if you want a more atomic analysis. You’ll see how this works later.Theindexparameter defines the rows of the output. By passingsubject, you specify that you want each subject’s data in a separate row. You’ve created separate rows for math (M) and Portuguese (P). This is similar to the grouping functionality you saw earlier. Although not relevant here, it’s also possible to specify sub-groupings by passing in a list of columns to use.Thevaluesparameter defines the data columns on which you want to perform the aggregate calculation. In this case, you want to do so on both theabsencesandfailurescolumns. This gives you results for both of these.Finally, you need to define which aggregate calculation you wish to perform. In this case, you want to calculate mean values, which you do by settingaggregate_functionto""mean"". One drawback with.pivot()is that you can only pass a single aggregation function to theaggregate_functionparameter. If you use.agg(), then you can pass in several aggregation functions as you saw earlier. However, you only need one here.When you first look at your pivot table, you’ll notice that it has created some of its own column headings. As mentioned earlier, the main aggregated data comes from the originalabsencesandfailurescolumns. To present these aggregations for each school, Polars creates a column for each of them. That’s where theabsences_GP,absences_MS,failures_GP, andfailures_MScolumn headings come from.Customizing Column OrderIf you want to make the output more readable so that each school’s mean absence and failure figures are next to each other, you can use.select()to define the order in which the columns are displayed:Python>>>(...all_students....pivot(...on=""school"",...index=""subject"",...values=[""absences"",""failures""],...aggregate_function=""mean"",...)....select(...pl.col(...""subject"",...""absences_GP"",...""failures_GP"",...""absences_MS"",...""failures_MS"",...)...)...)shape: (2, 5)┌─────────┬─────────────┬─────────────┬─────────────┬─────────────┐│ subject ┆ absences_GP ┆ failures_GP ┆ absences_MS ┆ failures_MS ││ ---     ┆ ---         ┆ ---         ┆ ---         ┆ ---         ││ str     ┆ f64         ┆ f64         ┆ f64         ┆ f64         │╞═════════╪═════════════╪═════════════╪═════════════╪═════════════╡│ M       ┆ 5.965616    ┆ 0.318052    ┆ 3.76087     ┆ 0.456522    ││ P       ┆ 4.21513     ┆ 0.172577    ┆ 2.619469    ┆ 0.314159    │└─────────┴─────────────┴─────────────┴─────────────┴─────────────┘Although the data in each column is the same, you’ve arranged them so that the columns for each school appear next to one another.The output shows the mean absences and failures for each subject and school. Interestingly,GPschool appears to fare slightly better thanMS. Although its absence rate is higher, its failure rate is lower. If any students are reading this, please don’t take it to mean that less attendance will lead to greater success. In practice, the opposite is most definitely true.Digging Deeper With Your AnalysisFinally, you might want to sub-analyze your data to determine if it’s related to the reasons for attending the schools. This can be done by tweaking your pivot table:Python>>>(...all_students....pivot(...on=""school"",...index=[""subject"",""reason""],...values=[""absences"",""failures""],...aggregate_function=""mean"",...)....select(...pl.col(...""subject"",...""reason"",...""absences_GP"",...""failures_GP"",...""absences_MS"",...""failures_MS"",...)...)...)shape: (8, 6)┌─────────┬────────────┬─────────────┬─────────────┬─────────────┬─────────────┐│ subject ┆ reason     ┆ absences_GP ┆ failures_GP ┆ absences_MS ┆ failures_MS ││ ---     ┆ ---        ┆ ---         ┆ ---         ┆ ---         ┆ ---         ││ str     ┆ str        ┆ f64         ┆ f64         ┆ f64         ┆ f64         │╞═════════╪════════════╪═════════════╪═════════════╪═════════════╪═════════════╡│ M       ┆ course     ┆ 4.104839    ┆ 0.33871     ┆ 3.190476    ┆ 0.52381     ││ M       ┆ other      ┆ 6.518519    ┆ 0.333333    ┆ 2.888889    ┆ 0.222222    ││ M       ┆ home       ┆ 7.397959    ┆ 0.357143    ┆ 4.909091    ┆ 0.636364    ││ M       ┆ reputation ┆ 6.72        ┆ 0.25        ┆ 5.2         ┆ 0.2         ││ P       ┆ course     ┆ 3.928144    ┆ 0.245509    ┆ 2.627119    ┆ 0.449153    ││ P       ┆ other      ┆ 3.407407    ┆ 0.185185    ┆ 2.4         ┆ 0.244444    ││ P       ┆ home       ┆ 4.869565    ┆ 0.130435    ┆ 3.058824    ┆ 0.147059    ││ P       ┆ reputation ┆ 4.166667    ┆ 0.105263    ┆ 2.413793    ┆ 0.068966    │└─────────┴────────────┴─────────────┴─────────────┴─────────────┴─────────────┘To perform the calculation byreasonwithinsubject, you pass both columns as a list to theindexparameter. You also adjust.select()to includereason. These small changes have made a significant difference to your output. This time, the results are more atomically analyzed.Again, it appears that, on average, more students seem to be failing math atMSdespite their better attendance. The same trend is broadly similar for Portuguese. This time, you can also see that students who chose a school because it was closest to their home have the highest average absence rates.There’s time for one final exercise.Remove adsTrying Out Your Pivot Table SkillsExercise: ""Comprehension Check""Show/HideCreate a pivot table that contains rows for gender (sex) within eachsubject. For each of these combinations, calculate the average of gradeG1and the average of gradeG2for each school.Solution: ""Comprehension Check""Show/HideOne possible solution could be:Program Output┌─────────┬─────┬───────────┬───────────┬───────────┬───────────┐
│ subject ┆ sex ┆ G1_GP     ┆ G1_MS     ┆ G2_GP     ┆ G2_MS     │
│ ---     ┆ --- ┆ ---       ┆ ---       ┆ ---       ┆ ---       │
│ str     ┆ str ┆ f64       ┆ f64       ┆ f64       ┆ f64       │
╞═════════╪═════╪═══════════╪═══════════╪═══════════╪═══════════╡
│ M       ┆ F   ┆ 10.579235 ┆ 10.92     ┆ 10.398907 ┆ 10.32     │
│ M       ┆ M   ┆ 11.337349 ┆ 10.380952 ┆ 11.204819 ┆ 10.047619 │
│ P       ┆ F   ┆ 12.28692  ┆ 10.582192 ┆ 12.50211  ┆ 10.719178 │
│ P       ┆ M   ┆ 11.602151 ┆ 9.7875    ┆ 11.688172 ┆ 10.0875   │
└─────────┴─────┴───────────┴───────────┴───────────┴───────────┘You’ll find the code that produced this result in thesolutions.ipynbfile in your downloads.Congratulations on completing this tutorial. You can now look forward to confidently aggregating and grouping your datasets to reveal previously hidden insights.Get Your Code:Click here to download the free sample codethat you’ll use to learn about grouping data with Polars .group_by().ConclusionThis tutorial showed you how to summarize data using various aggregation and grouping techniques. Now, you should have a solid understanding of how to use Polars.group_by()to group data by column values.You’ve also learned how to:Use simpleaggregationto find summary valuesFilterdata based on aggregated valuesSubdivide your data intogroupsand perform aggregations on each groupSummarizetime seriesdataUsewindow functionsto compare summarized and original dataPerform more intense summarizations withpivot tablesWhile you’ve had a good overview of typical data aggregation and grouping techniques, you’re strongly encouraged to practice using your own datasets or those freely available on sites likeKaggle. It’s also worthwhile to keep an eye on thePolars documentationas well. Matt Harrison’sEffective Polarswill give you many examples to play with.Frequently Asked QuestionsNow that you have some experience grouping data using Polars.group_by()in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.How does Polars.group_by()work?Show/HideYou use Polars.group_by()to create groups based on unique values in a specified column. Once grouped, you can perform aggregations on each group independently to summarize your data.Does Polars.group_by()preserve order?Show/HidePolars.group_by()doesn’t preserve the order of the data. The method processes data based on the unique values of the specified column, disregarding the original order.How do you handle time series data in Polars?Show/HideYou handle time series data in Polars using.group_by_dynamic(), which lets you group data based on time intervals. You specify the time column and the interval, such as “1w” for weekly, to create time-based groupings for analysis.What are window functions in Polars, and how do you use them?Show/HideWindow functions in Polars allow you to perform aggregations over groups while retaining the original DataFrame’s structure. You use them by applying aggregation functions with.over(), which assigns the aggregated value to each row in the group.How do pivot tables work in Polars?Show/HideYou create pivot tables in Polars using.pivot(), which summarizes data by aggregating specified columns over defined indexes and columns. You choose the aggregation function, such as “mean” or “sum,” to analyze patterns in your data.Take the Quiz:Test your knowledge with our interactive “How to Group Data Using Polars .group_by()” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizHow to Group Data Using Polars .group_by()Put your Polars .group_by() and aggregation skills to the test. This quiz goes beyond the tutorial, so you'll need to dig deeper to find all the answers.Mark as CompletedShare"
How to Get the Most Out of PyCon US,https://realpython.com/pycon-guide/,"May 14, 2025",N/A,"career, community","Table of ContentsWhat PyCon InvolvesWhat to Do Before You GoWhat to Do at PyConTalksOpen SpacesSponsorsVolunteer OpportunitiesAfter-Hours ActivitiesNew FriendsWhat to Do After PyConWelcome to the Greatest Community!Remove adsCongratulations! You’re going to PyCon US!Whether this is your first time or you’re a regular attendee, going to a conference full of people who love the same thing as you is always a fun experience. There’s so much more to PyCon than just a bunch of people talking about the Python language—it’s a vibrant community event filled with talks, workshops, hallway conversations, and social gatherings. But for first-time attendees, it can also feel a little intimidating. This guide will help you navigate all there is to see and do at PyCon.PyCon USis the biggest conference centered around Python. Originally launched in 2003, this conference has grown exponentially and has even spawned several otherPyCons and workshops around the world.Everyone who attends PyCon will have a different experience, and that’s what makes the conference truly unique. This guide is meant to help you, but you don’t need to follow it strictly.By the end of this article, you’ll know:How PyCon consists oftutorials,conference, andsprintsWhat to dobeforeyou goWhat to doduringPyConWhat to doafterthe eventHow to have agreatPyConThis guide contains links that are specific to PyCon 2025, but it should be useful for future PyCons as well.Free Download:Get a sample chapter from Python Tricks: The Bookthat shows you Python’s best practices with simple examples you can apply instantly to write more beautiful + Pythonic code.What PyCon InvolvesBefore considering how to get the most out of PyCon, it’s first important to understand what PyCon involves.PyCon is divided into three stages:Tutorials:PyCon starts with two days of three-hour workshops, during which you learn in depth with instructors. These sessions are worth attending because the class sizes are small, and you’ll have the chance to ask instructors questions directly. You should consider going to at least one of these if you can. They have an additional cost of $150 per tutorial.Conference:Next, PyCon offers three days of talks. Each presentation runs for 30 to 45 minutes, and around five talks run concurrently, including a Spanish-language charlas track. But that’s not all: there are open spaces, sponsors, posters, lightning talks, dinners, and so much more.Sprints:During this stage, you can take what you’ve learned and apply it! This is a four-day exercise where people group up to work on various open-source projects related to Python. If you’ve got the time, going to one or more sprint days is a great way to practice what you’ve learned, become associated with an open-source project, and network with other smart and talented people. If you’re still unconvinced, here’swhat to expect at this year’s PyCon US sprints. Learn more about sprints from an earlier year in thisblog post.Since most PyCon attendees go to the conference part, that’ll be the focus of this article. However, don’t let that deter you from attending the tutorials or sprints if you can!You may learn more technical skills by attending the tutorials rather than listening to the talks. The sprints are great for networking and applying the skills you already have, as well as learning new ones from the people you’ll be working with.Remove adsWhat to Do Before You GoIn general, the more prepared you are for something, the better your experience will be. The same applies to PyCon.It’s really helpful to plan and prepare ahead of time, which you’re already doing just by reading this article!Look through thetalks scheduleand see which talks sound most interesting. This doesn’t mean you need to plan out all of the talks you’ll see in every slot possible. But it helps to get an idea of which topics will be presented so that you can decide what you’re most interested in.Getting thePyCon US mobile appwill help you plan your schedule. This app lets you view the schedule for the talks and add reminders for those you want to attend. If you’re having a hard time picking which talks to attend, you can come prepared with a question or problem you need to solve. Doing this can help you focus on the topics that are important to you.If you can, come a day early to check in and attend the opening reception. The line to check in on the first day is always long, so you’ll save time if you check in the day before. There’s also an opening reception that evening, where you can meet other attendees and speakers and check out the various sponsors and their booths.If you’re new to PyCon, theNewcomer Orientationcan help you learn about the conference and how you can participate.Because of the COVID pandemic, which caused PyCon 2020 and PyCon 2021 to go remote, extrahealth and safety guidelinesare still in place for this year’s PyCon conference. For the first time since 2022, masks are encouraged but not required, especially in crowded or enclosed spaces. Stay safe!Recap:Here’s what to do before you go:Look at thetalks schedule.Get thePyCon US mobile app.Come up with a specific question that you want answered.Check in the day before the conference begins.Review thehealth and safety guidelines.What to Do at PyConIt’s okay if you’re nervous or excited on your first day at the conference.There will be a lot of different people from all walks of life, and that’s what makes it so great. You may see some of your Python heroes, such asGuido van Rossum, and have a chance to go up to them and say hello.Guido van Rossum With the Python Staff of EnlightenmentThe Python community is very welcoming! But there are also some designated quiet rooms where speakers and others will go to work in peace. You should refrain from talking to anyone in those rooms to allow them that safe space.You can break down the conference into some key elements to see how you can get the most out of them:TalksOpen spacesSponsorsVolunteer opportunitiesAfter-hours activities, including lightning talksTime for yourselfTalksGo to as many of the talks as you want, but you don’t need to attend them all. You’ll only get stressed as you run from room to room. Instead, ensure you hit up the talks you selected before coming. Although it’s rare, the schedule can change, so check the schedule board daily to catch any changes.'Light Up Your Life⁠ — With Python and LEDs' Talk Given by Nina Zakharenko at PyCon 2019If there’s a conflict between two talks you want to attend, remember that all presentations are recorded anduploaded to YouTube. Sometimes, they’re even available that same day! Pick the talk that will be the most relevant to your situation and seems the most interesting to you. Then take note of the talk you’ll miss, and watch it later when you have some free time.Even though all talks are available online, attending in person is still valuable. You’re more likely to retain the information, and you’ll have the chance to ask the presenter questions directly.Remember, you don’t need to see all the so-called celebrity speakers. While they may get more attention in the Python community and seem like must-see sessions, every talk at PyCon goes through a rigorous selection process, ensuring that all speakers and topics are worth your time.Sometimes, it’s better to see some less famous speakers because you can get better seats and have a greater chance to ask questions.Remember to silence your phone and computer when you go to a talk. Noise can be very distracting to the audience and the speaker. Consider putting away your devices altogether and simply listening or taking notes with pen and paper.Also consider thinking of questions related to the topic being discussed. Typically, there’s time set aside at the end for audience questions. If that time isn’t available, the presenters are usually very willing to answer questions in the hallway afterward.Recap:Here’s what you need to know about talks at PyCon:You don’t need to go to every talk—all sessions will be available on YouTube.All talks and speakers are amazing.Keep noise to a minimum by silencing your devices.Think of questions to ask.Talk with speakers afterward.Remove adsOpen SpacesOpen spaces are rooms that conference attendees can book. One-hour time slots are available throughout the day for anyone who wants to use them. These rooms are used to teach people, hold meetups, and even do yoga classes. They’re open for whatever activities you need them for, as long as you follow theCode of Conduct, of course.Open Spaces Board at PyCon 2019You may want to visit these open spaces instead of a talk or a sponsor booth. Check out the open space board daily since it constantly changes. It’s a good idea to take a picture of the board to reference later.Feel free to create your own open space. Remember that problem or specific question that you were looking for help with? Sign up for a room and ask for advice on that topic! You never know who might show up to help out.Real Python hosted open spaces at PyCon in 2019 and 2022. They were great events with existing members and people who didn’t know us very well. We won’t be hosting an open space this year, but you should definitely check out some of the other exciting get-togethers happening at the conference.If you’re an expert or have some limited knowledge about a topic you want to share, feel free to grab an open space for that as well! These spaces are intended to be whatever you want or need them to be, so don’t be shy about using them.Recap:Here’s what you need to know about open spaces at PyCon:Open spaces can be whatever you need them to be.Use an open space slot to ask for help.Use an open space slot to teach others.SponsorsVisiting sponsors is a great way to get to know some of the companies that are using Python in their everyday workflows. There are some very big names that come almost every year: Microsoft, JetBrains, and Google, to name a few. At PyCon 2025, there will be about ninety-five sponsors! Going to a sponsor booth is great for many reasons, not just for the wonderful swag that everyone gives out. Here are a few of our favorites:Real Python Swag: Meet us at PyCon and Get Some StickersThe greatest thing about sponsors being there is that you can speak with the actual developers of the tools and software you use. Say you have a problem with an Anaconda install on a Windows environment. You can go straight up to the Anaconda booth and ask questions! This is a great opportunity to talk to the developers and creators of the tools you use.It’s not just developers that you get to meet, either. There are authors and content creators who come too. Walk the floor and strike up conversations. You’re bound to meet lots of interesting people.Finally, meeting with the sponsors could lead to a job opportunity. Many sponsors are also looking for talented Python developers, and you can apply with them directly at their booths or during the job fair, which happens toward the end of the conference. If you’re not looking for a job, it’s still great to see what’s out there and what skills these companies are looking for to help you choose where to focus your learning.Recap:Here’s what you need to know about sponsors at PyCon:Getting sponsor swag is great.Meeting with the developers and content creators is even better.You can apply for a job or see what skills companies are looking for.Volunteer OpportunitiesHave you ever wished you could contribute orgive backto the Python community? Well, you can at PyCon.So much work goes into making a conference happen, and none of it would be possible without volunteers. PyCon 2025 is looking for over 300 hours of on-site volunteer support!!That sounds like a lot, but there are small ways you can make a difference. An hour or two of your time can be a big help, without taking away from your learning time. You also never know who you might rub shoulders with as a volunteer. You can learn more about helping out in thecall for on-site volunteers. As you’ll see, there’s a little something for everyone.Recap:Here’s what you need to know about volunteering at PyCon:Just Do It.Really, Just Do It!Remove adsAfter-Hours ActivitiesEven though the conference ends in the early evening, there’s still more to do after the conference wraps up for the day.The first thing you should check out, even if only for a little while, is thelightning talks. These are five-minute slots available for anyone to share their knowledge on a topic. The talks span a wide range of subjects, from new open-source projects to social commentary and philanthropy. Did you know thatDocker was first publicly announced during a PyCon lightning talk? The lightning talks have become a popular staple for regular attendees.Also, be on the lookout for sponsors doing sponsored dinners with members of their company. This is a great way to build up your network and get a free dinner as well. PyCon does host dinner parties in the evenings, but these cost money and typically sell out really quickly.Even if you don’t get in on the official PyCon dinners or the sponsored ones, there’s always plenty to check out near the conference. Each conferencelocationis selected in part because of the interesting things nearby. When you’re getting ready for the conference, look for fun places to eat. You’ll find that downtown Pittsburgh has plenty.Recap:Here’s what you need to know about after-hours events at PyCon:Check out the lightning talks.If there are spots available, sign up for one of the official PyCon dinners.Check early and often for any sponsored dinners.Have fun exploring the local cuisine and culture.New FriendsOne of the most significant pieces of advice for going to PyCon is to make a new friend each day.Dan Bader and Andres PinedaThe lunch and snack breaks are some of the best times to get to know someone at PyCon. Instead of trying to pick an empty table, find one that already has a person or two and ask if you can join them.Strike up a conversation about their favorite talk so far, or how they use Python in their day-to-day activities. Before long, you might find you’ve made a new friend. You can take a few notes about your conversation, whether mentally or literally, so that you can remember that person later on.To stay in touch with the people you meet, consider creating business cards that include your contact information. Additionally, update any profiles you share, such as LinkedIn or GitHub.Recap:Here’s what you need to know about making new friends at PyCon:Challenge yourself to meet at least one new person each day.Make a quick note of who you meet so you don’t forget.Bring business cards to share with the people you connect with.What to Do After PyConOnce the conference is over, there’s still a lot you can do. First off, if you have the time, there are thedev sprints, which are an excellent opportunity for you to hone your skills and even gain new ones as a Python developer. They last four days after the conference, but you don’t need to stay the entire time. Stay for as long as you like, whether for a few hours or the duration.After you get home, check out the YouTube videos of talks you missed or want to rewatch. You can also check out all of the tutorials, keynote speaker talks, and even the lightning talks on YouTube. There’s plenty there to get your PyCon fix throughout the year.The greatest thing about PyCon is the feeling of belonging to a community. That’s only made possible by the great people who give back to the Python community, and you can become one of them!There are lots of ways that you can give back to this great community:Contribute to an open-source project that uses Python.Join a local Python meetup group. Don’t have one? Create one!Share with others what you’ve learned.Submit a talk or poster for next year’s PyCon.Finally, you can start preparing for the next PyCon. You get a discounted price when you purchase tickets early, but those tickets tend to sell out quickly. To prepare for which talks to attend at the next PyCon, you can start taking note of any problems or questions you run into throughout the year. They can help you choose which talks to attend next time.Recap:Here’s what you need to know about what to do after the conference:If you have time, stay for the sprints.Check out the YouTube videos of the talks that you missed or loved.Look for a way to contribute to the Python community with what you learned.Start looking at next year’s PyCon.Remove adsWelcome to the Greatest Community!Congratulations! You’re about to attend one of the greatest technical conferences out there, and you’re well-equipped to make the most of your time there.In this article, you learned:What PyCon isall aboutWhat you can dobeforegoing to PyConWhat you can doatPyConWhat you can doafterPyConWith the tips in this article, you’ll be able to have a great PyCon. We look forward to seeing you there!Mark as CompletedShare"
Working With Missing Data in Polars,https://realpython.com/courses/missing-data-polars/,"May 13, 2025",38m,"intermediate, data-science, python","Efficiently handling missing data in Polars is essential for keeping your datasets clean during analysis. Polars provides powerful tools to identify, replace, and remove null values, ensuring seamless data processing.This video course covers practical techniques for managing missing data and highlights Polars’ capabilities to enhance your data analysis workflow. By following along, you’ll gain hands-on experience with these techniques and learn how to ensure your datasets are accurate and reliable.By the end of this video course, you’ll understand that:Polarsallows you to handle missing data usingLazyFramesandDataFrames.You cancheck for null valuesin Polars using the.null_count()method.NaNrepresents non-numeric values whilenullindicates missing data.You canreplace NaNin Polars by converting them to nulls and using.fill_null().You canfix missing databy identifying, replacing, or removing null values.What’s Included:9 LessonsVideo Subtitles and Full Transcripts2 Downloadable ResourcesAccompanying Text-Based TutorialInteractive Quiz to Check Your ProgressQ&A With Python Experts: Ask a QuestionCertificate of CompletionDownloadable Resources:Course Slides (.pdf)Sample Code (.zip)"
Python's T-Strings Coming Soon and Other Python News for May 2025,https://realpython.com/python-news-may-2025/,"May 12, 2025",N/A,community,"Table of ContentsPEP 750: Template Strings Coming to PythonOther Python Language DevelopmentsPython 3.14.0a7 ReleasedPEP 751: A File Format to Record Python DependenciesPEP 768: A Safe Debugging Interface for CPythonPEP 781: A Built-in Constant for TYPE_CHECKINGDjango and Web DevelopmentDjango 5.2 ReleasedSecurity Updates for Django 5.0, 4.2, and 3.2Python Community EventsPyCon US 2025 Kicks Off This MonthEuroPython 2025 Heads to PragueWhat’s Next for Python?Remove adsWelcome to the May 2025 edition of the Python news roundup. Last month brought confirmation that Python will have the eagerly-awaited template strings, or t-strings, included in the next release. You’ll also read about other key developments in Python’s evolution from the past month, updates from the Django world, and exciting announcements from the community around upcoming conferences.From newPEPs and alpha releases to major framework updates, here’s what’s been happening in the world of Python.Join Now:Click here to join the Real Python Newsletterand you'll never miss another Python tutorial, course update, or post.PEP 750: Template Strings Coming to PythonPEP 750introducestemplate strings, a new standard mechanism for defining string templates as reusable, structured objects. Unlikef-stringsorstr.format(), which embed formatting directly in string literals, template strings separate the definition of the string structure from the data used to populate it:Python>>>template=t""Howdy, {input('Enter your name: ')}!""Enter your name: Stephen>>>templateTemplate(strings=('Howdy, ', '!'),interpolations=(Interpolation('Stephen', ""input('Enter your name: ')"", None, ''),))>>>foritemintemplate:...print(item)...Howdy,Interpolation('Stephen', ""input('Enter your name: ')"", None, '')!This new tool opens up new possibilities for dynamic formatting, localization, user-facing messages, and more. It also makes it easier to share and reuse format templates across an application. The addition of t-strings is already being described as a major enhancement to Python’s string-handling capabilities.Remove adsOther Python Language DevelopmentsPython 3.14 continues to take shape, with a new alpha release and several PEPs being accepted or proposed. These updates give a sense of where the language is heading, especially in areas likedebugging,dependency management, andtype checking.Python 3.14.0a7 ReleasedPython 3.14.0a7was released in April, marking thefinal alphain the Python 3.14 development cycle. This release includes several fixes and tweaks, with the focus now shifting to stabilization as the first beta approaches.Alongside the 3.14 alpha, the Python core team also issued a set ofmaintenance releases:3.13.3,3.12.10,3.11.12,3.10.17, and3.9.22. These include bug fixes and security patches across all actively supported Python versions.With the alpha phase complete, Python 3.14 will now enter beta. That means no new features will be added, and the focus will shift to fixing bugs and finalizing documentation ahead of the official release later this year.PEP 751: A File Format to Record Python DependenciesPEP 751has been accepted. This PEP defines a new file format based onTOMLfor recording dependencies, aimed at enablingreproducible installsacross environments.The format captures the state of a project’s environment at a point in time, allowing developers to install exactly the same versions of every dependency, regardless of operating system or Python version. While still an early step, this format could eventually support a more consistent and reliable project setup experience for Python users.PEP 768: A Safe Debugging Interface for CPythonPEP 768has also been accepted and introduces a new, low-overhead interface for external debuggers to connect to running Python processes. Inspired by tools likegdb -p, this interface allows debuggers to safely attach to a liveCPythonprocess by its process ID and run debugging scripts at predefined points during interpreter execution.The design avoids unsafe code injection by extending Python’s thread state and evaluation loop, ensuring compatibility withmultithreadedprograms and Python’s audit hooks. While this PEP is primarily aimed at tool developers, Python users can expect better stability and support in advanced debugging tools as a result.The change is part of an ongoing effort to improve Python’s introspection and tooling capabilities without compromising runtime safety.PEP 781: A Built-in Constant forTYPE_CHECKINGPEP 781is a new draft proposing thatTYPE_CHECKING, currently part of thetypingmodule, become abuilt-in constant. It’s often used to wrap import statements that are only needed during static analysis.By makingTYPE_CHECKINGalways available, this change would remove a common friction point for library authors and simplify conditional imports in type-hinted code.Django and Web DevelopmentApril was a busy month forDjangodevelopers. A new release and important security updates brought improvements and fixes across multiple supported versions.Django 5.2 ReleasedThe Django team releasedversion 5.2, adding several developer-facing improvements:Support for composite primary keys, a long-requested featureAutomatic model imports in the interactive shellEnhanced options for customizing how forms render in templatesIf you’ve ever manually set up custom form widgets or imported your models every time you ranmanage.py shell, then this release might make your life a little easier.Remove adsSecurity Updates for Django 5.0, 4.2, and 3.2The team also issuedsecurity patchesfor supported Django versions to address potential vulnerabilities in file uploads and some edge cases in SQL query generation.Django users are encouraged to update as soon as possible to ensure they’re protected.Python Community EventsTwo of the biggest Python conferences are on the horizon, withPyCon USjust weeks away andEuroPythonset for early summer.PyCon US 2025 Kicks Off This MonthPyCon US 2025will take place in Pittsburgh from May 14 to 22. Attendees can look forward to a packed schedule of talks, tutorials, and sprints, along with keynotes from leaders in the Python ecosystem.The event also includes a hallway track,lightning talks, and plenty of chances to connect with fellow developers. To prepare yourself and maximize your experience, check out our helpful guide onHow to Get the Most Out of PyCon US.If you can’t make it in person, livestreams and recordings will be available.EuroPython 2025 Heads to PragueEuroPython 2025is scheduled for July 14 to 20 in Prague, Czech Republic. Ticket sales are now open.As one of the largest Python events in Europe, EuroPython brings together developers, educators, and researchers from across the continent and beyond.What’s Next for Python?Python 3.14 is now transitioning from its alpha phase to beta, which means the language feature set is frozen and the focus shifts to testing and documentation. Several accepted PEPs—like template strings and a reproducible dependency format—are already shaping what Python 3.14 will deliver.Elsewhere, Python’s type system continues to evolve, and new capabilities like safe debugger interfaces are paving the way for better tooling and developer experiences.We’ll be back next month with more highlights from the Python world. Happy Pythoning!Mark as CompletedShare"
How to Use Loguru for Simpler Python Logging,https://realpython.com/python-loguru/,"May 07, 2025",N/A,"intermediate, tools","Table of ContentsInstalling LoguruVerifying the InstallationUnderstanding Basic Setup ConsiderationsLearning the Fundamentals of Logging With LoguruGetting Started With Zero ConfigurationUnderstanding Log LevelsCustomizing LogsAdding Context to LogsLogging to Files Using LoguruError Handling and Debugging With LoguruUsing the @logger.catch DecoratorUsing Improved Tracebacks With Customized Error MessagesDebugging With Contextualized ErrorsStructured Logging for Modern ApplicationsFormatting Logs as JSONCreating Custom JSON FormatsConclusionNext StepsFrequently Asked QuestionsRemove adsIn Python, logging is a vital programming practice that helps you track, understand, and debug your application’s behavior. Loguru is a Python library that provides simpler, more intuitive logging compared to Python’s built-inloggingmodule.Good logging gives you insights into your program’s execution, helps you diagnose issues, and provides valuable information about your application’s health in production. Without proper logging, you risk missing critical errors, spending countless hoursdebuggingblind spots, and potentially undermining your project’s overall stability.By the end of this tutorial, you’ll understand that:Loggingin Python can besimple and intuitivewith the right tools.Using Loguru lets youstart logging immediatelywithout complex configuration.You cancustomize log formatsand send logs to multiple destinations like files, the standard error stream, or external services.You can implementautomatic log rotation and retentionpolicies to manage log files effectively.Loguru providespowerful debugging capabilitiesthat make troubleshooting easier.Loguru supportsstructured loggingwith JSON formatting for modern applications.After reading this tutorial, you’ll be able to quickly implement better logging in your Python applications. You’ll spend less time wrestling with logging configuration and more time using logs effectively to debug issues. This will help you build production-ready applications that are easier to troubleshoot when problems occur.To get the most from this tutorial, you should be familiar with Python concepts likefunctions,decorators, andcontext managers. You might also find it helpful to have some experience with Python’s built-inloggingmodule, though this isn’t required.Don’t worry if you’re new to logging in Python. This tutorial will guide you through everything you need to know to get started with Loguru and implement effective logging in your applications.You’ll do parts of the coding for this tutorial in thePython standard REPL, and some other parts withPython scripts. You’ll find full script examples in the materials of this tutorial. You can download these scripts by clicking the link below:Get Your Code:Click here to download the free sample codethat shows you how to use Loguru for simpler Python logging.Take the Quiz:Test your knowledge with our interactive “Python Logging With the Loguru Library” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizPython Logging With the Loguru LibraryThink you know Python logging? Take this quick Loguru quiz to test your knowledge of formatting, sinks, rotation, and more!Installing LoguruLoguruis available onPyPI, and you can install it withpip. Open aterminalor command prompt, create a newvirtual environment, and then install the library:WindowsLinux + macOSWindows PowerShellPS>python-mvenvvenvPS>venv\Scripts\activate(venv)PS>python-mpipinstallloguruShell$python-mvenvvenv/$sourcevenv/bin/activate(venv)$python-mpipinstallloguruThis command will install the latest version of Loguru fromPython Package Index (PyPI)onto your machine.Remove adsVerifying the InstallationTo verify that the installation was successful, start a PythonREPL:Shell(venv)$pythonNext, import Loguru:Python>>>importloguruIf the import runs without error, then you’ve successfully installed Loguru and can now use it to log messages in your Python programs and applications.Understanding Basic Setup ConsiderationsBefore diving into Loguru’s features, there are a few key points to keep in mind:Single Logger Instance: Unlike Python’s built-inloggingmodule, Loguru uses a single logger instance. You don’t need to create multiple loggers, just import the pre-configuredloggerobject:PythonfromloguruimportloggerDefault Configuration: Out of the box, Loguru logs tostderrwith a reasonable default format. This means you can start logging immediately without any setup.Python Version Compatibility: Loguru supports Python 3.5 and above.Now that you understand these basic considerations, you’re ready to start logging with Loguru. In the next section, you’ll learn about basic logging operations and how to customize them to suit your needs.Learning the Fundamentals of Logging With LoguruOne of Loguru’s main attractions is its simplicity compared to Python’s built-inloggingmodule. Instead of writing multiple lines of configuration code, you can start logging immediately with a pre-configured logger.This section will cover the fundamentals of using Loguru, from basic logging to more advanced features like custom formatting and log file management. You’ll learn how to implement effective logging with minimal setup while maintaining the flexibility to customize your logging as needed.Getting Started With Zero ConfigurationThe most basic way to use Loguru is through its pre-configuredloggerobject. Unlike Python’s built-inloggingmodule, which requires explicit configuration before use, Loguru comes ready to use right after you import it.You can start logging messages immediately with several logging methods that correspond to different severity levels:Python>>>fromloguruimportlogger>>>logger.debug(""Debug message"")2025-02-01 11:38:50.215 | DEBUG    | __main__:<module>:1 - Debug message>>>logger.info(""Info message"")2025-02-01 11:38:50.216 | INFO     | __main__:<module>:1 - Info message>>>logger.error(""Error message"")2025-02-01 11:38:51.420 | ERROR    | __main__:<module>:1 - Error messageWhen you run this code, you’ll see that each message is automatically formatted with useful information like the timestamp, log level, and the location of the log call:The default output includes color-coded levels when logging to a terminal, making it possible to quickly identify different types of messages. Loguru automatically detects if your terminal supports colors and disables them if it doesn’t.Now it’s time to take a closer look at the first logging message:Log File2025-02-01 11:38:50.215 | DEBUG    | __main__:<module>:1 - Debug messageIn the above message, you have the following information:2025-02-01 11:38:50.215: Timestamp with millisecond precisionDEBUG: Log level indicating message severity__main__: The module name where the log was called<module>: The function or scope—in this case, module level1: Line number in the source codeDebug message: The actual message being loggedEach component is separated by a special character, such as a pipe (|) or a dash (-), for readability, and you can customize this format, as you’ll learn later in this tutorial.Logs are sent to thestandard error stream(stderr), which is the output channel that Loguru uses by default. It’s traditionally used for error messages and diagnostic output, making it ideal for logging since it can be separated from your program’s regular output. You can change this later when you need more complex logging setups. For example, you can send logs to files, network services, or multiple destinations at once.Now that you understand the basics of logging with Loguru, next, you’ll explore how to categorize your messages by importance. Loguru provides several log levels that let you distinguish between different types of information, from detaileddebuggingoutput to critical errors.Remove adsUnderstanding Log LevelsNow that you’re familiar with basic logging, you’ll explore Loguru’s log levels in more detail. Log levels help you categorize messages based on their severity and importance, allowing you to filter and manage your logs effectively.Loguru provides seven built-inlog levels, each with its own method, severity value, and default color scheme:LevelMethodValuePurposeTRACElogger.trace()5Extremely detailed information for debuggingDEBUGlogger.debug()10Information useful during developmentINFOlogger.info()20General information about what’s happening in the codeSUCCESSlogger.success()25Notifications of successful operationsWARNINGlogger.warning()30Warnings about something unexpected but not necessarily problematicERRORlogger.error()40Errors for when something fails but the application continues runningCRITICALlogger.critical()50Critical errors that are serious and urgentBy default, Loguru shows all messages with levelDEBUG(10) and above. This means that when you first start using Loguru, you’ll see most log messages except for the extremely detailedTRACEmessages. This behavior helps keep your logs focused on information that’s most relevant during development while filtering out excessive details. You can see this filtering in action with the following example:Python>>>fromloguruimportlogger>>>logger.trace(""This is a detailed trace message!"")>>>logger.debug(""Debug message!"")2025-02-02 11:37:39.443 | DEBUG    | __main__:<module>:1 - Debug message!>>>logger.success(""Success message!"")2025-02-02 11:37:39.444 | SUCCESS  | __main__:<module>:1 - Success message!>>>logger.critical(""Critical error has occurred!"")2025-02-02 11:37:39.626 | CRITICAL | __main__:<module>:1 - Critical error has occurred!You’ll notice that theTRACEmessage doesn’t appear in the output, while all other levels are displayed with their appropriate formatting and colors:The reasonTRACEdoesn’t appear in the output is because theTRACElevel is below Loguru’s default minimum level ofDEBUG.To enableTRACElevel messages, you can adjust the minimum level using thelogger.add()method:Python>>>importsys>>>fromloguruimportlogger>>>logger.add(sys.stderr,level=""TRACE"")1>>>logger.trace(""Will this be visible?"")2025-02-03 10:24:31.720 | TRACE    | __main__:<module>:1 - Will this be visible?>>>logger.debug(""A debug message"")2025-02-03 10:24:31.721 | DEBUG    | __main__:<module>:1 - A debug message2025-02-03 10:24:31.721 | DEBUG    | __main__:<module>:1 - A debug message>>>logger.info(""An info message"")2025-02-03 10:24:31.841 | INFO     | __main__:<module>:1 - An info message2025-02-03 10:24:31.841 | INFO     | __main__:<module>:1 - An info messageIn the code above, you import thesysmodule to access the standard error stream—sys.stderr—which will be used as asinkor output destination for your logs. You then use thelogger.add()method to add a newhandler. Here, you pass itsys.stderrand set itsdefault leveltoTRACEusing thelevelargument.The.add()method returns an integer that uniquely identifies the handler. You can use this identifier to remove the handler later with.remove().While running the code, you may notice something unexpected. TheDEBUGandINFOlog messages appear twice. This happens because Loguru now has two handlers: the default one at theDEBUGlevel, and your new one at theTRACElevel. To fix this, you need to remove the default handler first:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(sys.stderr,level=""TRACE"")1>>>logger.trace(""This WILL be visible"")2025-02-03 10:25:38.508 | TRACE    | __main__:<module>:1 - This WILL be visible>>>logger.debug(""Now this appears exactly once"")2025-02-03 10:25:38.509 | DEBUG    | __main__:<module>:1 - Now this appears exactly once>>>logger.info(""As does this info message"")2025-02-03 10:25:38.669 | INFO     | __main__:<module>:1 - As does this info messageThelogger.remove()method, when called without an argument, effectively removes all existing handlers, including the default one, allowing you to start with a clean slate before adding your new handler.Note:To remove only the default handler, you can pass0tologger.remove(). Loguru always assigns the identifier0to the default handler, sologger.remove(0)will remove it. For any other handlers, you would pass the identifier that was returned when you added the handler. Your code will now behave as expected.Understanding the log levels helps you implement appropriate logging strategies for different environments. For example, you might use theDEBUGlevel in development but onlyWARNINGand above in production. Next, you’ll look at how to customize the format and filtering of your log messages to make them even more useful.Customizing LogsWhile Loguru’s default configuration is useful out of the box, you’ll often want to customize how your logs look and which messages get logged. Loguru makes this customization straightforward through the.add()method with aformatparameter.Start with a format that includes just the essential log message without any additional metadata or formatting:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(sys.stderr,format=""{message}"")1>>>logger.info(""A minimal log message"")A minimal log messageHere, you use the{message}placeholder to display just the log message with no other information.When you run this code, you’ll see a clean, minimalist output with only the message content. There are no timestamps, log levels, or source information. This bare-bones approach might be useful for very specific use cases where you need logs to be as concise as possible:Log FileA minimal log messageTheformatstring supports severalplaceholdersthat get replaced with actual values:{time}: Timestamp{level}: Log level{message}: The actual log message{name}: Module name{line}: Line numberFor better context, and better troubleshooting and log analysis, you’ll typically want to include at least a timestamp and log level in your format string:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(...sys.stderr,...format=""{time:YYYY-MM-DD HH:mm:ss} |{level}|{message}""...)1>>>logger.info(""A more informative log message"")2025-02-03 10:26:27 | INFO | A more informative log messageThis format combines the{time}placeholder with a custom date format, the{level}placeholder to indicate severity, and the{message}placeholder for your actual log content. The pipe characters (|) create visual separation between the components, making logs easier to scan when troubleshooting issues.Notice that thetimeplaceholder is further customized by passing a format string (YYYY-MM-DD HH:mm:ss) to show the full date and time in a readable format.To help with debugging, you might want to include themodule nameandline numberto see exactly where a log message originated:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(...sys.stderr,...format=""[{time:HH:mm:ss}] >>{name}:{line}>>{level}:{message}""...)1>>>logger.info(""Database connection established"")[14:02:51] >> __main__:1 >> INFO: Database connection establishedIn this example, theformatstring creates a detailed log structure that’s extremely useful for debugging. Each component serves a specific purpose in helping you pinpoint exactly where and when each log was generated. Here’s a breakdown of the elements in this custom format:[{time:HH:mm:ss}]: Time in brackets, showing hours, minutes, and seconds{name}: The module name{line}: The line number where the logging call was made{level}: The severity level of the log message{message}: The actual log message>>: Custom separators between elements for better readabilityFor a complete list of available formatting placeholders, refer to the Loguru documentation on therecord dict attributes.Loguru also supportscolor markupin your format strings. You can use tags like<red>,<green>,<blue>, and others, and they’ll automatically be converted into terminal colors:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(...sys.stderr,...format=(...""[<red>{time:HH:mm:ss}</red>] >> ""...""<yellow>{level}</yellow>: ""...""<cyan>{message}</cyan>""...)...)1>>>logger.info(""Database connection established"")[14:02:57] >> INFO: Database connection establishedIn this example, theformatstring uses color markup tags to highlight different parts of the log message. The timestamp appears in red, the log level in yellow, and the message is in cyan. The format string is broken into multiple lines for readability, but it’s treated as a single continuous string.The result will be similar to the following image, although your colors may vary depending on your terminal and theme:The colors are automatically disabled if the output doesn’t support them, such as when logging to a file.Remove adsAdding Context to LogsOften, you’ll want to include extracontextin your log messages to help you better understand what was happening when the log was created. Loguru provides several ways to add this context. The simplest approach is to passkeyword argumentsdirectly to your logging methods:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(...sys.stderr,...format=""{time}|{level}|{message}|{extra}""...)1>>>logger.info(""User logged in"",user_id=123)2025-02-03T10:27:43.451744+0000 | INFO | User logged in | {'user_id': 123}Here, you pass a keyword argumentuser_id=123tologger.info()to add extra context. This approach is perfect for one-off contextual information that you only need for a specific log entry. The context is automatically added to theextradictionary.For context that needs to persist across multiple log entries, Loguru provides two powerful methods:.bind(): Creates a new logger with permanent context for all logs.contextualize(): Temporarily adds context within a code block using a context managerThe.bind()method is useful when you want to attach persistent information to every log message from a specific logger instance, such as user IDs, session IDs, or server information. This saves you from manually including this information in each log message and ensures consistency across all logs from that particular logger:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(sys.stderr,format=""{time}|{level}|{message}|{extra}"")1>>>user_logger=logger.bind(user_id=123)>>>user_logger.info(""User logged in"")2025-02-03T10:28:10.288620+0000 | INFO | User logged in | {'user_id': 123}>>>user_logger.info(""User started a session"")2025-02-03T10:28:11.397293+0000 | INFO | User started a session | {'user_id': 123}In this example, you first configure your logger to display any extra fields by including{extra}in the format string. Then you create a new logger instance calleduser_loggerusing.bind(), which attaches auser_idto all its messages.Every log message fromuser_loggerwill automatically include this user ID in its extra fields, which helps trace all actions performed by this user.When you run this code, each log message includes the bound context in its output—you don’t need to specify it each time. However, this context is permanent, which isn’t always ideal. Sometimes, you only need to add context that’s relevant to a specific operation or section of code, like a request ID during an API call or a transaction ID in a database operation. That’s where.contextualize()comes in!The.contextualize()method provides a clean way to add temporary context that automatically gets cleaned up once you’re done with that operation:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(sys.stderr,format=""{time}|{level}|{message}|{extra}"")1>>>withlogger.contextualize(request_id=""abc789""):...logger.info(""Processing request"")...logger.info(""Request completed"")...2025-02-03T10:28:30.942510+0000 | INFO | Processing request | {'request_id': 'abc789'}2025-02-03T10:28:30.943087+0000 | INFO | Request completed | {'request_id': 'abc789'}>>>logger.info(""Request is processed, this will not show extra context"")2025-02-03T10:28:31.026640+0000 | INFO | Request is processed, this will not show extra context | {}In this example, the.contextualize()method acts as a Pythoncontext managerthat temporarily adds arequest_idto the logs. Inside thewithblock, all log messages automatically include this ID, but once you exit the block, the context is removed. This is very useful when handlingweb requestsordatabasetransactions where you want to group all logs related to a single operation.Unlike.bind(), which creates a new logger instance,.contextualize()modifies the global logger’s context temporarily and then restores it to its previous state.When working with larger applications, you often need both permanent identifiers—like user IDs—and temporary ones, such as request or transaction IDs. By combining.bind()and.contextualize(), you can build a complete picture of what’s happening in your application:Python>>>importsys>>>fromloguruimportlogger>>>logger.remove()>>>logger.add(sys.stderr,format=""{time}|{level}|{message}|{extra}"")1>>>user_logger=logger.bind(user_id=123)>>>withuser_logger.contextualize(request_id=""abc789""):...user_logger.info(""Processing user request"")...2025-02-03T10:28:51.430919+0000 | INFO | Processing user request | {'request_id': 'abc789', 'user_id': 123}>>>user_logger.info(""Another user action unrelated to previous request"")2025-02-03T10:28:51.556306+0000 | INFO | Another user action unrelated to previous request | {'user_id': 123}This code demonstrates a permanently bounduser_idthat tracks all actions for a specific user, a temporaryrequest_idfor the duration of a single operation, and merged contexts in the output where both IDs appear ({'request_id': 'abc789', 'user_id': 123}).This pattern is a great way to trace operations inweb applicationswhere you track both the user making requests and individual request operations.The key difference between.bind()and.contextualize()is that.bind()creates a new logger instance with permanent context, while.contextualize()temporarily adds context within a specific block of code. You can combine them when you need both permanent and temporary context.Now that you understand how to enrich your logs with context data, you’ll take a look at the technical challenge oflog storageand management. This becomes important when your application runs for a long time and generates large amounts of log data. In the next section, you’ll explore how to save your logs to files and use Loguru’s powerfulrotationandretentionfeatures to keep them organized and manageable.Remove adsLogging to Files Using LoguruWhile logging to the console is useful during development, in production, you’ll typically want to write logs to files. Loguru enables setting up file logging with advanced features like log rotation and retention policies.Before you take a look at example implementations, you’ll need to understand the two main management policies that Loguru provides for neatly organizing your log files:Log rotation:Determines when to start a new log file, based on file size, time intervals, or other conditions.Log retention:Controls how long to keep old log files before deleting them, based on file count or age.For a bare-bones example of file logging without these policies, start with the basics. First, use a simple log file:Python>>>fromloguruimportlogger>>>logger.add(""app.log"")1>>>logger.info(""This message goes to app.log"")2025-02-03 10:53:29.498 | INFO     | __main__:<module>:1 - This message goes to app.logHere, you call the logger’s.add()method to specify a log message destination, known as asink. By passing the string""app.log""as the sink, you direct log messages to be written to this file. With this, in addition to logging to the console, a new file calledapp.logwill also be created if it doesn’t exist, or be appended to if it does.Loguru intelligently handles different sink types so that logs are sent to the correct destination based on the value you pass to.add().Theapp.logis a basic text file that you can open in any text editor:Textapp.log2025-02-03 10:53:29.498 | INFO     | __main__:<module>:1 - This message goes to app.logYou’ll notice that this basic setup, while simple, has some limitations: the file will grow indefinitely as your application runs. Log rotation, which automatically creates new log files based on size or time conditions, solves this problem by preventing any single file from becoming too large.As your application runs, you can control when new log files are created using rotation:Python>>>fromloguruimportlogger>>>logger.add(""app.log"",rotation=""4 KB"")1>>>foriinrange(100):...logger.info(f""Processing item #{i}"")...2025-02-03 10:54:34.971 | INFO     | __main__:<module>:2 - Processing item #02025-02-03 10:54:34.972 | INFO     | __main__:<module>:2 - Processing item #1(...)In this example, you write multiple log messages in a loop to demonstrate rotation in action. When the log file reaches four kilobytes in size, Loguru automatically renames the current log file to include a timestamp, such asapp.2025-02-03_10-54-34_188928.log. Then, it creates a freshapp.logfile and continues writing new messages to it.This continues as your application runs, and a new file is created each time the size limit is reached. The latest logs are always saved toapp.log. The same principle applies when usingtime-based rotationinstead ofsize-based rotation. For example, if you setrotationto""00:00"", the current file would be renamed exactly at midnight, and a new one will be immediately started.Therotationparameter defines when to start a new log file. It accepts several different types of arguments:Size-based:Creates a new file when size reaches a limit (""100 MB"",""2 GB"").Time-based:Creates a new file at specific times (""00:00""for daily).Interval-based:Creates a new file after set durations (""12 hours"",""3 days"").But what happens to these rotated files? By default, they accumulate indefinitely, which consumes disk space. Loguru’sretentionfeature helps manage this by automatically cleaning up old log files:Python>>>importtime>>>fromloguruimportlogger>>>logger.add(""app.log"",rotation=""5 seconds"",retention=""1 minute"")1>>>foriinrange(100):...logger.info(f""Processing item #{i}"")...time.sleep(2)...2025-02-03 10:55:49.298 | INFO     | __main__:<module>:2 - Processing item #02025-02-03 10:55:51.309 | INFO     | __main__:<module>:2 - Processing item #1(...)In the.add()example above, you configure the logger to rotate log files every5seconds and keep them for only1minute, then simulate a logging workload. The code does a few things:Sets up anapp.logfile sink with rotation every5seconds and retention for1minute. These two parameters are for demonstration only, and realistically, the durations will be way longer.Inside aforloop, a message is logged, then the program waits for2seconds using thetime.sleep()function from thetimemodule.Logging continues for 100 iterations, creating multiple rotated log files.Old log files are deleted after they exceed the1-minute retention period.This creates a rolling window of log files, where new logs continue to be written while expired files older than1minute are removed.Theretentionparameter can be eithercount-basedortime-based:Count-based: Keeps only theNmost recent files. For example,retention=3keeps only the three newest log files and deletes older ones.Time-based: Removes files older than the specified duration. For example,retention=""1 week""automatically deletes any log files older than one week.Now that you have a good understanding of basic logging, formatting, contextual data, and log file management, you know how to create a great logging system. However, when things go wrong in your application, you need more than just log messages—you need detailed error information that helps you track down and fix problems quickly.
In the next section, you’ll look at how to enhance your error handling with Loguru’s powerful debugging features.Remove adsError Handling and Debugging With LoguruWhen you’re debugging applications, just knowing an error occurred from log messages isn’t enough. You need to understand exactly what happened and why. Loguru provides powerful error-handling features that give you detailed error information, complete with variable values and execution context. In this section, you’ll learn how to capture and debug errors effectively using Loguru’s built-in features.Using the@logger.catchDecoratorThe simplest way to catch and log errors is with Loguru’s@logger.catchdecorator. It’s especially useful when you want to ensure that any errors in your application are automatically logged as they occur:Pythoncatch_and_log_errors.pyfromloguruimportlogger@logger.catchdefdivide(a,b):returna/bdivide(10,0)In this example, you use the@logger.catchdecorator to automatically catch and log any exceptions that occur individe(). As you can see, there’s a division by zero in thedivide(10, 0)call, which will raise aZeroDivisionErrorexception.To see how this works, you can execute this script in your terminal:Shell(venv)$pythoncatch_and_log_errors.pyLoguru provides more detailed information in its log to ensure thorough traceability for debugging with a full traceback, including variable values at the moment the error occurred:Shell2025-02-03 13:48:38.008 | ERROR    | __main__:<module>:7 - An error has been caught in function '<module>', process 'MainProcess' (9562), thread 'MainThread' (127338692705152):Traceback (most recent call last):> File ""/home/user/catch_and_log_errors.py"", line 7, in <module>divide(10, 0)└ <function divide at 0x73d058a1cd60>File ""/home/user/catch_and_log_errors.py"", line 5, in dividereturn a / b│   └ 0└ 10ZeroDivisionError: division by zeroIn this output, the@logger.catchdecorator automatically captures theZeroDivisionErrorerror, logs it with a traceback, and provides useful context. This includes the timestamp of the error,processandthreadinformation, atracebackshowing exactly where the error happened—along with variable values—and the actual error message and type.This automatic error catching is particularly useful during development as it ensures no exceptions go unnoticed. The decorator can be applied to any function where you want comprehensive error logging.Using Improved Tracebacks With Customized Error MessagesUsing the basic@logger.catchdecorator is a good idea because it requires zero configuration and catches all exceptions automatically. However, in larger applications, you often need more control over how errors are logged and handled.  You might want to customize the error message, set specific log levels, or handle certain types of errors differently. To solve this, you can customize the@logger.catchdecorator with additional parameters:Pythoncustomized_log_errors.pyfromloguruimportlogger@logger.catch(message=""Database connection failed"",level=""ERROR"")defconnect_to_db(host,port):ifport<1000:raiseValueError(""Invalid port number"")# Simulated database connectionreturn1/0# Simulate errorconnect_to_db(""localhost"",123)In this example, you’re simulating a database connection. The@logger.catchdecorator takes two important arguments: a custommessagethat provides context about what failed, and alevelparameter that ensures the error is logged with the appropriate severity.Theconnect_to_db()function has two parameters: thehostaddress andportnumber. It includes a basic validation check that raises aValueErrorif someone tries to use a port number below1000. After this check, it simulates a database connection failure using a division by zero operation.Run the script in your terminal to see it in action:Shell(venv)$pythoncustomized_log_errors.pyYou’ll get output that shows the log message, the exception that was raised, and the full context of the operation:Shell2025-02-03 13:50:53.549 | ERROR    | __main__:<module>:10 - Database connection failedTraceback (most recent call last):> File ""/home/user/customized_log_errors.py"", line 10, in <module>connect_to_db(""localhost"", 123)└ <function connect_to_db at 0x7c509a377a60>File ""/home/user/customized_log_errors.py"", line 6, in connect_to_dbraise ValueError(""Invalid port number"")ValueError: Invalid port numberHere, the customized log message appears on the first line. During theconnect_to_db(""localhost"", 123)call, the port number123fails the validation check, raisingValueError. The@logger.catchdecorator intercepts this error, wraps it with your custom message, and logs it at theERRORlevel, all while preserving the full context of what went wrong.This pattern is really useful in production applications where you need to quickly identify and diagnose issues. Instead of generic error messages, you get contextual information that helps you understand exactly what part of your application failed and why. For even more context, you can use the contextualization helpers you explored earlier. You’ll take a closer look at it in the next section.Remove adsDebugging With Contextualized ErrorsIn certain scenarios, you’ll likely need to understand not just where an error occurred, but also the state of your application when it happened. To achieve this, you can combine error handling and contextual information with the help of the.contextualize()context manager you saw earlier. Here’s an example of how you can use it to create highly informative debug logs:Pythondebug_with_context.py1importsys2fromloguruimportlogger34logger.remove()5logger.add(6sys.stderr,7format=""{time}|{level}|{message}|{extra}"",8level=""TRACE""9)1011@logger.catch12defperform_action(user,action):13withlogger.contextualize(user=user,action=action):14logger.trace(""Starting action"")15logger.info(""Performing action"")16ifactionnotin[""login"",""logout""]:17logger.trace(""Invalid action detected"")18raiseValueError(""Invalid action"")19logger.success(""Action completed"")2021perform_action(""alice"",""delete"")In the example above, you have a combination of contextualized logging and error handling that provides a complete picture of what happened before, during, and after an error occurs. Here’s a breakdown of how it works:Lines 1 and 2: Import thesysmodule and theloggerobject.Lines 4 to 9: Remove the default handler and add a custom one that shows context information ({extra}) and sets the minimum level to""TRACE""to capture all log messages.Lines 11 to 19: Define theperform_action()function that takes auserandactionparameters, then uses contextualization to attach this information to all logs within its scope.Line 21: Calls the function with parameters that trigger the error condition.Now run thisdebug_with_context.pyscript in your terminal to see all the logs and traceback that will be produced:Shell(venv)$pythondebug_with_context.pyYou’ll see a full sequence of log levels that tells a story:Shell2025-02-04T11:26:24.042435+0100 | TRACE | Starting action | {'user': 'alice', 'action': 'delete'}2025-02-04T11:26:24.042639+0100 | INFO | Performing action | {'user': 'alice', 'action': 'delete'}2025-02-04T11:26:24.042761+0100 | TRACE | Invalid action detected | {'user': 'alice', 'action': 'delete'}2025-02-04T11:26:24.042891+0100 | ERROR | An error has been caught in function '<module>', process 'MainProcess' (8238), thread 'MainThread' (128347999026048): | {}Traceback (most recent call last):> File ""/home/user/debug_with_context.py"", line 21, in <module>perform_action(""alice"", ""delete"")└ <function perform_action at 0x74bb575837e0>File ""/home/user/debug_with_context.py"", line 18, in perform_actionraise ValueError(""Invalid action"")ValueError: Invalid actionIn this sequence,.trace()logs the very beginning of the operation, then.info()indicates the main action being attempted. Another.trace()captures the moment right before the error. Finally, an error is caught by@logger.catchto indicate an invalid action.When you callperform_action(""alice"", ""delete""), the function fails because""delete""isn’t an allowed action. However, because of the tracing and context, you get a complete log of what happened:Whotried to perform the action:aliceWhatthey tried to do:deleteEach stepthat executed before the failureThe exact pointwhere the validation failedThis combination of contextual logging and error handling is great for debugging complex applications where you need to understand the sequence of events that led to an error.Note:Now you have solid understanding of how to handle errors and troubleshoot your Python programs! For even more advanced debugging capabilities, you may want to explore interactive debugging tools like Python’s built-in debugger,pdb. Check outPython Debugging With Pdbto learn how to inspect code and find bugs in real time.There’s one last thing to consider. As your application grows and your logging needs become more complex, it’s important to make your logs more accessible to automated analysis tools and logging aggregators. Structured logging formats likeJSONcan help you achieve this goal. In the next section, you’ll look at how to format your logs as structured data that’s both machine-readable and human-friendly.Structured Logging for Modern ApplicationsStructured logging helps you organize your log data in a consistent, machine-readable format while keeping it human-readable. Loguru provides two main approaches to structured logging:Serializing your entire log output as JSONSelectively adding structured data using extra fieldsIn this section, you’ll learn how to use both methods to create well-organized logs that work perfectly with logging tools and aggregators.Formatting Logs as JSONWhen you need your logs in a structured format, Loguru allows you to output them as JSON. This is particularly useful when you’re working with log analysis tools, or when you need to process your logs programmatically.To get a first impression of how JSON formatting works in logs, add aserializeparameter to the.add()method:Pythonloguru_json_format.pyimportsysfromloguruimportloggerlogger.remove()logger.add(sys.stderr,serialize=True)logger.info(""User logged in"",user_id=123)Here, you first remove the default handler and add one with JSON serialization by passingserialize=Trueto the.add()method. Theserializeparameter tells Loguru to convert each log message into a structured JSON object instead of the default text format. Notice that you can still pass additional contextual data, likeuser_id, as keyword arguments to the logging call, and Loguru will automatically include them in the JSON output’sextrafield.You can now run this script to generate a JSON object for each log message:Shell(venv)$pythonloguru_json_format.pyInstead of Loguru’s default formatted output that you’ve seen before, you’ll get a JSON object for each log message:JSON{""text"":""2025-02-04 15:19:00.504 | INFO | __main__:<module>:1 - User logged in\n"",""record"":{""elapsed"":{""repr"":""0:00:00.022562"",""seconds"":0.022562},""exception"":null,""extra"":{""user_id"":123},""file"":{""name"":""<stdin>"",""path"":""<stdin>""},""function"":""<module>"",""level"":{""icon"":""ℹ️"",""name"":""INFO"",""no"":20},""line"":1,""message"":""User logged in"",""module"":""<stdin>"",""name"":""__main__"",""process"":{""id"":13745,""name"":""MainProcess""},""thread"":{""id"":140715465190272,""name"":""MainThread""},""time"":{""repr"":""2025-02-04 15:19:00.504204+01:00"",""timestamp"":1738678740.504204}}}The JSON output includes all the information about your log message in a structured format, with the original formatted text in thetextfield and the structured data in therecordfield. Any contextual data passed as keyword arguments to the logger, such asuser_id=123, appears in theextrafield of the record.Of course, you can use a file as an output for your logs, just like you did previously. This time, the log file will be filled with one JSON object per line, so you can process it with standard JSON parsing tools, such asjq:Pythonloguru_json_file.pyfromloguruimportloggerlogger.remove()logger.add(""app.json"",serialize=True,format=""{time}|{level}|{message}"")logger.info(""Application started"")logger.warning(""Memory usage high"")Here, you configure Loguru to write serialized logs to a file namedapp.jsoninstead ofstderr, just as you did in theLogging to Files Using Logurusection. Theserialize=Trueparameter sets up JSON formatting, while theformatparameter defines how the text portion of each log entry will appear.When you run this script, a newapp.jsonwill be created if it doesn’t exist, or be appended to if it does:Shell(venv)$pythonloguru_json_file.pyEach logging call will create a new JSON object in the file in each new line. This newapp.jsonfile will have all the log data you’d expect, and will be structured and optimized for log analysis tools and APIs:JSONapp.json1{""text"":""2025-02-04T15:28:36.583972+0100 | INFO | Application started\n"",""record"":{""elapsed"":{""repr"":""0:00:00.027052"",""seconds"":0.027052},""exception"":null,""extra"":{},""file"":{""name"":""<stdin>"",""path"":""<stdin>""},""function"":""<module>"",""level"":{""icon"":""ℹ️"",""name"":""INFO"",""no"":20},""line"":1,""message"":""Application started"",""module"":""<stdin>"",""name"":""__main__"",""process"":{""id"":14132,""name"":""MainProcess""},""thread"":{""id"":129594171026304,""name"":""MainThread""},""time"":{""repr"":""2025-02-04 15:28:36.583972+01:00"",""timestamp"":1738679316.583972}}}2{""text"":""2025-02-04T15:28:37.063342+0100 | WARNING | Memory usage high\n"",""record"":{""elapsed"":{""repr"":""0:00:00.506422"",""seconds"":0.506422},""exception"":null,""extra"":{},""file"":{""name"":""<stdin>"",""path"":""<stdin>""},""function"":""<module>"",""level"":{""icon"":""⚠️"",""name"":""WARNING"",""no"":30},""line"":1,""message"":""Memory usage high"",""module"":""<stdin>"",""name"":""__main__"",""process"":{""id"":14132,""name"":""MainProcess""},""thread"":{""id"":129594171026304,""name"":""MainThread""},""time"":{""repr"":""2025-02-04 15:28:37.063342+01:00"",""timestamp"":1738679317.063342}}}In theapp.jsonfile, each line is a complete JSON object, one for each log message. Each object contains the formatted message text and a detailed record of information about when and where the log was created. The two log entries maintain their different severity levels—INFOandWARNING—and include identical structure but different content and timestamps.Note:The resultingapp.jsonfile isn’t a single JSON document but rather a series of JSON objects, one per line. This format is known asJSON Lines(or JSONL). It’s commonly used for log files because it allows you to append new log entries and helps with stream processing of the file.This standard format works well for many logging scenarios, but it can be quite verbose when you’re working with high-volume applications. For large-scale systems, you might need a more concise format that focuses only on the most relevant information. Fortunately, Loguru gives you the flexibility to customize your JSON output with exactly the fields you need.Remove adsCreating Custom JSON FormatsLoguru’s built-in JSON serialization is powerful, but it produces verbose output with more information than you might need. When working with log analysis tools likeLogstashorGrafana Loki, you’ll often want concise, focused log entries that contain only essential data.The good news is that Loguru allows you to create custom serialization functions, which will simplify the default JSON structure, and you can precisely control which fields appear in your logs. This leads to more readable output, optimized storage usage, and better integration with external analysis tools:Pythoncustom_json_logging.py1importjson2fromloguruimportlogger34defsimple_serializer(record):5subset={6""time"":record[""time""].timestamp(),7""level"":record[""level""].name,8""message"":record[""message""],9""context"":record[""extra""]# Include any bound context10}11returnjson.dumps(subset)1213defadd_serialization(record):14record[""extra""][""json_output""]=simple_serializer(record)1516logger.remove()17logger=logger.patch(add_serialization)18logger.add(""custom.json"",format=""{extra[json_output]}"")19logger.bind(user=""john"").info(""User logged in"")20logger.bind(order_id=12345).info(""Order processed"")This example solves the verbosity problem by creating a custom serialization function that includes only the fields you actually need. Here’s how it works:Lines 1 and 2: Import thejsonmodule and theloggerobject.Lines 4 to 11: Define thesimple_serializer()function that extracts only four essential fields from the log record: timestamp, level name, message text, and contextual data fromextra. It then converts this subset to a compact JSON string usingjson.dumps().Lines 13 and 14: Create theadd_serialization()function that will be applied to each log record. This function callssimple_serializer()and stores the resulting JSON in the record’sextradictionary under the""json_output""key.Line 16: Removes all default handlers withlogger.remove()to start with a clean configuration.Line 17: Patches theloggerwith theadd_serialization()function using.patch(), which ensures every future log record is processed by this function.Line 18: Adds a file handler that writes tocustom.jsonand usesformat=""{extra[json_output]}""to output only the customized JSON.Lines 19 and 20: Demonstrate logging with different contextual data using.bind(). Each log call produces a compact, focused JSON entry with the user’s context included.You can run this script to see it in action. A newcustom.jsonfile will be created and contain the compact JSON you’ve defined, in addition to the right context:Shell(venv)$pythoncustom_json_logging.pyWhen you run this code, the producedcustom.jsonfile will contain clean, concise JSON entries that focus only on the essential information you need for log analysis:JSONcustom.json{""time"":1740220156.181082,""level"":""INFO"",""message"":""User logged in"",""context"":{""user"":""john""}}{""time"":1740220156.181273,""level"":""INFO"",""message"":""Order processed"",""context"":{""order_id"":12345}}Each line contains a complete JSON object with timestamp, log level, message text, and contextual data in a format that’s both human-readable and easily programmatically parsable by machines.Using.patch()instead of theserializeparameter has several advantages:It gives you more control over how records are processed.It lets you modify records in place before they reach any handlers.It allows for more complex transformations beyond basic serialization.It works consistently across multiple handlers.This makes.patch()a handy way to customize log serialization in production applications where you need fine-grained control over your log output format.Note:Theformat=""{extra[json_output]}""directive is very important because it tells Loguru to use only your custom-serialized JSON string as the output, rather than applying any additional formatting. Without this specific format string, Loguru would apply its default formatting to your already-serialized JSON, potentially causing format issues or duplicate content.This approach gives you complete control over your log format while maintaining the convenience of structured logging. You can, of course, customize thesimple_serializer()function to include any additional fields that are important for your specific application or logging requirements.ConclusionIn this tutorial, you’ve learned how Loguru can transform Python logging from a complex configuration challenge into a simple and powerful tool for your applications. By now, you should have a solid understanding of how to use Loguru for everything from basic logging to advanced error handling and structured data output.In this tutorial, you’ve learned how to:Start logging immediatelywith Loguru’s pre-configured loggerCustomize log formatsto show exactly the information you needManage log fileswith rotation and retention policiesDebug errors effectivelywith detailed tracebacks and variable inspectionAdd contextto your logs for better traceabilityImplement structured loggingwith JSON formatting for modern applicationsThese skills will help you build more robust, maintainable applications with logs that provide real value for debugging and monitoring.Remove adsNext StepsNow that you’ve mastered the basics, consider exploring these advanced topics:Integration with web frameworkslikeFastAPI,Flask, orDjango.Log aggregationwith tools like Logstash or Grafana Loki.Performance optimizationfor high-volume logging.Security considerationsin logging sensitive data.Loguru’s simplicity and flexibility make it an excellent choice for both small scripts and large applications. By applying the techniques you’ve learned in this tutorial, you’ll be well-equipped to implement effective logging strategies in your Python projects.Get Your Code:Click here to download the free sample codethat shows you how to use Loguru for simpler Python logging.Frequently Asked QuestionsHow does Loguru compare to Python's built-inloggingmodule?Show/HideLoguru provides a simpler, more intuitive interface compared to Python’s built-inloggingmodule. While the standard library’s logging requires explicit configuration of handlers, formatters, and log levels, Loguru comes pre-configured and ready to use. It offers powerful features like automatic module detection, colored output, and structured logging with minimal setup.Can I use Loguru in production applications?Show/HideYes, Loguru is production-ready and used in many real-world applications. It’s thread-safe, provides robust error handling, and includes features specifically designed for production environments. You can configure Loguru to work with popular monitoring tools, and it handles high-volume logging efficiently. Just remember to disable thediagnoseoption in production to avoid exposing sensitive information in error tracebacks.How do I migrate from Python'sloggingmodule to Loguru?Show/HideMigrating from Python’s built-inloggingmodule to Loguru is straightforward. Instead of manually configuring handlers, formatters, and filters, simply import Loguru’s logger and start logging immediately. Theofficial migration guideexplains everything from log configuration with Loguru’s single-calladd()method, adjusting format strings, and binding contextual data.How can I use Loguru with pytest?Show/HideUsing Loguru withpytestis possible through log capture libraries such aslogot. This high-level log testing tool integrates well with Loguru. You can configurepytestto capture logs by setting thelogot_captureroption in yourpytestconfiguration. For detailed instructions and code examples, check out theLoguru documentation.Take the Quiz:Test your knowledge with our interactive “Python Logging With the Loguru Library” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizPython Logging With the Loguru LibraryThink you know Python logging? Take this quick Loguru quiz to test your knowledge of formatting, sinks, rotation, and more!Mark as CompletedShare"
Using the Python subprocess Module,https://realpython.com/courses/python-subprocess-module/,"May 06, 2025",40m,intermediate,"Python’ssubprocessmodule allows you to run shell commands and manage external processes directly from your Python code. By usingsubprocess, you can execute shell commands likelsordir, launch applications, and handle both input and output streams. This module provides tools for error handling and process communication, making it a flexible choice for integrating command-line operations into your Python projects.By the end of this video course, you’ll understand that:The Pythonsubprocessmodule is used torun shell commandsand manage external processes.You run a shell command usingsubprocessbycallingsubprocess.run()with the command as a list of arguments.subprocess.call(),subprocess.run(), andsubprocess.Popen()differ inhow they execute commandsand handle process output and return codes.multiprocessingis forparallel executionwithin Python, whilesubprocessmanagesexternal processes.To execute multiple commands in sequence usingsubprocess, you can chain them byusing pipes or running them consecutively.What’s Included:14 LessonsVideo Subtitles and Full Transcripts2 Downloadable ResourcesAccompanying Text-Based TutorialQ&A With Python Experts: Ask a QuestionCertificate of CompletionDownloadable Resources:Course Slides (.pdf)Sample Code (.zip)Related Learning Paths:Important Standard Library Modules"
Sets in Python,https://realpython.com/python-sets/,"May 05, 2025",N/A,"basics, python","Table of ContentsGetting Started With Python’s set Data TypeBuilding Sets in PythonCreating Sets Through LiteralsUsing the set() ConstructorUsing Set ComprehensionsPerforming Common Set OperationsUnionIntersectionDifferenceSymmetric DifferenceUsing Augmented Set OperationsAugmented UnionAugmented IntersectionAugmented DifferenceAugmented Symmetric DifferenceComparing SetsSubsetsProper SubsetsSupersetsProper SupersetsDisjoint SetsUsing Other Set MethodsAdding an Element With .add()Removing an Existing Element With .remove()Deleting an Existing or Missing Element With .discard()Removing and Returning an Element With .pop()Removing All Elements With .clear()Creating Shallow Copies of Sets With .copy()Traversing SetsAccessing and Modifying Elements in a LoopProcessing and Removing Elements in a LoopIterating Through a Sorted SetExploring Other Set CapabilitiesFinding the Number of Elements With len()Running Membership Tests on SetsConclusionFrequently Asked QuestionsRemove adsWatch NowThis tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding:Using Sets in PythonPython provides a built-insetdata type. It differs from other built-in data types in that it’s an unordered collection of unique elements. It also supports operations that differ from those of other data types. You might recall learning about sets and set theory in math class. Maybe you even remember Venn diagrams:Venn DiagramIn mathematics, the definition of a set can be abstract and difficult to grasp. In practice, you can think of a set as a well-defined collection of unique objects, typically calledelementsormembers. Grouping objects in a set can be pretty helpful in programming. That’s why Python has sets built into the language.By the end of this tutorial, you’ll understand that:Asetis an unordered collection of unique, hashable elements.Theset()constructorworks by converting any iterable into a set, removing duplicate elements in the process.You caninitialize asetusing literals, theset()constructor, or comprehensions.Sets areunorderedbecause they don’t maintain a specific order of elements.Sets are useful when you need to runset operations,remove duplicates, runefficient membership tests, and more.In this tutorial, you’ll dive deep into the features of Python sets and explore topics like set creation and initialization, common set operations, set manipulation, and more.Get Your Code:Click here to download the free sample codethat shows you how to work with sets in Python.Take the Quiz:Test your knowledge with our interactive “Python Sets” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizPython SetsIn this quiz, you'll assess your understanding of Python's built-in set data type. You'll revisit the definition of unordered, unique, hashable collections, how to create and initialize sets, and key set operations.Getting Started With Python’ssetData TypePython’s built-insetdata type is amutableand unordered collection of unique andhashableelements. In this definition, the qualifiers mean the following:Mutable: You can add or remove elements from an existing set.Unordered: A set doesn’t maintain any particular order of its elements.Unique elements: Duplicate elements aren’t allowed.Hashable elements: Each element must have ahash valuethat stays the same for its entire lifetime.As with other mutable data types, you can modify sets by increasing or decreasing theirsizeor number of elements. To this end, sets provide a series of handy methods that allow you to add and remove elements to and from an existing set.The elements of a set must be unique. This feature makes sets especially useful in scenarios where you need to remove duplicate elements from an existingiterable, such as alistortuple:Python>>>numbers=[1,2,2,2,3,4,5,5]>>>set(numbers){1, 2, 3, 4, 5}In practice, removing duplicate items from an iterable might be one of the most useful and commonly used features of sets.Python implements sets ashash tables. A great feature of hash tables is that they make lookup operations almost instantaneous. Because of this, sets are exceptionally efficient in membership operations with theinandnot inoperators.Finally, Python sets support commonset operations, such asunion,intersection,difference,symmetric difference, and others. This feature makes them useful when you need to do some of the following tasks:Find common elementsin two or more setsFind differencesbetween two or more setsCombine multiple setstogether while avoiding duplicatesAs you can see,setis a powerful data type with characteristics that make it useful in many contexts and situations. Throughout the rest of this tutorial, you’ll learn more about the features that make sets a worthwhile addition to your programming toolkit.Remove adsBuilding Sets in PythonTo use a set, you first need to create it. You’ll have different ways to build sets in Python. For example, you can create them using one of the following techniques:SetliteralsTheset()constructorAset comprehensionIn the following sections, you’ll learn how to use the three approaches listed above to create new sets in Python. You’ll start with set literals.Creating Sets Through LiteralsYou can define a new set by providing a comma-separated series of hashable objects within curly braces{}as shown below:Python Syntax{obj_0[,obj_1,...,obj_n]}The portion of this syntax enclosed in square brackets is optional. This means you can build a set with a single item if you remove the code inside the square brackets:Python>>># Single-element set>>>hex_colors={""#33FF57""}>>>hex_colors{'#33FF57'}>>># Multiple-element set>>>hex_colors={...""#33FF57"",# Green...""#3357FF"",# Blue...""#F1C40F"",# Yellow...""#E74C3C"",# Red...}>>>hex_colors{'#F1C40F', '#33FF57', '#E74C3C', '#3357FF'}In the first example, you create a set with a single element representing a color in hexadecimal notation. Later, you define the set with four elements.Note:You can’t use a literal to create an empty set because an empty pair of curly braces creates a dictionary. More about this topic in a moment.When you define a set following the literal syntax, each object becomes a distinct element. This syntax won’tunpackiterable objects. For example, if you use a tuple, then it’ll be added to the set as a tuple rather than a series of elements:Python>>>rgb_colors={...(51,255,87),# Green...(51,87,255),# Blue...(241,196,15),# Yellow...(231,76,60),# Red...}>>>rgb_colors{(51, 255, 87),(241, 196, 15),(51, 87, 255),(231, 76, 60)}In this example, you create a set of colors expressed as three-value tuples that follow theRGBcolor model. Note that the resulting set contains tuples. It doesn’t unpack the tuples’ content.In practice, most sets will contain similar objects—for example, evennumbersor surnames:Python>>>{2,4,6,8,10,8,2}{2, 4, 6, 8, 10}>>>{""Smith"",""McArthur"",""Wilson"",""Johansson"",""Smith""}{'Johansson', 'McArthur', 'Wilson', 'Smith'}Holding objects of homogeneous data type or similar semantics isn’t a requirement for Python sets. Additionally, note how in both examples, the resulting set removed the duplicate. This behavior guarantees that the resulting set contains only unique elements.The elements of a set can be objects of different data types:Python>>>{42,""Hi!"",3.14159,None,""Python""}{None, 42, 3.14159, 'Hi!', 'Python'}In this example, your set contains numbers, strings, and even theNoneobject. Even though sets can store objects of differentdata types, it’s common to have sets of semantically equivalent objects, such as colors, letters, surnames, and so on. This kind of set, in most cases, results in objects of the same data type.It’s also important to remember that set elements must be hashable. For example, you can include a tuple in a set, as you already learned, but you can’t include a list because lists aren’t hashable:Python>>>rgb_colors={...[51,255,87],# Green...[51,87,255],# Blue...[241,196,15],# Yellow...[231,76,60],# Red...}Traceback (most recent call last):...TypeError:unhashable type: 'list'Apart from lists, you can’t usedictionaries,bytearrayobjects, or other sets as the elements of a set. These data types are mutable, and therefore, they can’t be hashable.A special case occurs with tuples. If you have tuples containing hashable values, then you can add those tuples to a set. However, if your tuples contain unhashable values, then you can’t add them to a set:Python>>>students={...(""Jane"",18,[""Math"",""Physics"",""History""]),...(""John"",19,[""English"",""History"",""Philosophy""]),...}Traceback (most recent call last):...TypeError:unhashable type: 'list'In this example, you have tuples holding students’ data. Inside each tuple, you have a list of subjects. Lists are unhashable, so they can’t be added to sets even if they’re contained in a tuple.Remove adsUsing theset()ConstructorYou can also build sets using theset()constructor. When would you use this approach? For example, there’s no literal for creating empty sets because an empty pair of curly braces creates an empty dictionary. If you want to create an empty set, then you have to use the constructor:Python>>>empty=set()>>>emptyset()Calling the set constructor is the most straightforward and readable way to create an empty set. Note that instead of getting an empty pair of curly braces in the output, you getset()to avoid confusion with empty dictionaries.The syntax to build a set using the constructor is shown below:Python Syntaxset([iterable])The argumentiterableis optional and must be an iterable like a list or tuple. For example, the following code builds a set from a list:Python>>>set([1,2,2,3,4,4,5]){1, 2, 3, 4, 5}In this example, you pass a list of numbers toset(). Note how the originally duplicate values are only represented once in the resulting set.Pythonstringsare also iterable, so you can pass a string toset(). This will generate a set of characters in the input string:Python>>>language=""Python"">>>set(language){'y', 'P', 'o', 't', 'n', 'h'}The resulting set of characters is unordered. The original order, as specified in the string, isn’t preserved.There’s a subtle difference between using theset()constructor and the literal syntax. Observe the difference with a quick example:Python>>>set(""Hello!""){'H', 'l', 'e', '!', 'o'}>>>{""Hello!""}{'Hello!'}When you create sets using theset()constructor, the argument must be iterable. The constructor unpacks the iterable and adds its items to the resulting set as individual elements. In contrast, the set literal syntax adds the iterable as a single element to the set. It doesn’t unpack its items.Using Set ComprehensionsAset comprehensionis a concise way to create a set by evaluating an expression over an iterable. It works similarly tolist comprehensionsbut automatically removes duplicates.Here’s the syntax for a set comprehension:Python Syntax{expressionformemberiniterable[ifcondition]}The set comprehension syntax consists of the following key components:Theenclosing brackets({}) define the set comprehension.The comprehensionexpressionprovides an element in each iteration.The currentmemberrepresents the current item or value in the iterable.Theiterablecan be any iterable object, including alist,tuple,set,generator, or similar type.The[if condition]part is an optional conditional that you can use tofilterexisting collections or generate elements conditionally.A set comprehension returns a new set. So, you use them to create, transform, and filter sets, which are essential skills for any Python programmer.Note:To dive deeper into set comprehensions, check out thePython Set Comprehensions: How and When to Use Themtutorial.To illustrate how to use a set comprehension, say that you have a list of usernames initially entered without validation. You need to clean the list by converting all the usernames to lowercase, removing leading and trailing spaces, and removing duplicates. You can do this with a set comprehension:Python>>>usernames=[...""Alice"",..."" bob"",...""ALICE  "",...""Bob"",...""charlie"",...""Charlie"",...""JOHN""...]>>>{name.lower().strip()fornameinusernames}{'bob', 'alice', 'john', 'charlie'}In this example, the set comprehension processes a list of strings. It converts each value into lowercase and removes any leading and trailing spaces. It also eliminates duplicates. This way, you have a new set of clean usernames.Remove adsPerforming Common Set OperationsPython’ssetdata type provides a host of operations that are based on theoperationsdefined for mathematical sets. You can perform most set operations in two different ways:Using an operatorCalling a methodIn the following sections, you’ll explore both approaches and their differences. To kick things off, you’ll start with set union, which is one of the most common operations that you’ll perform on sets.UnionTheunionof two sets returns a new set that contains all unique elements from both sets. You can perform a union using the|operator or the.union()method. Any duplicate elements are automatically removed, so each item appears only once in the result. Union is a great way to keep all the elements without unwanted duplication.The following diagram provides a visual representation of the union operation between setsAandB:Set UnionThe darkest area in the center of the diagram represents the elements that were common toAandBand now are unique in the resulting set.Here’s the syntax for the union operation, using both the operator and the method:Python Syntaxx1|x2[|x3|...|xN]x1.union(x2[,x3,...,xN])In this syntax, the portion between square brackets is optional. The union operator (|) is a binary operator, which means it operates on two operands. The.union()method can take any number of arguments.To illustrate how the union operation works, say that you have the following sets:Python>>>pet_animals={""dog"",""cat"",""hamster"",""parrot""}>>>farm_animals={""cow"",""chicken"",""goat"",""dog"",""cat""}The union ofpet_animalsandfarm_animalsis a new set containing the elements from both initial sets. In the case of having one or more repeated elements, the resulting set will contain only one instance of those elements. In this example,""dog""and""cat""are repeated.Here’s how the union operator works:Python>>>pet_animals|farm_animals{'cow', 'hamster', 'cat', 'dog', 'goat', 'chicken', 'parrot'}>>>farm_animals|pet_animals{'cow', 'hamster', 'cat', 'dog', 'goat', 'chicken', 'parrot'}Note that the resulting sets contain only one instance of""dog""and""cat"". The rest of the elements are also in the result. It’s important to mention that the union operation is commutative, meaning the order of the operands doesn’t affect the outcome.The.union()method works similarly. You’ll invoke the method on one of the sets and pass the other as an argument:Python>>>pet_animals.union(farm_animals){'hamster', 'chicken', 'cow', 'dog', 'parrot', 'cat', 'goat'}>>>farm_animals.union(pet_animals){'hamster', 'chicken', 'cow', 'dog', 'parrot', 'cat', 'goat'}The resulting sets contain the same elements as in the previous example. Of course, they’re not in the same order because sets are unordered data types.In both examples, the operator and method behave identically. However, there’s a subtle difference between them. When you use the|operator, both operands must be sets. The.union()method, on the other hand, can take any iterables as arguments and then perform the union.Observe the difference between these two statements:Python>>>pet_animals|[""cow"",""chicken"",""goat"",""dog"",""cat""]Traceback (most recent call last):...TypeError:unsupported operand type(s) for |: 'set' and 'list'>>>pet_animals.union([""cow"",""chicken"",""goat"",""dog"",""cat""]){'hamster', 'chicken', 'cow', 'dog', 'parrot', 'cat', 'goat'}The first attempt to compute the union ofpet_animalsand the list of farm animals fails because the|operator doesn’t support data types different from sets. The.union()method succeeds because it can handle different iterable types.Note:The behavior of the union operator and method shown in the example above is consistent with the other operators and their corresponding methods.Here’s how you can use the operator and method with multiple sets:Python>>>a={1,2,3,4}>>>b={2,3,4,5}>>>c={3,4,5,6}>>>d={4,5,6,7}>>>a.union(b,c,d){1, 2, 3, 4, 5, 6, 7}>>>a|b|c|d{1, 2, 3, 4, 5, 6, 7}As usual, the resulting set contains all elements that are present in the specified sets without any duplication.Remove adsIntersectionTheintersectionof two sets is a new set containing only the elements common to both sets. You can use the&operator or the.intersection()method to perform an intersection. Intersection is a great way to find shared values between datasets, such as mutual friends, overlapping tags, or common items.The following diagram provides a visual representation of the intersection between setsAandB:Set IntersectionThe green area represents the intersection and holds the elements that are present in bothAandB.Here’s the syntax for the intersection operation, using both the operator and the method:Python Syntaxx1&x2[&x3&...&xN]x1.intersection(x2[,x3,...,xN])Again, the portion in square brackets is optional. The&operator is also binary, so you can use it with two operands. The.intersection()method can take any number of arguments. The operator and the method return a set of elements common to both.Consider the following examples where you use an intersection to find mutual friends:Python>>>john_friends={""Linda"",""Mathew"",""Carlos"",""Laura""}>>>jane_friends={""Alice"",""Bob"",""Laura"",""Mathew""}>>>john_friends&jane_friends{'Laura', 'Mathew'}>>>john_friends.intersection(jane_friends){'Laura', 'Mathew'}In this example, the resulting set contains the people who are both John and Jane’s friends. Isn’t that cool?You can specify multiple sets with the intersection operator and method, just like you can with set union:Python>>>a={1,2,3,4}>>>b={2,3,4,5}>>>c={3,4,5,6}>>>d={4,5,6,7}>>>a&b&c&d{4}>>>a.intersection(b,c,d){4}The resulting set contains only elements that are present in all of the specified sets. In this example, only the number4is present in all sets.Finally, it’s important to mention that if an intersection finds no common elements, you get an empty set:Python>>>x={1,2,3,4}>>>y={5,6,7,8}>>>x&yset()In this example, there are no common elements inxandy, so you get an empty set as a result of the intersection operation.DifferenceThedifferencebetween two sets is a new set containing elements that are in the first set but not in the second. It subtracts one set from another. You can perform a difference using the-operator or the.difference()method. Difference is applicable when you want to identify what’s unique to one dataset compared to another.The following diagram provides a visual representation of the difference between setsAandB:Set DifferenceThe green area represents the elements that only exist inA, which is the result of the difference operation.Here’s the syntax for the difference operation, using both the operator and the method:Python Syntaxx1-x2[-x3-...-xN]x1.difference(x2[,x3,...,xN])Again, the operator works with two sets, and the method can take any number of arguments.For a practical example, say that you have a set of people who have registered for an event and another set of people who actually attended. The difference tells you who didn’t show up:Python>>>registered_users={""Alice"",""Bob"",""Charlie"",""Diana"",""Linda""}>>>checked_in_users={""Alice"",""Charlie"",""Linda""}>>>registered_users-checked_in_users{'Bob', 'Diana'}In this example, the resulting set contains the users who registered but didn’t attend the event. The set difference operation is useful when you have questions like who is missing or what hasn’t been done yet.Note:In the case of set difference, the order of the operands affects the result:Python>>>checked_in_users-registered_usersset()Now, you get an empty set, which demonstrates that the difference operation isn’t commutative.Once again, you can specify more than two sets:Python>>>a={1,2,3,30,300}>>>b={10,20,30,40}>>>c={100,200,300,400}>>>a-b-c{1, 2, 3}>>>a.difference(b,c){1, 2, 3}When you specify multiple sets, the operation is performed from left to right. To better understand this behavior, consider the following diagram:Here,a - bis computed first, resulting in{1, 2, 3, 300}. Then,cis subtracted from the resulting set, leaving{1, 2, 3}.Remove adsSymmetric DifferenceThesymmetric differencebetween two sets is a new set containing all the elements that appear in either set but not both. You can perform a symmetric difference using the^operator or the.symmetric_difference()method. The symmetric difference comes in handy when you need to identify elements that are in exactly one of the two sets.The following diagram gives you a visual representation of the symmetric difference between setsAandB:Set Symmetric DifferenceThe green area represents elements inAbut not inB, and the other way around. The middle area represents the elements present in bothAandB. So, the resulting set contains uncommon or unshared elements.Here’s the syntax for both the operator and method for the symmetric difference operation:Python Syntaxx1^x2[^x3^...^xN]x1.symmetric_difference(x2)The operator works similarly to the other set operators. However, the method behaves differently because it only accepts one argument.Note:The symmetric difference is also known as theexclusive ORbecause it represents elements that appear in either of the two sets, but not in both at the same time.Going back to your event example, say that the event has morning and afternoon sessions, and you want to know the attendees who participated in only one of the sessions. You can do this with the symmetric difference operation:Python>>>morning_attendees={""Alice"",""Charlie"",""Linda"",""John"",""Jane""}>>>afternoon_attendees={""Charlie"",""Linda"",""Bob"",""Jane""}>>>morning_attendees^afternoon_attendees{'John', 'Bob', 'Alice'}>>>morning_attendees.symmetric_difference(afternoon_attendees){'John', 'Bob', 'Alice'}The resulting set contains the attendees who were present in only one session. A closer look at the involved sets will allow you to conclude that Alice and John attended the morning session, while Bob only attended the afternoon session.Note:Unlike the set difference operation, symmetric difference is commutative:Python>>>afternoon_attendees^morning_attendees{'John', 'Bob', 'Alice'}Despite the order of operands, you get the same result.The symmetric difference operator (^) also allows you to process more than two sets:Python>>>a={1,2,3,4,5}>>>b={10,2,3,4,50}>>>c={1,50,100}>>>a^b^c{100, 5, 10}As with the difference operator (-), when you specify multiple sets, the operation is performed from left to right.Curiously, the.symmetric_difference()method doesn’t support multiple arguments:Python>>>a={1,2,3,4,5}>>>b={10,2,3,4,50}>>>c={1,50,100}>>>a.symmetric_difference(b,c)Traceback (most recent call last):...TypeError:symmetric_difference() takes exactly one argument (2 given)If you try to call.symmetric_difference()with more than one argument, then you get aTypeErrorexception. You can work around this behavior by chaining calls:Python>>>a.symmetric_difference(b).symmetric_difference(c){10, 100, 5}In this example, you call the method ona. Then, you call the method on the result of the previous call. The final result is the same as with the operator.Remove adsUsing Augmented Set OperationsThe union, intersection, difference, and symmetric difference operators covered in the previous section haveaugmented variationsthat you can use to modify a setin place. Remember, sets are mutable data types, so you can add and remove elements from a set in place.Note:Python has a variation of sets calledfrozensetthat’s immutable. This built-in data type works like normal sets but doesn’t allow you to add or remove elements. Additionally, they don’t support augmented operations.For each augmented operator, you’ll have an equivalent method. In the following sections, you’ll learn about these augmented operators and how they work with sets.Augmented UnionTheaugmented unionupdates a set in place. You can use either the augmented union operator (|=) or the.update()method to do this. Here’s the syntax for both:Python Syntaxx1|=x2[|x3|...|xN]x1.update(x2[,x3,...,xN])The part of the syntax that’s enclosed in square brackets is optional. Both tools update the target set (x1) with elements from the other sets.Returning to your event example, say that you’d like to have an up-to-date record of the attendees who have checked in:Python>>>checked_in_attendees=set()>>>id(checked_in_attendees)4364315648>>>checked_in_attendees|={""Alice"",""Charlie""}>>>checked_in_attendees{'Charlie', 'Alice'}>>>id(checked_in_attendees)4364315648>>>checked_in_attendees.update({""Linda"",""Bob""})>>>checked_in_attendees{'Charlie', 'Bob', 'Linda', 'Alice'}>>>id(checked_in_attendees)4364315648In this example, you first create an empty set using theset()constructor. Then, you use the|=operator to add two people to the checked-in set. Next, you add more people using the.update()method. The built-inid()functionlets you check that your set remains the same and that the updates are in-place operations.Augmented IntersectionTheintersection updateallows you to modify a set in place by intersection. You can perform this operation using the augmented intersection operator (&=) or the.intersection_update()method.Here’s the required syntax:Python Syntaxx1&=x2[&x3&...&xN]x1.intersection_update(x2[,x3,...,xN])The operator and the method update the target set (x1) with elements from the other sets. As a result, the final version ofx1will hold only the elements found in all the involved sets.For example, say that you have a list of target customers for a marketing campaign, and you only want to keep those who have agreed to receive emails:Python>>>accepted_emails={""Bob"",""Diana"",""Charlie""}>>>target_customers={""Alice"",""Bob"",""Charlie"",""Diana"",""Jane""}>>>target_customers&=accepted_emails>>>target_customers{'Charlie', 'Bob', 'Diana'}>>># Or>>>target_customers={""Alice"",""Bob"",""Charlie"",""Diana"",""Jane""}>>>target_customers.intersection_update(accepted_emails)>>>target_customers{'Charlie', 'Bob', 'Diana'}With the intersection update, you’ve reduced the target customers to those who accepted marketing emails.Augmented DifferenceThedifference updatelets you modify a set in place by difference. To run this type of update, you can use the augmented difference operator (-=) or the.difference_update()method.Here’s the syntax you should use to run a difference update:Python Syntaxx1-=x2[|x3|...|xN]x1.difference_update(x2[,x3,...,xN])Both the operator and the method updatex1by removing elements found in the rest of the sets.Note:The syntax for the augmented difference operator differs from the syntax of augmented union and augmented intersection. Note that the minus sign (-) isn’t used in the optional part of the syntax. Instead, you have to use the union operator (|).To learn how the augmented difference works, suppose you have a list of tasks to complete for a Python project and want to remove the ones you’ve just finished:Python>>>todo_list={...""Implement user login"",...""Fix bug #123"",...""Improve performance"",...""Write unit tests""...}>>>completed_tasks={...""Fix bug #123"",...""Improve performance""...}>>>todo_list.difference_update(completed_tasks)>>>todo_list{'Implement user login', 'Write unit tests'}In this example, you use the.difference_update()method to remove the completed tasks. Go ahead and try the-=operator!Remove adsAugmented Symmetric DifferenceThesymmetric difference updateallows you to modify a set by symmetric difference. You can perform this operation with the augmented symmetric difference operator (^=) or the.symmetric_difference_update()method.Here’s the required syntax:Python Syntaxx1^=x2x1.symmetric_difference_update(x2)These tools updatex1in place, retaining the elements found in eitherx1orx2, but not in both.Suppose you want to get the list of people who participated in only one session of your event. You can do it with a symmetric difference update:Python>>>morning_attendees={""Alice"",""Charlie"",""Linda"",""John"",""Jane""}>>>afternoon_attendees={""Charlie"",""Linda"",""Bob"",""Jane""}>>>whole_day_attendees=set()>>>whole_day_attendees^=morning_attendees>>>whole_day_attendees.symmetric_difference_update(afternoon_attendees)>>>whole_day_attendees{'Bob', 'Alice', 'John'}In this example, you have two initial sets with the list of people who came in the morning and afternoon sessions. Next, you create a new empty set calledwhole_day_attendees. Then, you use the^=operator and the.symmetric_difference_update()to update the set with the elements from the initial sets. As a final result, you get the list of people that came to only one session.Comparing SetsYou can also use operators and methods to compare two sets. In the context of sets, relational operators like>,<,>=, and<=have a slightly different interpretation than in numerical comparisons. In the following sections, you’ll learn how these operators work with sets and how to interpret their results. You’ll also learn about the equivalent methods.It’s important to note that all the checks in the following sections return aBooleanvalue rather than a new set.SubsetsThesubsetoperation lets you determine whether one set is contained in another. You can use the<=operator or the.issubset()method to perform this check.Here’s the syntax for both the operator and method for the subset check:Python Syntaxx1<=x2x1.issubset(x2)A setx1is a subset of another setx2if every element ofx1is inx2. This type of check is commonly used to check whether the first set is contained in the second.For example, suppose you want to prepare a delicious meal. You have the required ingredients for a recipe and the ingredients you currently have in your kitchen. You can quickly check if you have everything you need for your meal with a subset operation:Python>>>required_ingredients={""cheese"",""eggs"",""milk""}>>>available_ingredients={""cheese"",""eggs"",""milk"",""sugar"",""salt""}>>>required_ingredients<=available_ingredientsTrue>>>required_ingredients.issubset(available_ingredients)TrueWhen you run this subset check, you getTrueas a result. This means that you have all the ingredients for your meal.It’s important to note that a set is considered a subset of itself:Python>>>a={1,2,3,4,5}>>>a<=aTrue>>>a.issubset(a)TrueThis result may seem a bit strange at first, but it completely fits the definition: every element ofais ina.Remove adsProper SubsetsWith this check, you can determine whether one set is a proper subset of another. To perform this check, you’ll use the<operator. You won’t have a dedicated method.The syntax for a proper subset check is shown below:Python Syntaxx1<x2Aproper subsetis a subset with the additional requirement that the compared sets can’t be identical. For example, setx1is considered a proper subset of setx2if every element ofx1is inx2, andx1isn’t equal tox2.Note:Two sets are equal when they contain the same elements. You can run this comparison with the equality operator (==), which doesn’t consider the order of elements because sets are unordered data types.To illustrate how you could use the proper subset check, say that you’re offering a service with two plans: regular and premium. Using a proper subset check, you can confirm that the regular plan has fewer features than the premium plan:Python>>>regular_plan={""Tutorials"",""Quizzes""}>>>premium_plan={""Tutorials"",""Video Courses"",""Quizzes"",""Books""}>>>regular_plan<premium_planTrueIn this example, when you check whether your regular plan is a proper subset of your premium plan, you getTrue. This check will warn you against any mistakes while updating the content of your plans.Finally, while a set is considered a subset of itself, it isn’t a proper subset of itself:Python>>>a={1,2,3,4,5}>>>a<aFalseThis behavior is consistent with the proper subset definition, which states that both sets can’t be equal.SupersetsThesupersetcheck lets you determine whether one set contains another. To perform this check, you can use the>=operator or the.issuperset()method.Here’s the syntax for both the operator and method for the superset check:Python Syntaxx1>=x2x1.issuperset(x2)A superset is the opposite of a subset. In other words, setx1is a superset of setx2ifx1contains every element ofx2.Returning to the meal example, you can also use the superset check to determine whether you have all the required ingredients:Python>>>required_ingredients={""cheese"",""eggs"",""milk""}>>>available_ingredients={""cheese"",""eggs"",""milk"",""sugar"",""salt""}>>>available_ingredients>=required_ingredientsTrue>>>available_ingredients.issuperset(required_ingredients)TrueThis time, you run the check in the opposite direction. Instead of checking that all the ingredients are available in your kitchen, you’re checking whether your available ingredients contain the required ones.Finally, a set is also considered a superset of itself:Python>>>a={1,2,3,4,5}>>>a.issuperset(a)True>>>a>=aTrueAgain, this behavior completely fits the definition:acontains every element ofa.Remove adsProper SupersetsWith this check, you can determine whether one set is a proper superset of another. To perform this check, you’ll use the>operator. As with a proper subset, you won’t have a dedicated method to check for a proper superset.Here’s the syntax for a proper superset check:Python Syntaxx1>x2Aproper supersetis also a superset, except that the involved sets can’t be identical. For example, setx1is a proper superset of setx2ifx1contains every element ofx2, andx1is different fromx2.The proper superset check is the opposite of the proper subset check. So, here’s a different approach to the example about service plans:Python>>>regular_plan={""Tutorials"",""Quizzes""}>>>premium_plan={""Tutorials"",""Video Courses"",""Quizzes"",""Books""}>>>premium_plan>regular_planTrueThis time, you check in the opposite direction, checking whether the regular plan is contained in the premium plan but guaranteeing that both plans are different.Finally, a set isn’t a proper superset of itself:Python>>>a={1,2,3,4,5}>>>a>aFalseOnce again, this behavior is consistent with the definition of a proper superset, where the compared sets can’t be equal.Disjoint SetsFinally, you have the disjoint check, which allows you to determine if two sets don’t have any elements in common. In this case, you only have a dedicated method called.isdisjoint(). You won’t have an operator.Here’s the syntax for the disjoint check:Python Syntaxx1.isdisjoint(x2)Thex1.isdisjoint(x2)call returnsTrueifx1andx2have no elements in common. This type of check is useful when you need to ensure that two sets have no overlap.For example, say that you’re coding the order system for a store. You’d like to prevent the purchase of certain products if the user is underage:Python>>>defverify_purchase(age,selection,restricted_products):...ifage<21andnotselection.isdisjoint(restricted_products):...print(""Purchase denied: selection includes age-restricted products"")...else:...print(""Purchase approved"")...Insideverify_purchase(), you first check whether the current user is under 21 years old. If that’s the case, the user is underage, so you need to verify the selected products. To do that, you use a set disjoint check.Here’s how the function works:Python>>>verify_purchase(...age=18,...selection={""milk"",""bread"",""beer""},...restricted_products={""alcohol"",""beer"",""cigarettes""}...)Purchase denied: selection includes age-restricted products>>>verify_purchase(...age=18,...selection={""milk"",""bread""},...restricted_products={""alcohol"",""beer"",""cigarettes""}...)Purchase approved>>>verify_purchase(...age=35,...selection={""milk"",""bread"",""beer""},...restricted_products={""alcohol"",""beer"",""cigarettes""}...)Purchase approvedIn the first call, the user is 18 years old and is trying to buy beer, which isn’t allowed for underage users. In the second call, the beer was removed from the order, so the purchase was approved. Finally, if the user is an adult, then they don’t have purchase restrictions.Remove adsUsing Other Set MethodsSo far, you’ve learned a lot about set-specific operations. However, those aren’t the only operations that you can perform on sets. There are a mix of methods that you can call on sets to change their content.You’ll find methods for adding elements to a set and also for removing elements from a set. These are the two generic mutations that you can perform on sets. In the following sections, you’ll learn about these methods and how to use them in your Python code.Adding an Element With.add()The.add()method allows you to add a single element to an existing set. Below is a quick example that shows how this method works:Python>>>employees={""Alice"",""Charlie""}>>>employees.add(""John"")>>>employees{'Charlie', 'John', 'Alice'}>>>employees.add(""Laura"")>>>employees{'Charlie', 'John', 'Laura', 'Alice'}>>>employees.add(""John"")>>>employees{'Laura', 'Alice', 'Charlie', 'John'}>>>employees.add(""Jane"",""Bob"")Traceback (most recent call last):...TypeError:set.add() takes exactly one argument (2 given)In these examples, you add elements to an existing set. Note that when you call.add()with an element that’s already in the set, nothing happens. Finally, you can only pass one argument to.add(). Otherwise, you get aTypeErrorexception.Removing an Existing Element With.remove()If you need to remove elements from a set, then use the.remove()method. You can call this method with the element you want to remove. However, keep in mind that you’ll get an exception if the target element isn’t found in the set:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>employees.remove(""Charlie"")>>>employees{'John', 'Laura', 'Alice'}>>>employees.remove(""Linda"")Traceback (most recent call last):...KeyError:'Linda'With.remove(), you can delete one element at a time. When the target element doesn’t exist in the set, you get aKeyErrorexception. Why aKeyError? Well, sets are implemented like dictionaries with keys but without associated values. So, set elements are like dictionary keys.Deleting an Existing or Missing Element With.discard()Like.remove(), the.discard()method allows you to remove a single element from an existing set. The difference between both methods is that.discard()doesn’traise an exceptionif the element doesn’t exist:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>employees.discard(""Alice"")>>>employees{'Charlie', 'John', 'Laura'}>>>employees.discard(""Linda"")>>>employees{'Charlie', 'John', 'Laura'}If the element exists in the set, then.discard()removes it. If the element isn’t present in the set, then.discard()does nothing without raising an error.Removing and Returning an Element With.pop()Sometimes, you need to retrieve an element from a set, process it, and then remove it. In that case, you can use the.pop()method, which removes and returns an element from a set. If the target set is empty, then.pop()raises aKeyErrorexception:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>employee=employees.pop()>>>employee'Charlie'>>>employee=employees.pop()>>>employee'John'>>>employees{'Laura', 'Alice'}>>>employees.pop()>>>employees.pop()>>>employees.pop()Traceback (most recent call last):...KeyError:'pop from an empty set'The.pop()method removes and returns an arbitrary element from a set in one go. Because sets are unordered data types, you can’t predict which element will be removed. You can assign the removed element to avariableand get a reference as you did withemployee.Removing All Elements With.clear()If you ever need to remove all the elements from a set in a single operation, then you can use the.clear()method:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>employees.clear()>>>employeesset()The.clear()method comes in handy when you want to reset a set so you can start fresh. Calling.clear()completely empties the set in one step, getting it ready for new data without the hassle of removing items individually.Creating Shallow Copies of Sets With.copy()You can use the.copy()method to create ashallow copyof an existing set. This method is useful when you need to keep a copy of a set while performing some changes in the original data:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>employees_copy=employees.copy()>>>employees==employees_copyTrue>>>employeesisemployees_copyFalse>>># Change the original set>>>employees.remove(""Alice"")>>>employees{'Charlie', 'John', 'Laura'}>>>employees_copy# Keeps the data unchanged{'Charlie', 'Alice', 'John', 'Laura'}In this example, you create a copy of employees by calling the.copy()method. The copy will have the same data as the original set. In fact, it’ll hold references to the data in the original set. That’s why it’s a shallow copy.Once you’ve saved the data in the copy, you can perform any modifications to the original set. The copy will keep the data unchanged.Traversing SetsWhen working with Python sets, you’ll often need to traverse their elements in order to perform actions on them. A Pythonforlooplets you do that. If you want to iterate over a set while processing and removing its elements, then you can use awhileloop.However, you need to keep in mind that in both situations, the iteration order will be unknown beforehand because sets are unordered data types. If you need to examine a set’s content in order, then you can loop through it using the built-insorted()function.In the following sections, you’ll explore some short examples that will help you understand how to use these techniques for traversing sets in Python.Accessing and Modifying Elements in a LoopPython sets are mutable in the sense that you can add or remove elements from them. However, you can’t modify a set element in place as you can with list items, for example. So, when you use a loop to traverse a set, you can perform actionswitheach element of the set, but you can’t modify them.Consider the following example:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>foremployeeinemployees:...print(f""Hello,{employee}!"")...Hello, Charlie!Hello, John!Hello, Laura!Hello, Alice!In this example, you use aforloop to iterate over the set of employees. Inside the loop, you access the current element and use it to generate a message that you print to the screen. This loop doesn’t modify the set’s elements but does something with them.If you want to modify the elements of a set, then you should create a new set. For example, say that you want the employees’ names to be displayed in uppercase letters. You can do this with the following code:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>uppercase=set()>>>foremployeeinemployees:...uppercase.add(employee.upper())...>>>uppercase{'ALICE', 'CHARLIE', 'JOHN', 'LAURA'}In this example, you have the original set containing employees’ names. Next, you create an empty set that you’ll use to store the names in uppercase. In the loop, you use the.add()method to populate theuppercaseset by applying the.upper()method to each employee name. As a result, you get a set of names in uppercase.You can achieve the same result using a set comprehension like the following:Python>>>employees={""Alice"",""Charlie"",""John"",""Laura""}>>>{employee.upper()foremployeeinemployees}{'ALICE', 'CHARLIE', 'JOHN', 'LAURA'}Set comprehensions provide a concise and efficient way to create sets from iterables, including other sets. In this example, you create a new set with the employees’ names in uppercase letters.Processing and Removing Elements in a LoopThe.pop()method comes in handy when you need to process throwaway elements before removing them. For example, say that you have a set with the available seats on a flight. Once you assign a seat, you can remove it from the set:Python>>>available_seats={""A1"",""A2"",""B1"",""B2"",""C1""}>>>whileavailable_seats:...assigned_seat=available_seats.pop()...print(f""Seat{assigned_seat}was assigned"")...Seat B1 was assignedSeat A1 was assignedSeat B2 was assignedSeat C1 was assignedSeat A2 was assigned>>>available_seatsset()In this example, you use awhileloopto process the set of available seats. The.pop()method lets you get a reference to the current seat in the loop. Then, you assign the seat to a variable immediately after removing it from the set of available seats.Iterating Through a Sorted SetAs you already know, sets don’t keep their elements in order. Therefore, you can’t predict which element will be processed in each iteration. The built-insorted()function can help you put some order to your iteration:Python>>>cities={""Vancouver"",""Berlin"",""London"",""Warsaw"",""Vienna""}>>>forcityinsorted(cities):...print(city)...BerlinLondonVancouverViennaWarsawIn this example, you use thesorted()function to iterate over a set of cities in alphabetical order.Note:You can’t sort a set in place because they’re unordered data types. With thesorted()function, you get a new list containing the set’s elements in sorted order. This list takes additional memory.To add some spice to this example, suppose the set contains tuples of the form(city, population), and you want to iterate it sorted by population. In this situation, you can do something like the following:Python>>>cities={...(""Vancouver"",675000),...(""Berlin"",3800000),...(""London"",8980000),...(""Warsaw"",1790000),...(""Vienna"",1900000),...}>>>forcityinsorted(cities,key=lambdacity:city[1]):...print(city)...('Vancouver', 675000)('Warsaw', 1790000)('Vienna', 1900000)('Berlin', 3800000)('London', 8980000)In this example, you use alambdafunction that returns the population of the current city. Thesorted()function uses this value as a sorting key.By default, thesorted()function sorts the items in ascending order. You can use thereverseargument to sort in descending order:Python>>>forcityinsorted(cities,key=lambdacity:city[1],reverse=True):...print(city)...('London', 8980000)('Berlin', 3800000)('Vienna', 1900000)('Warsaw', 1790000)('Vancouver', 675000)SettingreversetoTruemakes the function sort the items in descending order. Now, the most populated city is at the top of the output.Exploring Other Set CapabilitiesPython sets work seamlessly with some built-in functions and operators. Among the most popular are thelen()function and the membership operatorsinandnot in, which provide efficient ways to work with sets.Note:To learn more about thelen()function and the membership operators, check out the following tutorials:Using thelen()Function in PythonPython’sinandnot inOperators: Check for MembershipWhether you want to quickly check how many elements a set has or verify if an element is in a set, these two tools have you covered.Finding the Number of Elements Withlen()To find out how many elements a set contains, simply call thelen()function with your set as an argument:Python>>>fruits={""apple"",""mango"",""orange""}>>>len(fruits)3Because sets don’t allow duplicates, you’ll always get the count of distinct items, makinglen()a quick way to verify the uniqueness of your data.Running Membership Tests on SetsYou can use the Pythoninandnotin operators to check whether an element belongs to a collection or container. These checks are known asmembership testsand can be pretty useful in real-world coding.Because Python sets are implemented as hash tables, it turns out that they’re very efficient for membership tests, especially compared tolistobjects. So, when you need to perform frequent membership tests on a collection, you’ll benefit from using a set.The followingscriptcompares the execution speed of membership tests run on a list and a set:Pythonmembership.pyimportrandomimporttimenumbers_list=list(range(1_000_000))numbers_set=set(range(1_000_000))number_to_check=[random.randint(0,999_999)for_inrange(1_000)]start=time.perf_counter()fornumberinnumber_to_check:_=numberinnumbers_listend=time.perf_counter()print(f""List membership check took{end-start:.4f}seconds"")start=time.perf_counter()fornumberinnumber_to_check:_=numberinnumbers_setend=time.perf_counter()print(f""Set membership check took{end-start:.4f}seconds"")Sets shine when you need to run several membership checks. In this example, you generate a list and a set of one million numbers each. Then, you perform 1000 membership tests on each data type in a loop. Go ahead and run the script on your computer to check the speed gain with the set variation.ConclusionYou’ve learned a lot about Python’ssetdata type, which is an unordered collection of unique and hashable elements. You’ve explored different ways to create sets, including using literals, theset()constructor, and set comprehensions.Additionally, you’ve learned about common set operations such as union, intersection, difference, and symmetric difference, as well as several set manipulation techniques.Understanding sets can make a difference in your Python journey. Sets provide efficient ways to handle collections of unique items, perform membership tests, and execute set operations. They come in handy when you need to eliminate duplicates or perform fast lookups.In this tutorial, you’ve learned how to:Create sets usingliterals, theset()constructor, andcomprehensionsPerform commonset operationssuch asunion,intersection,difference, andsymmetric differenceUseaugmented set operationsto modify setsin placeCompare sets usingsubset,superset, anddisjointchecksManipulate sets byadding,removing, andtraversingtheir elementsWith these skills, you can now effectively use Python sets to manage collections of unique items, optimize your code for performance, and solve problems involving set theory and operations. This knowledge will enable you to write more efficient and clean Python code.Get Your Code:Click here to download the free sample codethat shows you how to work with sets in Python.Frequently Asked QuestionsNow that you have some experience with sets in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What is asetin Python and how does it differ from a list?Show/HideAsetin Python is an unordered collection of unique and hashable elements, unlike a list, which is ordered and can contain duplicate elements.How do you create asetin Python?Show/HideYou can create asetusing literals that consist of a pair of curly braces{}with a comma-separated series of elements inside, or by using theset()constructor or a set comprehension.What are some common set operations you can perform on Python'sset?Show/HideYou can perform operations like union, intersection, difference, and symmetric difference on Python sets.How can you add or remove elements from asetin Python?Show/HideYou can add elements to asetusing the.add()method and remove elements with the.remove(),.discard(), or.pop()methods.What are some scenarios where using asetis beneficial?Show/HideUsing asetis beneficial when you need to store unique items, perform many membership tests, or eliminate duplicates from an iterable.Take the Quiz:Test your knowledge with our interactive “Python Sets” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizPython SetsIn this quiz, you'll assess your understanding of Python's built-in set data type. You'll revisit the definition of unordered, unique, hashable collections, how to create and initialize sets, and key set operations.Mark as CompletedShareWatch NowThis tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding:Using Sets in Python"
Modern Web Automation With Python and Selenium,https://realpython.com/modern-web-automation-with-python-and-selenium/,"Apr 30, 2025",N/A,"intermediate, projects, testing, web-scraping","Table of ContentsUnderstand the Project and ApproachThe Selenium ProjectYour Bandcamp Discover Music PlayerThe POM Design PatternThis TutorialSet Up Your EnvironmentInstall SeleniumSet Up GeckoDriver for FirefoxVerify Your SetupNavigate a Web Page With Python and SeleniumUnderstand the DOM Structure of BandcampLaunch a Headless Browser and Navigate to a URLLocate Elements in the DOMInteract With Web ElementsClick Buttons and LinksSend Keystrokes and Text EntryDeal With Hidden or Overlaid ElementsUse Hover, Drag-and-Drop, and More Complex GesturesSubmit FormsHandle Dynamic ContentUnderstand Implicit, Explicit, and Fluent WaitsSet Up an Implicit WaitUse Explicit Waits for Targeted WaitingChoose From Common Expected ConditionsHandle Synchronization IssuesImplement the Page Object Model (POM)Understand the POM Design PatternEstablish a Base for Pages and ElementsDescribe Your Web Page as a Page ObjectDefine Reusable Web ElementsKeep Locators SeparateEnjoy the Benefits of the POM in PracticeBuild the Music Player AppCreate Your Music Player ClassAssemble a Text-Based User InterfaceMake Your App ExecutableNext StepsConclusionFrequently Asked QuestionsRemove adsSelenium is a web automation tool that allows you to use Python to programmatically interact with dynamic, JavaScript-generated web pages. Your Python Selenium code drives a real browser that you can instruct to fill out forms, click buttons, scrape dynamically generated data, or write automated tests for web applications.By implementing the Page Object Model (POM) design pattern, you can create clean and scalable automation scripts that are straightforward to read and maintain.By the end of this tutorial, you’ll understand that:Seleniumallows you to launch browsers, visit URLs, and interact with web elements.Headless browserslet you run scripts without displaying a browser window, which is useful for automation and testing.You can target web elements using differentlocators, such as CSS selectors, XPath, or IDs.Explicit waitsprovide a flexible way to handle dynamic content by waiting for specific conditions.ThePage Object Modeldesign pattern separates page structure from business logic.In this tutorial, you’ll learn how to use Selenium with Python to build a fully functional music player that interacts with Bandcamp’sDiscoverpage. You’ll control the player from the command line while a headless Firefox browser runs in the background. With it, you’ll be able to play tracks, pause music, list available tracks, and load more tracks, replicating some of the website’s core functionality.Along the way, you’ll learn modern best practices, like implementing thePage Object Model (POM), which helps keep your automation scripts clean, testable, and maintainable. Ready to get started? Head over tobandcamp.com/discover/and play some of the available music to get a feel for the website and pump up your mood for this project!Get Your Code:Click here to download the free sample codethat shows you how to use Selenium in Python for modern web automation.Take the Quiz:Test your knowledge with our interactive “Web Automation With Python and Selenium” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizWeb Automation With Python and SeleniumIn this quiz, you'll test your understanding of using Selenium with Python for web automation. You'll revisit concepts like launching browsers, interacting with web elements, handling dynamic content, and implementing the Page Object Model (POM) design pattern.Understand the Project and ApproachWeb automationinvolves using a script to drive a browser and perform actions such as clicking links, filling out forms, and gathering data. Instead of manually navigating a website, you can delegate these tasks to Python. A typical scenario is automating repetitive tasks, such as logging in daily to a tool or scraping regularly updated data.Because many web apps are built for human interaction, they can present challenges when you try to interact with them automatically. In the early days of the internet, you could send HTTP requests and parse the resulting HTML. But modern sites often rely onJavaScriptto handle events or generate content dynamically, meaning that an HTTP request alone probably won’t reveal the full page content. That’s whereSeleniumcomes in.Remove adsThe Selenium ProjectSelenium is a mature open-source project that provides a convenient API to control browsers. With Selenium, you can:Launch a headless or visible browser such as Firefox or Chrome using aweb driver.Visit URLs and navigate pages just like a real user would.Locate elements with CSS selectors, XPath, or similar locators.Interact with elements by clicking, typing, dragging, or waiting for them to change.Once you install the appropriate driver for your browser, you can control your browser through a script using Selenium.Selenium itself is written inJava, but has bindings for different programming languages. In Python, it’s distributed onPyPIas a single package calledselenium, which you can install usingpip.Selenium is often used for automated testing, but it’s equally useful for generic web automation, which is what this tutorial will focus on.Note:You might be wondering how Selenium differs from other tools for scripted web interactions, such asBeautiful Soup,Scrapy, orRequests.One central difference is that those tools are great at handling static data, while Selenium allows you to replicate user behavior at the JavaScript level. This means that you can interact with dynamically generated web content using Selenium.Before diving into the nuts and bolts of Selenium, it’s helpful to get a clear picture of what you’ll build by the end of this tutorial. As mentioned, you’ll create a fully functional, console-based music player that interacts with theBandcampDiscoverpageusing a headless Firefox browser.Your Bandcamp Discover Music PlayerBandcamp is a popular online record store and music community where you can stream songs, explore artists, and discover new albums.Selenium allows you to automate direct interactions with Bandcamp’s web interface—as though you were clicking and scrolling yourself!Your finished project will open the Bandcamp Discover page in the background, which means you won’t get to see any of the wonderful album artwork:If a browser automation tool creates a browser instance without a visible browser window, it’s said to run inheadlessmode. But don’t lose your head over that word—your code will stay calm and in control!In headless mode, the browser instance will gather a list of tracks. Each track will have information about its associated album, artist, and—if present—genre.Finally, your app will provide a text-based interface to control the music playback with a couple of options:play:Plays or resumes playing a track, optionally through a selected track numberpause:Pauses the currently playing tracktracks:Lists the currently loaded tracksmore:Loads more tracks from the Bandcamp Discover pageexit:Shuts down the program and closes the headless browser instanceUsing these commands, you’ll be able to listen to the music that’s currently available on Bandcamp’s Discover page:TextType: play [<track number>] | pause | tracks | more | exit
> play
Track(album='Carrie & Lowell (10th Anniversary Edition)',
      artist='by Sufjan Stevens',
      genre='folk',
      url='https://music.sufjan.com/album/carrie-lowell-10th-anniversary-edition')

Type: play [<track number>] | pause | tracks | more | exit
> tracks
#     Album                          Artist                         Genre
--------------------------------------------------------------------------------
1     Carrie & Lowell (10th Anniv... by Sufjan Stevens              folk
2     moisturizer                    by Wet Leg                     alternative
3     Outpost (DiN11)                by Robert Rich & Ian Boddy     electronic
4     Obscure Power                  by Quest Master                ambient
5     Hex; Or Printing In The Inf... by Earth                       experimental
...Hopefully this sounds like a fun project to tackle! Reducing a colorful user interface with album images to a text-based interaction surely must be a programmer’s dream!Even if you (rightfully) disagree with this sentiment, there’s a serious educational point to working on this project. Building a music player with Selenium hits many real-world tasks that you can also utilize for other web automation tasks, such as finding and clicking elements, handling dynamic content, and structuring your code well.This project also merges the idea of functional testing—ensuring the interface works as intended—with the potential for gathering data or performing tasks automatically.Remove adsThe POM Design PatternYou could theoretically write your entire automation script in a single Python file, but as soon as your project grows, you’ll feel the pain of monolithic spaghetti code. That’s where thePage Object Model (POM)enters the picture.The POM is a design pattern commonly used in test automation to improve the structure, readability, and maintainability of test code. It encourages a clear separation between the logic that interacts with the user interface and the actual test scripts. By following the POM, you represent each web page or component in an application by a dedicated class known as apage object.This class serves as an interface to that page and usually encapsulates both the locators and the actions a user can perform on the page, such as clicking a button or entering text into a field.Note:In this tutorial, you’ll further separate the locators into a dedicated file. You’ll use references to these locators in your page objects.By organizing UI interactions this way, POM helps reduce duplication and makes test or automation code less effort to manage, especially as a project grows. If the structure of a web page changes, then you’ll typically need to apply updates only in the corresponding page object rather than across multiple scripts. This leads to more robust and reusable code.Ultimately, the Page Object Model allows automation code to be more scalable, more straightforward to understand, and less prone to breaking when the web application evolves.This TutorialIn this tutorial, you’ll start by covering essential Selenium skills in short, targeted sections, before moving into implementing these skills using the POM, and finally, you’ll bring it all together to build your music player.When you’re done, you can use your app to discover new music on Bandcamp. You’ll also have learned how to orchestrate Selenium to reliably find and interact with page elements in a well-organized codebase.Note:Any time you automate interactions with a website, make sure that you abide by the site’s terms of use and act responsibly.This tutorial doesn’t scrape any personal data and only performs basic actions that a typical user would. If you plan to adapt such scripts for more extensive scraping, then confirm that you’re not violating any policies or overwhelming servers with too many requests.Now that you know where you’re headed, you can move on to prepare your environment so you can develop, run, and test your Selenium automation.Set Up Your EnvironmentTo run Selenium in Python, you’ll need a modern version of Python, theseleniumpackage, a browser, and a browser driver that can talk to your chosen browser. In this tutorial, you’ll use Firefox along with GeckoDriver. But you can pick a different driver, like ChromeDriver, if you prefer using Chrome.Install SeleniumTo follow along,install Python 3.10 or newer. You can verify your installation by opening aterminaland checking for Python’s version:Shell$python--versionPython 3.13.2Your exact version number will differ, but it should read3.10or above so that you can leverage Python’sstructural pattern matchingwhen you build thecommand-line interface (CLI)for your music player.With a compatible version of Python installed, create avirtual environmentso that your Selenium installation and any dependencies don’t clutter your global Python setup.Navigate to your project folder and create the environment usingvenv:WindowsLinux + macOSWindows PowerShellPS>python-mvenvvenv\PS>.\venv\Scripts\activate(venv)PS>python--versionPython 3.13.2Shell$python-mvenvvenv/$sourcevenv/bin/activate(venv)$python--versionPython 3.13.2You’ll notice(venv)in your shell prompt, which means that your virtual environment is active.Next, install Selenium into this virtual environment usingpip:Shell(venv)$python-mpipinstallseleniumThe Python bindings for Selenium that you get using this command are the only direct dependencies for this project that you’ll install withpip.If you want to make sure that you’re running the same version of all external packages, then you can install them from therequirements.txtfile provided in the downloadable materials:Get Your Code:Click here to download the free sample codethat shows you how to use Selenium in Python for modern web automation.Once you’re in the same folder as the therequirements.txtfile, you can install all dependencies listed there:Shell(venv)$python-mpipinstall-rrequirements.txtIf you installseleniumdirectly, then pip will fetch the latest stable version of Selenium from PyPI. If you choose to install the dependencies using therequirements.txtfile, then you’ll work with the exact versions used in this tutorial.Remove adsSet Up GeckoDriver for FirefoxSelenium interacts with a real browser under the hood. Before proceeding, make sure that you have an up-to-dateinstallation of Firefoxon your computer.To communicate with Firefox, you need thegeckodriverbinary. Download the correct version from theMozilla geckodriver releasespage, and choose the appropriate build for your operating system.After unpacking, place thegeckodriverbinary in a location accessible by your system. For instance, on macOS or Linux, you could move it into/usr/local/bin. On Windows, you can add the folder containinggeckodriver.exetoyour system’s PATH.Confirm the driver is available by typing:Shell(venv)$geckodriver--versiongeckodriver 0.36.0 (a3d508507022 2025-02-24 15:57 +0000)...Your version number may be different, but you should see some version string printed to your terminal. If you get acommand not founderror, then you still need to adjust your PATH or specify the driver’s exact location in your Selenium code.Verify Your SetupTo make sure everything works, open aPython REPLinside your virtual environment and take your browser for a drive:Python>>>fromseleniumimportwebdriver>>>fromselenium.webdriver.firefox.optionsimportOptions>>>options=Options()>>>options.add_argument(""--headless"")>>>driver=webdriver.Firefox(options=options)>>>driver.get(""https://www.python.org"")>>>driver.title'Welcome to Python.org'>>>driver.quit()If you see'Welcome to Python.org', then congratulations—Selenium just launched Firefox in headless mode, navigated to Python’s home page, and fetched the page title. You’ve confirmed that your environment is set up correctly.In case Firefox isn’t working correctly for you, expand the collapsible section below to try using Chrome instead:Use Chrome Instead of FirefoxShow/HideYou’ll need to have theChrome browserand theChromeDriverproperly installed if you want to work with Chrome instead of Firefox.If that’s all set up correctly, then you just need to swap out the relevant import and setup steps:Python>>>fromseleniumimportwebdriver>>>fromselenium.webdriver.chrome.optionsimportOptions>>>options=Options()>>>options.add_argument(""--headless"")>>>driver=webdriver.Chrome(options=options)>>>driver.get(""https://www.python.org"")>>>driver.title'Welcome to Python.org'>>>driver.quit()The tutorial will keep referring to a setup using Firefox and GeckoDriver, but if you’re working with Chrome and ChromeDriver, you’ll just need to swap out these lines of code in the upcoming code examples.If you’re curious to see Selenium drive your browser while keeping its head on, then try running the same code without adding any options. You should see a browser window pop up, navigate topython.org, and finally close again when you call.quit().You may run into snags during this setup. If you do, then check out the following troubleshooting tips:Version Mismatch: If instantiating yourWebDriverfails, then check that your browser version aligns with the one required by the matching WebDriver. Typically, GeckoDriver updates are backward-compatible with many versions of Firefox, but very old or very new versions might cause an issue.Permission Issues: On UNIX systems, you need to make sure that thegeckodriverfile has execute permissions.PATH Issues: Ensure that the directory containing thegeckodriveris in your PATH, so that your operating system knows where to find it.Firewall or Security Software Blocks: Occasionally, overly strict antivirus programs can block WebDriver traffic. Temporarily disabling or adding exceptions can help.These are some quick tips that may send you in the right direction if your setup isn’t working yet.With everything installed and tested, you’re ready to code more complex interactions. You’ll soon see how to open the Bandcamp page, parse track elements, and eventually control an entire music player.But first, you’ll learn how to navigate a page with Selenium, select elements, and read or manipulate their content. These building blocks will help you understand how your final player selects the correct track, clicksplay, and gathers information about each album and artist.Navigate a Web Page With Python and SeleniumWith Selenium installed and your driver set up, you can now open up a website using Python code and inspect or manipulate its content. In this section, you’ll learn some essential operations:Loading a page and waiting for it to finish loadingLocating elements by CSS selector or HTML IDReading attribute values or text from the elementsBecause you’ll be building a music player eventually, it’s a good idea to get more familiar with the structure of the Bandcamp discover page.Underlying every web page is theDOM (Document Object Model), which represents HTML elements in a tree-like structure. Selenium’s job is to let you query and manipulate parts of that DOM.Remove adsUnderstand the DOM Structure of BandcampThe first step ofprogrammaticallyinteracting with any website is always to interact with itmanually. Before you write code, you need to understand the page that you want to work with. So, open up your browser athttps://bandcamp.com/discover/.Note:In some geographical locations, the site may greet you with a cookie consent form. Take a mental note of that. Ifyouneed to click away a cookie consent form, then your Selenium driver will have to do that as well.You should see a grid of tracks, each with an image thumbnail, album name, artist, and so on. On the right side, there’s a larger player that highlights the first song, or the song that’s currently playing.
When you scroll to the bottom of the page, you can load more tracks dynamically by clicking theView more resultsbutton.Listen to a song or two, pressplayandpausea couple of times, then load more songs into view:Next, open your developer tools by right-clicking the page and selectingInspect. Bandcamp’s discover page has a large container that holds the track elements, and each track has an associated button to start or pause audio.By inspecting these elements, you can identify the relevant classes or attributes that you’ll later use in your script:HTML<divclass=""results-grid""><ulclass=""items""><liclass=""results-grid-item""><sectionclass=""image-carousel"">...<buttonclass=""play-pause-button""aria-label=""Play""></button>...</section><divclass=""meta""><p><ahref=""https://artist-name.bandcamp.com/album/album-name?from=discover_page""><strong>Album Name</strong><span>by Artist Name</span></a></p><pclass=""genre"">genre</p></div></li>...</ul></div>The actual HTML is a lot longer and more complex, and may also change when Bandcamp updates their site structure.Note:If you need a refresher for understanding this code, then you can learn more inHTML and CSS for Python Developers.The main idea is that each track is a list element with aplay-pausebutton, an album URL, the name of the album and artist, and possibly some information about the genre. You’ll use some of the classes you see above to locate elements later on.Launch a Headless Browser and Navigate to a URLAfter manually opening the site, you’ll now open Bandcamp’s Discover page using Python code. Start by creating awebdriver.Firefoxinstance, then navigate to the Discover page URL:Pythonnavigation.pyfromseleniumimportwebdriverfromselenium.webdriver.firefox.optionsimportOptionsoptions=Options()options.add_argument(""--headless"")driver=webdriver.Firefox(options=options)driver.implicitly_wait(5)driver.get(""https://bandcamp.com/discover/"")print(driver.title)driver.quit()This short script opens a headless Firefox browser, navigates to your target site, waits for elements to load, and fetches the page title. Then, it closes the browser instance.Note:Calling.quit()on your WebDriver instances is important to avoid invisible headless browser instances looming in the back of your system, eating up processing power and RAM. Sounds scary? It sure does—so remember to closethe instances that you summon!If you omit the--headlessoption, then you’ll see the browser window pop up and navigate to the page. This can be useful for debugging, but it’s often redundant for automated tasks. Showing your browser’s interface also exposes it to accidental input, such as when you accidentally click on the visible window. Further, some websites may behave differently depending on your screen size.Locate Elements in the DOMAfter loading a page, you’ll want to locate certain elements. You may be looking for a search bar or a login button—or a music track! Selenium supports severallocator strategies, including:By IDBy CSS selectorBy XPathBy link text, tag name, or class nameIn modern versions of Selenium, the recommended approach is to use theByclasstogether with.find_element()or.find_elements():Pythonnavigation.pyfromseleniumimportwebdriverfromselenium.webdriver.firefox.optionsimportOptionsfromselenium.webdriver.common.byimportByoptions=Options()options.add_argument(""--headless"")driver=webdriver.Firefox(options=options)driver.implicitly_wait(5)driver.get(""https://bandcamp.com/discover/"")print(driver.title)pagination_button=driver.find_element(By.ID,""view-more"")print(pagination_button.accessible_name)tracks=driver.find_elements(By.CLASS_NAME,""results-grid-item"")print(len(tracks))print(tracks[0].text)driver.quit()In this example, you use two different locator strategies:You look for asingleelement using.find_element()with the selectorBy.IDto find theView more resultsbutton.You look foralltrack elements that are currently visible on the page using.find_elements()with the selectorBy.CLASS_NAME. This returns a list ofWebElementobjects.Then, youprintsome of the gathered results to your terminal.Note:The number of tracks you see will also depend on theviewportsize of your headless browser instance. You’ll set a fixed value for it later to ensure reproducible results.Because Selenium returnsWebElementobjects, you can perform sub-searches on those elements using the same approach. For example, you can pick the first track and find the album title:Pythonnavigation.py# ...track_1=tracks[0]album=track_1.find_element(By.CSS_SELECTOR,""div.meta a strong"")print(album.text)In this case, the CSS selector""div.meta a strong""points to the HTML element that contains the album name.Before you write this code, you already need to know where the information you’re looking for is located on the website. That’s why it’s important to inspect the site using your developer toolsfirst, and in doing so, identify locators that’ll help you target the elements you’re interested in.Also, keep in mind that not all situations benefit from the same locator strategy. IDs or unique CSS classes are usually good choices and you’ll work with them throughout this tutorial.XPathsare another powerful locator strategy, but they can become unwieldy if you rely on complicated XPath expressions and are oftenless performantthan other options.Any locators that you settle on may stop working when the website structure changes. It sure can be frustrating when you write locators that match your current HTML, but break when the page design changes—and it will eventually!For example, consider the following XPath expression that targets an item unambiguously:Python""/html/body/div[2]/span[1]/a[3]""This XPath expression is an absolute path that starts at the root<html>element and drills down through the DOM tree to select a specific element. It navigates to the<body>, then to the second<div>inside the body, followed by the first<span>within that<div>. Finally, it selects the third link element within that<span>.While this expression is great for now, it may be overly fragile. If the page layout changes slightly, for example, if a designer adds a new<div>or reorders elements, then this locator fails.Wherever possible, look for stable attributes likeidor semantic classes. Unfortunately, some websites only use auto-generated classes, which may change frequently. In these cases, you can rely on partial text matches or more abstract patterns.Either way, locators are brittle and will require some maintenance across the life of your web automation. That’s just a fact, based on the reality that web pages keep changing and evolving.Note:ThePage Object Model design pattern, which you’ll learn more about later, can help you manage your locators in a maintainable way.At this point, you know how to start Selenium, navigate to a URL, and locate key elements in the DOM.In the next section, you’ll refine your skills by clicking elements and performing more advanced interactions, like sending keystrokes or dealing with forms. These building blocks will give you a good general overview and will also lead into the final application, where you’ll systematically gather track information and pressPlayon Bandcamp.Remove adsInteract With Web ElementsNavigating to a page and targeting elements is only step one. You probably also need to interact with some elements on the page. This could mean filling out forms, clicking buttons, selecting checkboxes, or scrolling. You’ll do these tasks by calling methods on yourWebElementinstances. In this section, you’ll explore common interactions and see how to adapt them for your Bandcamp music player.Click Buttons and LinksTo click a button with Selenium, you need to locate the button element and call.click()on it:Pythonbutton=driver.find_element(By.ID,""submit-button"")button.click()Calling.click()instructs Selenium to simulate a mouse click. Under the hood, Selenium ensures the element is in view and clickable. If it’s obscured, then you may get an exception about an element not being interactable. Sometimes you need to scroll or wait for animations to end.In your music player, you’ll use click events to play and pause tracks, and to load additional tracks. Start with a script similar to the one you built in the previous section:Pythoninteraction.pyfromseleniumimportwebdriverfromselenium.webdriver.firefox.optionsimportOptionsfromselenium.webdriver.common.byimportByoptions=Options()options.add_argument(""--headless"")driver=webdriver.Firefox(options=options)driver.implicitly_wait(5)driver.get(""https://bandcamp.com/discover/"")tracks=driver.find_elements(By.CLASS_NAME,""results-grid-item"")print(len(tracks))driver.quit()This script prints the number of currently visible tracks to your terminal. Run the script and take note of how many tracks your headless browser sees displayed.Now, add code to find theView more resultsbutton like you did before—and this time also click it:Pythoninteraction.pyimporttime# ...pagination_button=driver.find_element(By.ID,""view-more"")pagination_button.click()time.sleep(0.5)tracks=driver.find_elements(By.CLASS_NAME,""results-grid-item"")print(len(tracks))driver.quit()You’ve identified the pagination button and clicked it. To give the site a chance to load the new results, you’ve added a crude call totime.sleep()that pauses execution for half a second. There are better ways to do this within Selenium, andyou’ll learn about themin just a bit.Then, you did another search for all track elements in their container, and printed the number of tracks a second time. You’ll see that you have more accessible tracks after clicking the button. Indeed, you just loaded additional results into your headless browser!Selenium will throw anElementNotInteractableErrorif the button isn’t visible or is outside of the current viewport. Usually, you can fix this by ensuring the page is scrolled properly or the button is truly ready to be clicked.Note:If your headless browser encounters a cookie consent form, then the above interaction will also fail with anElementNotInteractableError.In this case, you can practice writing code to locate the cookie consent form first and instruct Selenium to click one of the buttons to dismiss it. That’s good practice! If you need to dismiss the cookie form now, then you’ll also need to do so later on for the music player.You’ll see a possible solution in the next section and learn more about how to tackle these situations in the section ondealing with overlays.In many standard web pages, if the element is in the DOM, then.click()works perfectly—but keep an eye out for special JavaScript behaviors and overlays.Send Keystrokes and Text EntryIf you’re dealing with input fields, then you can type text into them using.send_keys():Pythonsearch_box=driver.find_element(By.TAG_NAME,""input"")search_box.send_keys(""Search for this"")search_box.submit()Here, we find the input element by its HTML tag name, type a query, and then submit the form. The.submit()method is equivalent to pressing theEnterkey when focused on a form field, but you could also explicitly instruct the browser to press theEnterkey:Pythonfromselenium.webdriver.common.keysimportKeys# ...search_box.send_keys(Keys.ENTER)How could this work on the Bandcamp page? At the top, you have a search field that allows you to search for albums, artists, and more. You can identify the locator of that field using your developer tools, target the HTML input field, and send you search query.Because it’s fun to see your code type something on a website, run the following script without using headless mode:Pythoncommunication.pyimporttimefromseleniumimportwebdriverfromselenium.common.exceptionsimportNoSuchElementExceptionfromselenium.webdriver.common.byimportBydriver=webdriver.Firefox()# Run in normal modedriver.implicitly_wait(5)driver.get(""https://bandcamp.com/discover/"")# Accept cookies, if requiredtry:cookie_accept_button=driver.find_element(By.CSS_SELECTOR,""#cookie-control-dialog button.g-button.outline"",)cookie_accept_button.click()exceptNoSuchElementException:passtime.sleep(0.5)search=driver.find_element(By.CLASS_NAME,""site-search-form"")search_field=search.find_element(By.TAG_NAME,""input"")search_field.send_keys(""selenium"")search_field.submit()time.sleep(5)driver.quit()When you run this script, you’ll see how Python opens up a browser window, locates the search box up top, enters the text you passed to.send_keys(), and submits the form.The code includes a call totime.sleep()to give you a moment to look at the newly loaded page before closing the browser instance with.quit().Keep in mind that Selenium does the same when you run it in headless mode—you just don’t get to see the interactions. As you might expect, switching off headless mode can often be helpful if you’re wondering why something doesn’t quite work the way you want it to. For example, like when a cookie consent form overlay blocks any other interaction with the page.Remove adsDeal With Hidden or Overlaid ElementsModern sites often use overlays or modals that might conceal underlying elements. Selenium typically interacts with the topmost clickable element under the cursor. If you suspect an overlay is interfering, then you first need to close the overlay, or wait until it disappears.In the previous examples, you may have encountered a cookie overlay that needs to be dealt with before you can click anything else on the page.Considering that such an overlay is a normal part of the page like anything else, you can target the overlay and the relevant buttons, then perform a click event to dismiss it:Python# ...cookie_accept_button=driver.find_element(By.CSS_SELECTOR,""#cookie-control-dialog button.g-button.outline"",)cookie_accept_button.click()This code snippet finds theAccept necessary onlybutton on Bandcamp’s cookie consent overlay and clicks it. As a privacy-aware internet user, you’d take the same action manually when visiting the page for the first time.Because some HTML pop-ups, such as cookie consent forms, may be targeted only at certain geographies, it can be a good idea to account for that by wrapping the logic into atry…exceptblock:Pythonfromselenium.common.exceptionsimportNoSuchElementException# ...try:cookie_accept_button=driver.find_element(By.CSS_SELECTOR,""#cookie-control-dialog button.g-button.outline"",)cookie_accept_button.click()exceptNoSuchElementException:passBy wrapping the cookie consent logic into atry...exceptblock, you make your code more robust and versatile. FollowingEAFP, you first ask Selenium to find the cookie consent button. If the button exists, you instruct Selenium to click it. If it doesn’t exist, the framework raises aNoSuchElementException, which you catch and follow up with apassstatementto continue normal execution.Another approach you can follow is to use JavaScript directly:Pythondriver.execute_script(""arguments[0].click();"",overlay_element)This code snippet executes a short JavaScript function that clicks on the page. This may work to remove some overlays which you don’t need to target. But be careful—bypassing standard user interactions can break real-world test conditions.For the final Bandcamp-based project, you won’t need such workarounds. You’ve already identified the cookie consent form, and the site’s track elements are straightforward to interact with.Use Hover, Drag-and-Drop, and More Complex GesturesSelenium can also replicate user actions like dragging elements, hovering, or right-clicking. These are performed using theActionChainsclass. Here’s an hypothetical example of performing a hover and clicking a submenu item:Pythonfromselenium.webdriverimportActionChains# ...menu=driver.find_element(By.CSS_SELECTOR,"".menu"")submenu=driver.find_element(By.CSS_SELECTOR,"".menu #submenu"")actions=ActionChains(driver)actions.move_to_element(menu)actions.click(submenu)actions.perform()You start by identifying both relevant elements, then set up an instance ofActionChains. You then use.move_to_element()to perform a hover action on themenuelement. This hover action triggers a drop-down that allows you to select a sub-menu item. Because the sub-menu is now open for interaction, you can call.click()on this child element.In this example, you stack multiple actions, which you then execute in the defined order using.perform(). Being able to collect actions before executing them together is a helpful feature ofActionChains.Though the final Bandcamp app won’t require such advanced gestures, it’s good to know that Selenium can handle them. If you want a comprehensive reference, then check outAction Chainsin the Selenium documentation.Submit FormsIf you’re testing or automating a form, you’ll often fill in multiple fields before clicking a submit button. For example:Pythonsignup_form=driver.find_element(By.ID,""signup-form"")email_input=signup_form.find_element(By.NAME,""email"")password_input=signup_form.find_element(By.NAME,""password"")email_input.send_keys(""user@example.com"")password_input.send_keys(""MySecurePassword123"")signup_form.submit()Just like when interacting with a form manually, you can fill multiple input fields and then submit the whole form in one go.Submitting the form typically triggers a page load orAJAXcall, so it’s wise to pair this with a wait condition, which you’ll cover in the next section.While some of the code snippets in this section are fairly general, most of them still feed into your final project. You’ll soon implement button clicks to play and pause tracks, and load additional tracks by pressing theView more resultsbutton. Knowing how to locate elements and issue interactions using.click()is essential for that.Next, you’ll see how to handle one of the biggest challenges on many modern sites: dynamic content that arrives asynchronously. You’ll learn about explicit waits and how you can make sure that your code doesn’t break just because a track or button isn’t immediately visible.Remove adsHandle Dynamic ContentOne of the biggest obstacles in web automation isdynamic content. Many sites aresingle-page applicationsor rely heavily on JavaScript to fetch data after the initial page load. If you naively try to locate elements before they exist, then you’ll get errors likeNoSuchElementException. You need a strategy for telling Selenium to wait until the content is actually there.You’ve usedtime.sleep()in previous examples, but Selenium has much more flexible and robust built-in solutions to handle this challenge.Understand Implicit, Explicit, and Fluent WaitsSelenium offers different built-in waiting mechanisms that give you a lot of flexibility in how to wait for a site to represent the state you need for interaction.The Java implementation of Selenium distinguishes between three types of waits:Implicit Wait: Selenium polls the DOM for a specified time whenever you try to find an element.Explicit Wait: Selenium applies conditions to waits, which makes it more flexible.Fluent Wait: Selenium allows you to specify the polling interval, ignore certain exceptions that occur during polling, and set custom timeout messages.In Java, an explicit wait is just a fluent wait with certain default restrictions applied.The Python bindings for Selenium skip setting up a third type of wait and expose implicit and explicit waits. In Python, the explicit waits have all the flexibility that a Java fluent wait provides.Set Up an Implicit WaitAs mentioned, an implicit wait tells Selenium to poll the DOM for a specified time whenever you try to find an element. You’ve seen it in all the previous code examples and you only need to set it once for a driver session:Pythondriver.implicitly_wait(5)This line of code sets up an implicit wait of five seconds for yourdriver.
If your element is found quickly, then execution continues. Otherwise, Selenium keeps checking until either the element appears or five seconds pass, whichever comes first.Adding an implicit wait can be a quick fix if your script breaks due to load time issues, and generally establishes a good safety net. It’s certainly a step up compared to callingtime.sleep()multiple times in your code! However, it’s a general wait that’s not targeted to any conditions, or specific to an element or interaction.Use Explicit Waits for Targeted WaitingThe true stars of waiting for dynamic content when working with Selenium are explicit waits. Explicit waits use aWebDriverWaitobject in combination with predefined conditions. This is immensely more flexible!Copy the code that you wrote ininteraction.pyto load additional tracks into a new file that you can callobservation.py:Pythonobservation.pyimporttimefromseleniumimportwebdriverfromselenium.common.exceptionsimportNoSuchElementExceptionfromselenium.webdriver.firefox.optionsimportOptionsfromselenium.webdriver.common.byimportByoptions=Options()options.add_argument(""--headless"")driver=webdriver.Firefox(options=options)driver.implicitly_wait(5)driver.get(""https://bandcamp.com/discover/"")tracks=driver.find_elements(By.CLASS_NAME,""results-grid-item"")print(len(tracks))try:cookie_accept_button=driver.find_element(By.CSS_SELECTOR,""#cookie-control-dialog button.g-button.outline"",)cookie_accept_button.click()exceptNoSuchElementException:passpagination_button=driver.find_element(By.ID,""view-more"")pagination_button.click()time.sleep(0.5)tracks=driver.find_elements(By.CLASS_NAME,""results-grid-item"")print(len(tracks))driver.quit()Here, you’ve usedtime.sleep(0.5)to give Bandcamp time to load the requested tracks.
Thisprobablyworks for you, but how long your code should sleep depends on factors such as internet speed, which you can’t reliably predict.But, while inspecting the page using your developer tools, you identified that theView more resultsbutton isn’t clickable while the page loads more results. It only becomes clickable again once Bandcamp has finished loading the new tracks.Therefore, you can use an explicit wait to wait exactly as long as is necessary:Pythonobservation.py# ...fromselenium.webdriver.support.uiimportWebDriverWaitfromselenium.webdriver.supportimportexpected_conditionsasEC# ...wait=WebDriverWait(driver,10)wait.until(EC.element_to_be_clickable((By.ID,""view-more"")))tracks=driver.find_elements(By.CLASS_NAME,""results-grid-item"")print(len(tracks))driver.quit()You’ve removedtime.sleep(0.5)and replaced it with an explicit wait condition. Specifically, you told Selenium to wait until the element with the idview-more, which is the pagination button, is clickable.In the final codebase, you’ll structure this logic within a dedicated class method. This method will handle the click and then update your list of available tracks.Once the new results have finished loading, you can continue with the code as before—searching for all track elements and printing how many there are before quitting the browser instance.Calling.until()on aWebDriverWaitobject returns the element that Selenium was waiting for, so it’s a common approach to wait for a button to become clickable, and then click it like this:Pythonwait=WebDriverWait(driver,10)pagination_button=wait.until(EC.element_to_be_clickable((By.ID,""view-more"")))pagination_button.click()However, as you’ve seen in the previous example, you can also use explicit waits without interacting with the element they return.Remove adsChoose From Common Expected ConditionsTheexpected_conditionsmodule contains many conditions that yourWebDriverWaitobject can wait on, such as:FunctionDescriptionpresence_of_element_located()Waits for an element to be present in the DOM.visibility_of_element_located()Waits for an element to be present and visible.element_to_be_clickable()Waits for an element to be visible and enabled for clicking.alert_is_present()Waits for a JavaScript alert to appear.title_is()/title_contains()Checks if the page title exactly matches or contains a substring.url_to_be()/url_contains()Verifies that the current URL exactly matches or contains a substring.Check out thedocumentation on expected conditionsfor a full list. If none of the pre-built conditions fit your scenario, then you can also write a custom function.For example, you may want to wait until at least one Bandcamp track has a non-empty text property. You can achieve this by defining a function usingPython’sany()and agenerator expression:Pythonwait=WebDriverWait(driver,10)deftracks_loaded(driver):track_cards=driver.find_elements(By.CLASS_NAME,""results-grid-item"")returnany(card.text.strip()forcardintrack_cards)wait.until(tracks_loaded)After definingtracks_loaded(), you can pass it to.until()as an argument. In this scenario, Selenium proceeds whentracks_loaded()returns a truthy value.Additionally,WebDriverWaitalso supports parameters for setting even more advanced wait conditions that match Java’s fluent wait:timeout: Specifies the number of seconds to wait before timing outpoll_frequency: Specifies how long to wait in between calls and defaults to half a secondignored_exceptions: Specifies which exceptions to ignore during waits and defaults toNoSuchElementExceptiononlyIn the example above, you instantiated aWebDriverWaitobject with atimeoutof10. This means that Selenium will wait until the expected condition is met or ten seconds have passed, whichever happens earlier.Similarly, you could also pass values forpoll_frequencyandignored_exceptionsto customize your explicit wait even more.In most cases, it’s a good idea to work with explicit waits because they let you precisely define what condition you’re waiting for.Handle Synchronization IssuesEven with explicit waits, you can still run into flaky tests or scripts if the site triggers multiple asynchronous events. It’s best to identify the most stable sign that the page is done updating. If you rely on less stable signals, then your script might fail sporadically under a heavier server load.Some websites behave differently when you run a headless browser. For example, certain animations or transitions might run faster—or not at all—in headless mode. If you suspect a bug is related to headless mode, try removing the""--headless""flag to watch what’s actually happening on screen.Sites often display cookie consent pop-ups or promotional overlays, like the one you learned to tacklein an earlier section. As mentioned there, you may need to find the cookie consent button and click it before you can interact with the site underneath.Of course, you can also rely on an explicit wait if the cookie overlay loads asynchronously. This ensures your script doesn’t attempt to click before the overlay is visible.Sites may also trigger JavaScript alerts. You can use built-in Selenium functionality to switch to such alerts and dismiss them. If it’s unreliable whether or not the alert will appear, then you can handle that using atry...exceptblock and aNoAlertPresentException:Pythonfromselenium.common.exceptionsimportNoAlertPresentExceptiontry:alert=driver.switch_to.alertalert.dismiss()# Or alert.accept()exceptNoAlertPresentException:passThis construct utilizes Selenium’s.switch_toproperty. It’ll dismiss a JavaScript alert if the site triggers one. If there’s no alert but you attempt to switch to one, then Selenium will raise aNoAlertPresentExceptionand your code will pass and continue normally.You won’t need to handle these types of alerts for automating your music player.Now that you’ve covered navigating, clicking, entering text, and waiting for content to load, you’re almost ready to put everything together for your Bandcamp-based music player. However, as your code grows, you should avoid stuffing all these selectors and waits into a single file. That’s where thePage Object Model (POM)comes in.In the next section, you’ll learn how the POM helps isolate your interactions with the Discover page from your business logic that decides which track to play. You’ll define Python classes to represent pages and components. This approach keeps your code modular, testable, and better maintainable—even if Bandcamp changes its layout.Remove adsImplement the Page Object Model (POM)As you’ve seen, Selenium can handle just about any web interaction. But if you keep piling all your code into one file, then you’ll end up with a mess of locators, wait statements, and repeated logic. This is where thePage Object Model (POM)shines by separating page structure from business logic.Understand the POM Design PatternPOM is a design pattern where you represent each significant page component with a dedicated class in your code. This class knows how to locate and interact with elements on that specific area. The rest of your application uses these classes without worrying about the underlying selectors or waiting logic that are specific to that element.Implementing the POM for your Selenium applications—whether it’s for automated testing or for other web automation tasks—makes your code more maintainable and stable:[Using Page Objects] reduces the amount of duplicated code and means that if the UI changes, the fix needs only to be applied in one place.(Source)To go about building a Selenium project following the POM, you need to understand the web page, or web pages, that you’ll interact with. A straightforward first step is to create a new class for each separateweb pagethat you’re dealing with. You could add these classes to a module namedpages.py.However, the POM suggests that you primarily focus onpage elements, or panels, more than on full pages:Despite the term “page” object, these objects shouldn’t usually be built for each page, but rather for the significant elements on a page.—Martin Fowler(Source)For any more complex web automation, you’ll need to interact withpartsof a web page rather than a full page. When you model these elements as separate classes, you can test them in isolation.In this tutorial, you’ll add classes that model page elements in a module namedelements.py. If you’re dealing with more complex pages and elements, then it may make sense to create separate modules for each page object that you create. Decide what works best for you—your aim should be to keep your code well-organized and maintainable.Because locators are the most brittle aspect of the application that you’re building, you’ll add locators into a separate module calledlocators.py. Alternatively, you could also include the relevant locators as attributes directly in each page object.Finally, both pages and elements often have abase classthat they inherit from. In this tutorial, you’ll split off these base classes into a separate module calledbase.pythat they’ll share with other basic settings for the web automation part of your music player.When you follow these suggestions, you’ll end up with a basic file structure consisting of four modules and an__init__.pyfile:bandcamp/
├── __init__.py
├── base.py
├── elements.py
├── locators.py
└── pages.pyAdding an__init__.pyfile marksbandcampas a regular Python package that you can reference in imports. You don’t need to add any content to the file for this to work.With this fundamental structure set up, you can start to practice thinking in terms of the POM. Fetch a pen and some paper, open up the Bandcamp Discover page, turn on some new music if you want to, and sketch the significant page components that you’ll want to interact with to build the music player.When you’re done, you can open the collapsible section below to read about the implementation that you’ll build out in the rest of this tutorial:Possible POM Structure for the Bandcamp Music PlayerShow/HideHere are some classes that you could build to split out significant components of the Bandcamp Discover page following the POM:DiscoverPage(inbandcamp/pages.py) represents the full Discover page of Bandcamp. It’ll need methods to accept cookies and expose the list of track items.TrackListElement(inbandcamp/elements.py) represents the grid of track items. It’ll contain methods to load new tracks and to find track items in the DOM.TrackElement(inbandcamp/elements.py) represents a single track item. This object will know how to play and pause a track, and fetch information about the track, such as album, artist, and genre.Note that this isn’t necessarily the only way you could model the Bandcamp Discover page following the POM, but it’s what you’ll keep working with in this tutorial.Note that you’re not yet thinking about the front-end functionality of your music player app. The POM focuses on presenting a middle layer between the UI of your web page and whatever code you’ll stick to the other end. Often, that code will be automated tests for the site. In your case, it’ll be a music player.Remove adsEstablish a Base for Pages and ElementsA good first step is to createbase classesthat all your page and element classes will inherit from. In this project, you’ll place this code into a separate file,base.py. However, you could also keep a base class for pages inpages.py, and a base class for elements inelements.py.Note:Remember to create the files in this section inside a package you namebandcamp, like shown in the folder structure further up.The base classes should handle setup logic that applies to all child elements, such as setting a viewport size and initializing aWebDriverWaitobject:Pythonbandcamp/base.pyfromselenium.webdriver.remote.webdriverimportWebDriverfromselenium.webdriver.remote.webelementimportWebElementfromselenium.webdriver.support.waitimportWebDriverWaitMAX_WAIT_SECONDS=10.0DEFAULT_WINDOW_SIZE=(1920,3000)classWebPage:def__init__(self,driver:WebDriver)->None:self._driver=driverself._driver.set_window_size(*DEFAULT_WINDOW_SIZE)self._driver.implicitly_wait(5)self._wait=WebDriverWait(driver,MAX_WAIT_SECONDS)classWebComponent(WebPage):def__init__(self,parent:WebElement,driver:WebDriver)->None:super().__init__(driver)self._parent=parentIn this initial version ofbase.py, you define two classes:WebPageandWebComponent.WebPagefunctions as the base class. Using twoconstants, it fixes the browser window size to a  larger area to fit more items, and initializes aWebDriverWaitobject with a maximum wait time of ten seconds.Note:While using one default setup forWebDriverWaitworks in this example, you may need differently initialized wait objects for more complex scenarios. For example, if you’re dealing with a brittle element that requires you to ignore certain exceptions, or adapt the polling frequency.The second class,WebComponent, retains a reference to a parentWebElementin addition to inheriting the same driver and wait object fromWebPage. You’re importing theWebElementclass fromwebelementso you can properlytype hinttheparentparameter. To avoid confusion with this Selenium-provided class, you name your base class for your web elementsWebComponentinstead.Using abase.pymodule can help you keep shared logic like waiting or standard properties in one place, if that’s a good fit for your project. Keep in mind that some more complex web automation or testing scenarios may require you to set up custom wait logic for different page objects.Describe Your Web Page as a Page ObjectNow it’s time to think about the structure of the specific page that you want to test or automate. In your case, that’s the Bandcamp Discover page. But you won’t needeverythingthat’s on the website. Take another look at the live page and consider what you really need to model in this high-level page object that represents the overall Discover page.You want to play music, so you need access to the tracks. Also, you may need to deal with a cookie consent form. In the code below, you identify the track list container and implement logic to dismiss the cookie consent form:Pythonbandcamp/pages.py1fromselenium.common.exceptionsimportNoSuchElementException2fromselenium.webdriver.remote.webdriverimportWebDriver34frombandcamp.baseimportWebPage5frombandcamp.elementsimportTrackListElement6frombandcamp.locatorsimportDiscoverPageLocator78classDiscoverPage(WebPage):9""""""Model the relevant parts of the Bandcamp Discover page.""""""1011def__init__(self,driver:WebDriver)->None:12super().__init__(driver)13self._accept_cookie_consent()14self.discover_tracklist=TrackListElement(15self._driver.find_element(*DiscoverPageLocator.DISCOVER_RESULTS),16self._driver,17)1819def_accept_cookie_consent(self)->None:20""""""Accept the necessary cookie consent.""""""21try:22self._driver.find_element(23*DiscoverPageLocator.COOKIE_ACCEPT_NECESSARY24).click()25exceptNoSuchElementException:26passYou reuse theWebPagebase class that you set up inbase.pyand allow your newDiscoverPageto inherit from it. That gives you access to a web driver asself._driverand an explicit wait asself._wait.When you instantiateDiscoverPage, it automatically clicks theAccept necessary cookiesbutton if it’s present, then sets up aTrackListElement. This is a natural, real-world representation of the page with a track list.Because the track list is a significant element on the Discover page, it deserves its own page object.Note:If usingpagein this context bothers you, you’re in good company and can think of it as apanel objectinstead.You’ll model page elements in a dedicated file,elements.py, so both the import on line 5 as well as the instantiation ofTrackListElementon lines 14 to 17 are just promises of code-to-be for now.Similarly, so are the references toDiscoverPageLocatorin yourlocatorsmodule and its use in the helper method._accept_cookie_consent(). But don’t worry, you’ll address all of this in just a moment!For now, you can revel in the accomplishment of describing the parts of Bandcamp’s Discover page that are relevant for your music player as a true page object!Define Reusable Web ElementsOnward toelements.py, which is where most of the POM-related abstraction of this Selenium project takes place. Again, you can take a step back and consider which elements on the page are significant for interaction. Two elements stand out:TrackListElementmodels the container element that harbors all the music tracks, and the button to load more results.TrackElementmodels a single music track and should allow you to play and pause tracks, as well as fetch track information.Starting with theTrackListElement, it needs to remember which tracks are available, and it needs functionality to load additional tracks:Pythonbandcamp/elements.pyfromselenium.webdriver.remote.webdriverimportWebDriverfromselenium.webdriver.remote.webelementimportWebElementfromselenium.webdriver.supportimportexpected_conditionsasECfrombandcamp.baseimportWebComponentfrombandcamp.locatorsimportTrackListLocatorclassTrackListElement(WebComponent):""""""Model the track list on Bandcamp's Discover page.""""""def__init__(self,parent:WebElement,driver:WebDriver=None)->None:super().__init__(parent,driver)self.available_tracks=self._get_available_tracks()defload_more(self)->None:""""""Load additional tracks.""""""view_more_button=self._driver.find_element(*TrackListLocator.PAGINATION_BUTTON)view_more_button.click()# The button is disabled until all new tracks are loaded.self._wait.until(EC.element_to_be_clickable(TrackListLocator.PAGINATION_BUTTON))self.available_tracks=self._get_available_tracks()def_get_available_tracks(self)->list:""""""Find all currently available tracks.""""""self._wait.until(self._track_text_loaded,message=""Timeout waiting for track text to load"",)all_tracks=self._driver.find_elements(*TrackListLocator.ITEM)# Filter tracks that are displayed and have text.return[TrackElement(track,self._driver)fortrackinall_tracksiftrack.is_displayed()andtrack.text.strip()]def_track_text_loaded(self,driver):""""""Check if the track text has loaded.""""""returnany(e.is_displayed()ande.text.strip()foreindriver.find_elements(*TrackListLocator.ITEM))You’ve implemented the track list as a page object. In this code, you set up a list of tracks, each represented by aTrackElement. You’ll write code for this final page object next. You also set up some sanity checks, to confirm that tracks are displayed and contain at least some text.While this may look like a lot of code, you’ve already encountered and reasoned about much of it before! In previous sections, you’ve implemented the same functionality to load additional tracks into view that you’ve now packaged into.load_more(). After firstlocatingthe right button, youclick it, and then use anexplicit waitto pause until all new tracks are loaded.Earlier, you also searched for tracks. Now, you’ve added some checks to confirm that these tracks have a play button, are displayed, and contain at least some text. You’ve also seen similar code in the custom wait condition of._track_text_loaded()when learning aboutexpected conditions. It’s great to see it all coming together!WithTrackListElementset up you’re more than halfway there. Next, you’ll set up the missingTrackElementto model individual track panels. In your POM classes, you define methods that represent user actions. For example, theTrackElementmight have.play()and.pause()methods:Pythonbandcamp/elements.py# ...frombandcamp.locatorsimportTrackListLocator,TrackLocator# ...classTrackElement(WebComponent):""""""Model a playable track on Bandcamp's Discover page.""""""defplay(self)->None:""""""Play the track.""""""ifnotself.is_playing:self._get_play_button().click()defpause(self)->None:""""""Pause the track.""""""ifself.is_playing:self._get_play_button().click()@propertydefis_playing(self)->bool:return""Pause""inself._get_play_button().get_attribute(""aria-label"")def_get_play_button(self):returnself._parent.find_element(*TrackLocator.PLAY_BUTTON)By adding this code, you model a track element and expose the most important interactions with it—pressingplayto start the song, andpauseto stop it. To round off the logic, you add._is_playingas a property, and._get_play_button()as a helper method that locates and returns the play button in a track element.Notice that._get_play_button()usesself._parent.find_element(). BecauseTrackElementinherits fromWebComponent, it has a._parentattribute and its parent is the track’s container, not the entire page. This method encapsulateshowyou play a track, leaving your higher-level code to simply call.play()on aTrackElement.Finally, you also want to be able to access information about each track. TheTrackElementpage object is the right place for setting up that logic as well:Pythonbandcamp/elements.py1fromselenium.common.exceptionsimportNoSuchElementException23# ...45classTrackElement(WebComponent):6# ...78def_get_track_info(self)->dict:9""""""Create a representation of the track's relevant information.""""""10full_url=self._parent.find_element(*TrackLocator.URL).get_attribute(11""href""12)13# Cut off the referrer query parameter14clean_url=full_url.split(""?"")[0]iffull_urlelse""""15# Some tracks don't have a genre16try:17genre=self._parent.find_element(*TrackLocator.GENRE).text18exceptNoSuchElementException:19genre=""""20return{21""album"":self._parent.find_element(*TrackLocator.ALBUM).text,22""artist"":self._parent.find_element(*TrackLocator.ARTIST).text,23""genre"":genre,24""url"":clean_url,25}You set up another helper method that identifies the album, artist, genre, and album URL. Because not all artists like to see their music shoved into genre boxes, Bandcamp apparently made adding genres optional. Your code must account for that, so you set up anothertry...exceptblock that adds an empty string if there’s no genre information provided.You also use aconditional expressionin line 14 to cut off a possible referrer query parameter and display a clean URL to the album page.Great! With this addition, you’ve finished setting up bothpages.pyandelements.py, actively implementing the POM in your web automation design. But there’s still one promise left to fulfill. You need to filllocators.pyto allow all your page objects to utilize the locators they so sorely need to findanythingon the page.Keep Locators SeparateLocators are one of the most brittle aspects in web automation. They can quickly change, so it’s good practice to store locators in a dedicated file. That way, if a CSS selector or ID changes on the page—and they will—then you only need to look in one place to fix it.You’ve already used theunpacking operator syntaxtogether with some descriptive class names in the code you previously wrote. Now, it’s time to give*TrackLocator.ARTISTsome meaning by setting up the classes andclass attributesthat you targeted with that code:Pythonbandcamp/locators.pyfromselenium.webdriver.common.byimportByclassDiscoverPageLocator:DISCOVER_RESULTS=(By.CLASS_NAME,""results-grid"")COOKIE_ACCEPT_NECESSARY=(By.CSS_SELECTOR,""#cookie-control-dialog button.g-button.outline"",)classTrackListLocator:ITEM=(By.CLASS_NAME,""results-grid-item"")PAGINATION_BUTTON=(By.ID,""view-more"")classTrackLocator:PLAY_BUTTON=(By.CSS_SELECTOR,""button.play-pause-button"")URL=(By.CSS_SELECTOR,""div.meta p a"")ALBUM=(By.CSS_SELECTOR,""div.meta p a strong"")GENRE=(By.CSS_SELECTOR,""div.meta p.genre"")ARTIST=(By.CSS_SELECTOR,""div.meta p a span"")In this example implementation, you store the relevant locators in classes that you name after the corresponding page objects you defined. You store them astuplesof two elements each. The first element records which locator strategy you use and the second element is the locator string.This allows you to use the unpacking operator to provide both as arguments to.find_element()and related methods.Note:It’s not necessary to wrap your locators into classes, and you may see them also defined as globalconstantsin other Selenium projects.However, using descriptively named classes that reference your page objects adds another layer of structure and improves maintainability.Now, all your locators live in a single place! What bliss! You now only need to go updatelocators.pywhen Bandcamp decides to move track elements into a different container.Your code can continue to referenceDiscoverPageLocator.DISCOVER_RESULTSwherever it needs to find that container, even if it’s used in multiple places. You won’t need to hunt down locators scattered throughout your increasingly complex Selenium codebase. This approach improves maintainability and is self-documenting, so your colleagues will send you appreciative letters for years to come.Enjoy the Benefits of the POM in PracticeNow that you’ve modeled all the page elements that you need for this project following the POM, you can give it a spin to enjoy the abstraction that this setup offers you. Navigate to the parent folder that also contains yourbandcampmodule, then start a new REPL session and play a song:Python>>>fromselenium.webdriverimportFirefox>>>frombandcamp.pagesimportDiscoverPage>>>BANDCAMP_DISCOVER_URL=""https://bandcamp.com/discover/"">>>driver=Firefox()>>>driver.get(BANDCAMP_DISCOVER_URL)>>>page=DiscoverPage(driver)>>>track_1=page.discover_tracklist.available_tracks[0]>>>track_1.play()>>>track_1.pause()>>>page._driver.quit()This code keeps the head on your browser so that you can see your automation in practice. Selenium will open a new window when you instantiateFirefox, then navigate to the Discover page when you call.get()on it.Next, you start using your page objects by instantiatingDiscoverPage. You can now access all available tracks by stepping through.discover_tracklist, which is aTrackListElement, and indexing into its.available_trackslist. You pick the firstTrackElementand call.play()on it. You can watch as your browser instance clicks on the play button, and the music starts playing!When you follow the Page Object Model design pattern for your Selenium projects, you can avoid duplicating logic for actions that a user may take on the site you’re automating.In your Bandcamp music player, it means that you’ve defined a central place for playing, pausing, or loading more tracks. If Bandcamp changes the class name of the container that holds the tracks, for example, then you just updateDiscoverPageLocator.DISCOVER_RESULTSinlocators.py. If the track item’s HTML changes, then you adjustTrackLocatorinelements.py.Meanwhile, you could still use the same code you just played with in the REPL session above to play a song. This means that any code you write in your high-level music player can remain the same even if the page changes.The POM approach is especially powerful if you want to add tests to your codebase. For example, you could write tests that verify you can pause a playing track, or that loading more tracks adds new items. Each test can reuse the same page objects, which ensures consistency.Now that your code is structured in a maintainable way, it’s time to build out the final feature, your text-based music player interface that uses these page objects under the hood.You’ll set up one module to orchestrate the Selenium interactions, and another to provide a command-line loop for the user. By the end, you’ll have a project that, when run, launches Firefox headlessly, goes to Bandcamp, and lets you explore and play tracks in your terminal.Build the Music Player AppYou’ve got a robust Page Object Model for interacting with Bandcamp’s Discover page. Now it’s time to assemble the final pieces into a runnable, text-based music player. You want to continue to follow maintainable design patterns, so you’ll split this part of the project into a separate namespace, and divide it into two modules:player.pywill contain the logic for your music player app and utilize the page objects that you defined previously.tui.pywill provide the command-line loop and other functionality that focuses on the display of information.To bundle the logic you wrote for the web automation into a single place, you’ll also introduce two top-level packages:web/for the code you’ve written so far, andapp/for the code you’ll write in this section.Finally, you’ll also create a small__main__.pyfile that’ll serve as the entry point for your project. Go ahead and restructure your project accordingly:bandcamp/
│
├── app/
│   │
│   ├── __init__.py
│   ├── player.py
│   └── tui.py
│
├── web/
│   │
│   ├── __init__.py
│   ├── base.py
│   ├── elements.py
│   ├── locators.py
│   └── pages.py
│
├── __init__.py
└── __main__.pyAfter you’ve restructured the project and added the new, initially empty files, you may need to update someimportsto make your code work together smoothly. Specifically, you’ll need to rename all imports that previously usedbandcamp.moduletobandcamp.web.moduleinpages.pyandelements.py.Note:Someintegrated development environments (IDEs), such asPyCharm, will automatically change these imports for you when you move the files.For convenience, you’ll also set up adata classthat you nameTrackinbase.pyto replace the dictionary thatTrackElementpreviously returned:Pythonbandcamp/web/base.pyfromdataclassesimportdataclassfrompprintimportpformat# ...@dataclassclassTrack:album:strartist:strgenre:strurl:strdef__str__(self):returnpformat(self)# ...With these additions tobase.py, you’ve created a minimal data class that contains all the information you want to collect about a track. Using a data class instead of a dictionary in this case just makes it more straightforward to access and display the track information.Note:To improve the readability of the output when you print aTrack, you’ve also added a custom.__str__()methodthat ensures Python prints each attribute in a separate line. Sure, your music player will be text-based, but you can still make it a bitprettier!Take a side-step intoelements.pyand update the code to use this data class instead:Pythonbandcamp/web/elements.py# ...frombandcamp.web.baseimportWebComponent,Track# ...classTrackElement(WebComponent):# ...def_get_track_info(self)->Track:# ...returnTrack(album=self._parent.find_element(*TrackLocator.ALBUM).text,artist=self._parent.find_element(*TrackLocator.ARTIST).text,genre=genre,url=clean_url,)Here, you’ve updated the import to account for the new structure, addedTrackto it, and replaced the return value ofTrackElementso it builds aTrackfor each element.You can download the finished project code to preview the necessary updates:Get Your Code:Click here to download the free sample codethat shows you how to use Selenium in Python for modern web automation.Now, you’re ready to build the core logic for your music player that utilizes the web automation code that you wrote and structured so beautifully in the previous section.Create Your Music Player ClassFirst comesPlayer, a class that encapsulates the high-level logic of opening the browser, creating aDiscoverPageobject, and providing simple methods like.play()and.pause(). Note that it’s similar to code you wrote in the earlier sections, as well as when you tested your POM structure in the REPL:Pythonbandcamp/app/player.pyfromselenium.webdriverimportFirefoxfromselenium.webdriver.firefox.optionsimportOptionsfrombandcamp.web.pagesimportDiscoverPageBANDCAMP_DISCOVER_URL=""https://bandcamp.com/discover/""classPlayer:""""""Play tracks from Bandcamp's Discover page.""""""def__init__(self)->None:self._driver=self._set_up_driver()self.page=DiscoverPage(self._driver)self.tracklist=self.page.discover_tracklistself._current_track=self.tracklist.available_tracks[0]def__enter__(self):returnselfdef__exit__(self,exc_type,exc_value,exc_tb):""""""Close the headless browser.""""""self._driver.quit()defplay(self,track_number=None):""""""Play the first track, or one of the available numbered tracks.""""""iftrack_number:self._current_track=self.tracklist.available_tracks[track_number-1]self._current_track.play()defpause(self):""""""Pause the current track.""""""self._current_track.pause()def_set_up_driver(self):""""""Create a headless browser pointing to Bandcamp.""""""options=Options()options.add_argument(""--headless"")browser=Firefox(options=options)browser.get(BANDCAMP_DISCOVER_URL)returnbrowserThe music player provides an interface for doing the most important aspects of its purpose, which is playing and pausing tracks through.tracklist.
Sure, this won’t be as engaging or good-looking as a first-generation iPod, but it’ll do the job.ThePlayerclass also handles important set up and tear down logic:Set up: When you instantiate aPlayer, it spins up a headless Firefox browser and navigates to Bandcamp’s Discover page using._set_up_driver(). Then, Python constructs aDiscoverPagepage object and fetches all available tracks throughDiscoverPage.discover_tracklist, and finally sets the current track to the first available item.Tear down: You define the.__enter__()and.__exit__()special methods, which allow you to usePlayerin acontext managerand ensure that the browser closes automatically. No zombie foxes munching on your computer’s RAM!Other than that, you only set up the functionality to play and pause. However,Playerbeing the abstraction that it is allows you to optionally switch tracks by indexing into the.available_trackslist using.play()and passing it an integer. Then, it calls the.play()method on that specificTrackElement. Similarly,.pause()calls.pause()on the current track element.Because you’ve already done the heavy lifting in your POM classes,Playercan remain clean. Aside from opening and closing the headless browser, you defer all other interactions through theDiscoverPageobject.This is a high-level abstraction that makes sense. As a user, you’d also start by navigating to the main page and then use the interaction possibilities that the site offers. Because of the POM, you don’t need any raw selectors or waiting logic inplayer.py—those are hidden in the page object layers.Assemble a Text-Based User InterfaceWith the logic in place, you only need to define the interface that you’ll use to interact with the page. This code will essentially be the front end of your music player. There are many third-party libraries available that allow you to build beautiful text-based user interfaces (TUIs) using Python.To keep the scope smaller, you’ll stick with plain Python in this tutorial. But feel free to enhance your music player with a more advanced interface—like usingTextual—if you’d like to take it further.Start by defining the high-level interactions ininteract(). The user interactions that you’ll define are a good use case for Python’sstructural pattern matching:Pythonbandcamp/app/tui.pyfrombandcamp.app.playerimportPlayerMAX_TRACKS=100# Allows to load more tracks once.definteract():""""""Control the player through user interactions.""""""withPlayer()asplayer:whileTrue:print(""\nType: play [<track number>] | pause | tracks | more | exit"")matchinput(""> "").strip().lower().split():case[""play""]:play(player)case[""play"",track]:try:track_number=int(track)play(player,track_number)exceptValueError:print(""Please provide a valid track number."")case[""pause""]:pause(player)case[""tracks""]:display_tracks(player)case[""more""]iflen(player.tracklist.available_tracks)>=MAX_TRACKS:print(""Can't load more tracks. Pick one from the track list."")case[""more""]:player.tracklist.load_more()display_tracks(player)case[""exit""]:print(""Exiting the player..."")breakcase_:print(""Unknown command. Try again."")Withininteract()you usePlayeras a context manager. Remember that this is possible because you defined.__enter__()and.__exit__()in that class. UsingPlayeras a context manager ensures that Python will close the headless browser when it exits the context manager.Then, you set up anindefinite iterationusingwhile True, which starts by printing the options that exist for interacting with the music player.You then usematchto capture the user input that you sanitize with.strip()and.lower(), and that yousplitinto separate items to account for the possibility that users enterplayfollowed by a track number.Then, you add a number ofcasestatements that use structural pattern matching to correctly route the possible commands to the intended functionality. Note that you haven’t written some of these functions yet.Your code also does a couple of sanity checks and usescase _as the final catch-all for any unwanted inputs. The interactive loop continues until the user typesexit.You’ll next need to set up the missing functionsplay()andpause(), which mainly hand functionality over to theplayerinstance:Pythonbandcamp/app/tui.py# ...defplay(player,track_number=None):""""""Play a track and show info about the track.""""""try:player.play(track_number)print(player._current_track._get_track_info())exceptIndexError:print(""Please provide a valid track number. """"You can list available tracks with `tracks`."")defpause(player):""""""Pause the current track.""""""player.pause()In addition to callingplayer.pause()andplayer.play(), theplay()function of your TUI also checks whether the number entered is available as an index in your player’s tracklist and prints a representation of the playing track to the console.Note:Currently, the interaction allows you to use negative indices to play tracks. That can be helpful—or unnecessary—so feel free to add more input validation to your liking.Finally, you need a way to represent the list of available songs in your TUI. For this, you’ll definedisplay_tracks()to neatly print all discovered tracks in a tabular style:Pythonbandcamp/app/tui.py1# ...23COLUMN_WIDTH=CW=3045# ...67defdisplay_tracks(player):8""""""Display information about the currently playable tracks.""""""9header=f""{'#':<5}{'Album':<{CW}}{'Artist':<{CW}}{'Genre':<{CW}}""10print(header)11print(""-""*80)12fortrack_number,track_elementinenumerate(13player.tracklist.available_tracks,start=114):15track=track_element._get_track_info()16album=_truncate(track.album,CW)17artist=_truncate(track.artist,CW)18genre=_truncate(track.genre,CW)19print(20f""{track_number:<5}{album:<{CW}}{artist:<{CW}}{genre:<{CW}}""21)222324def_truncate(text,width):25""""""Truncate track information.""""""26returntext[:width-3]+""...""iflen(text)>widthelsetextIn this code, you usef-stringsto set up a column header in line 9 andinterpolatethe track information pieces for each track as a line item.Note how you’re usingCWas a shortcut for the constantCOLUMN_WIDTHin order to set up consistently sized cells using Python’sformat mini-language. You also use a helper function._truncate()to abbreviate longer pieces of information.To display each available track, you iterate over.available_tracks, which is an attribute on yourTrackListElementand contains all currently playableTrackElementobjects. But of course, your code intui.pydoesn’t need to know much about these page objects, other than their attributes and methods.Make Your App ExecutableFinally, you package your script with a__main__.pyfile that calls theinteract()function:Pythonbandcamp/__main__.pyfrombandcamp.app.tuiimportinteractdefmain():""""""Provide the main entry point for the app.""""""interact()As thedocstringexplains, this file is the entry point for your entire application. To follow best practices, you should also set up apyproject.tomlfileand declare the entry point:TOMLpyproject.toml[build-system]requires=[""setuptools"",""wheel""]build-backend=""setuptools.build_meta""[project]name=""bandcamp_player""version=""0.1.0""requires-python="">=3.10""description=""A web player for Bandcamp using Selenium""dependencies=[""selenium"",][project.scripts]discover=""bandcamp.__main__:main""Move this file so that it lives in the same folder as yourbandcamppackage:./
│
├── bandcamp/
│
└── pyproject.tomlThis way, it’ll correctly find the entry-point script with the given setting.Withpyproject.tomlset up, you can now install the package locally and run the music player using the command you define in[project.scripts]:Shell(venv)$python-mpipinstall....(venv)$discoverIf you set up everything correctly, then you’ll get to see and interact with your very own Bandcamp Discover music player:TextType: play [<track number>] | pause | tracks | more | exit
>Typetracksto see a list of available tracks. Then typeplay 3to start playing the third track. Typepauseto pause, ormoreto load additional tracks if you want to see a bigger list. Finally, to quit, typeexit.But you don’t need to exit the player yet. You can stick around for a while and discover some new music. That was the whole point of building this music player after all!Next StepsYou’ve built a fun, fully operational command-line music player that quietly runs a real Firefox session in the background. Pretty cool! You’ve also nearly reached the end of this tutorial—phew! However, that doesn’t need to be the end of your music player. Now that you have a working first version, you could expand it in different ways:Search by genre: Automate clicking a specific genre filter.Test: Add tests usingpytestorunittestthat validate the track list loads, or that theplaycommand works.Add a rich TUI: Use a more advanced text-based UI library, such asTextual, to add color or interactive menus.Your Bandcamp player is just one example of how Selenium can automate a website for fun or practical workflows. By following best practices in Selenium development, such as implementing the Page Object Model design pattern, you’ve developed a codebase that’s both approachable and powerful. Without too much effort, you can now add more features or integrate a test suite.ConclusionIn this tutorial, you’ve learned how to use Python and Selenium to automate web interactions and create a functional, text-based music player that interacts with Bandcamp’s Discover page. You explored essential concepts such as navigating web pages, locating and interacting with elements, handling dynamic content, and structuring your code using the Page Object Model (POM) for maintainability and scalability.Understanding web automation opens up a wide range of possibilities, from testing web applications to scraping data and automating repetitive tasks. Learning to effectively automate web interactions can significantly enhance your efficiency and productivity.In this tutorial, you’ve learned how to:Set up and configureSelenium for web automationwith Python.Locate and interact with web elementsusing different strategies.Handle dynamic contentwith explicit waits and expected conditions.Implement the Page Object Modelto organize and maintain your automation code.Build a functionalcommand-line music playeron top of your web automation project.You may often need to replicate user behavior in a browser, and with these skills, you can now automate complex web interactions and build robust automation scripts. Selenium is widely used for automated testing in quality assurance and web scraping, but it’s also helpful for tasks like verifying SEO metadata, generating screenshots, or even filling out complicated forms. Once you master the fundamentals, the only limit is your imagination.Keep exploring theSelenium documentation, and you’ll find even more advanced techniques—like orchestrating multiple browsers, capturing network logs, or integrating with headless testing frameworks. But for now, take a moment to tune into Bandcamp using the interactive music player you built, powered by Selenium and Python.Get Your Code:Click here to download the free sample codethat shows you how to use Selenium in Python for modern web automation.Frequently Asked QuestionsNow that you have some experience using Selenium for web automation in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What is Selenium used for in Python?Show/HideYou use Selenium in Python to automate interactions with web browsers, allowing you to perform tasks like filling forms, clicking buttons, scraping data, and writing automated tests for web applications.How do you set up Selenium with Python?Show/HideYou set up Selenium with Python by installing theseleniumpackage usingpip, downloading the appropriate WebDriver for your browser, and configuring your environment to recognize the WebDriver.How do you create a headless browser in Selenium?Show/HideYou create a headless browser in Selenium by configuring your WebDriver options to run the browser without a visible interface using the""--headless""argument.How do you use Selenium for web scraping?Show/HideYou use Selenium for web scraping by navigating to web pages, locating elements using various selectors, and extracting the desired data while handling dynamic content and JavaScript-generated elements.How can you interact with dynamic web content using Selenium?Show/HideYou can interact with dynamic web content in Selenium by using explicit waits to ensure that elements are present and ready before interacting with them. This helps you avoid errors caused by trying to access elements that haven’t loaded yet.What is the Page Object Model?Show/HideThe Page Object Model (POM) is a design pattern often used in web automation projects. It helps to structure your code by representing each significant page component as a class, separating the page structure from the business logic for better maintainability.What are the different types of waits in Selenium?Show/HideIn Selenium, you can use implicit waits as a browser-wide setting to poll the DOM. You set up explicit waits throughWebDriverWaitobjects, which allow for more flexible and targeted waiting conditions. Fluent waits are available in the Java implementation of Selenium. In Python, you can reproduce their functionality by passing arguments when instantiating aWebDriverWaitobject.Take the Quiz:Test your knowledge with our interactive “Web Automation With Python and Selenium” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizWeb Automation With Python and SeleniumIn this quiz, you'll test your understanding of using Selenium with Python for web automation. You'll revisit concepts like launching browsers, interacting with web elements, handling dynamic content, and implementing the Page Object Model (POM) design pattern.Mark as CompletedShare"
Thread Safety in Python: Locks and Other Techniques,https://realpython.com/courses/thread-safety-locks-other-techniques/,"Apr 29, 2025",38m,"intermediate, python","Threads share state in your programs, which means race conditions can be created when two or more threads fight to update a value. This course is about the various primitives you can use to ensure atomic access to your program’s shared state.By the end of this video course, you’ll be able to identify safety issues and prevent them by using the synchronization primitives in Python’sthreadingmodule to make your code thread-safe.In this video course, you’ll learn:Whatthread safetyisWhatrace conditionsare and how to avoid themHow to identifythread safety issuesin your codeWhat differentsynchronization primitivesexist in thethreadingmoduleHow to use synchronization primitives tomake your code thread-safeWhat’s Included:10 LessonsVideo Subtitles and Full Transcripts2 Downloadable ResourcesAccompanying Text-Based TutorialInteractive Quiz to Check Your ProgressQ&A With Python Experts: Ask a QuestionCertificate of CompletionDownloadable Resources:Course Slides (.pdf)Sample Code (.zip)Related Learning Paths:Concurrency and Async Programming"
Managing Python Projects With uv: An All-in-One Solution,https://realpython.com/python-uv/,"Apr 28, 2025",N/A,"intermediate, tools","Table of ContentsGetting to Know uv for PythonInstalling uv to Manage Python ProjectsUsing the Standalone InstallerInstalling From PyPIUpgrading to the Latest uv VersionHandling Python Projects With uvCreating a Python ProjectRunning the Project’s Entry-Point ScriptUsing uv for Dependency ManagementAdding and Installing DependenciesUpgrading and Removing DependenciesManaging Development DependenciesLocking and Syncing the EnvironmentBuilding and Publishing PackagesConfiguring the ProjectBuilding a DistributionPublishing a DistributionConclusionFrequently Asked QuestionsRemove adsThe uv tool is a high-speed package and project manager for Python. It’s written in Rust and designed to streamline your workflow. It offers fast dependency installation and integrates various functionalities into a single tool.With uv, you can install and manage multiple Python versions, create virtual environments, efficiently handle project dependencies, reproduce working environments, and even build and publish a project. These capabilities make uv an all-in-one tool for Python project management.By the end of this tutorial, you’ll understand that:uv is a Python package and project managerthat integrates multiple functionalities into one tool, offering a comprehensive solution for managing Python projects.uv is used for fast dependency installation, virtual environment management, Python version management, and project initialization, enhancing productivity and efficiency.uv can build and publish Python packagesto package repositories like PyPI, supporting a streamlined process from development to distribution.uv automatically handles virtual environments, creating and managing them as needed to ensure clean and isolated project dependencies.To dive deeper into managing your Python projects efficiently with uv, you should have a basic understanding of using Python virtual environments, setting uppyproject.tomlfiles for projects, and building distributable packages for a project.Get Your Code:Click here to download the free sample codeyou’ll use to learn about managing Python projects with uv.Take the Quiz:Test your knowledge with our interactive “Managing Python Projects With uv: An All-in-One Solution” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizManaging Python Projects With uv: An All-in-One SolutionIn this quiz, you'll test your understanding of the uv tool, a high-speed package and project manager for Python.Getting to Know uv for PythonRecently, a few exciting tools built with theRustprogramming language have appeared in the Python tooling ecosystem.Ruff—a linter and code formatter for Python—is a well-known and popular example of one of these tools.In this tutorial, you’ll explore another cool tool made with Rust for Python. You’ll get to knowuv, an extremely fast Pythonpackage and project manager.The main idea behind these tools is to accelerate your Python workflow by speeding up your project management actions. For example, Ruff is 10 to 100 times faster than linters likeFlake8and code formatters likeBlack. Similarly, for package installation, uv is10 to 100 times fasterthanpip.Additionally, uv integrates into one tool most of the functionality provided by tools likepip,pip-tools,pipx,poetry,pyenv,twine,virtualenv, and more. Therefore, uv is an all-in-one solution.Here’s a quick list of key uv features for managing your Python projects:Fast dependency installation: Installs dependencies really fast, which is especially useful for large dependency trees.Virtual environment management: Automatically creates and managesvirtual environments.Python version management: Allows the installation and management of multiple Python versions.Project initialization: Scaffolds a full Python project, including the root directory,Gitrepository, virtual environment,pyproject.toml,README, and more.Dependency management: Installs, updates, removes, and locks direct andtransitive dependencies, which allows for environment reproducibility.Package builds and publication management: Allows you to build and publish packages to package repositories like thePython Package Index (PyPI).Developer tooling support: Installs and lets you run development tools, such aspytest, Black, and Ruff.Apart from these features, uv is a standalone binary that allows for a smooth installation and quick upgrades. You don’t need to have Python installed on your system to install uv.So, with this quick summary of uv and its main features, you’re ready to install this tool on your system. That’s what you’ll do in the following section. Additionally, you’ll learn how to update your uv installation.Remove adsInstalling uv to Manage Python ProjectsThe first step in using any tool is to install it on your operating system. To install uv, you have several options. The quickest one would be to use the standalone installer. Another friendly option is to install uv fromPyPIusing other tools likepipxorpip.In the officialuv installation guide, you’ll find several other installation options. For example, you can use tools likeHomebrewandCargo, depending on your current platform and operating system. However, in this tutorial, you’ll only explore the standalone installer and the PyPI options.Using the Standalone InstallerThe uv project provides a standalone installer that you can use to download and install the tool in your system. Below are the relevant commands for the three main operating systems:WindowsLinux + macOSWindows PowerShellPS>powershell-ExecutionPolicyByPass-c""irm https://astral.sh/uv/install.ps1 | iex""Shell$curl-LsSfhttps://astral.sh/uv/install.sh|shIf you don’t havecurlinstalled on your system, then you can usewgetas shown below:Shell$wget-qO-https://astral.sh/uv/install.sh|shThese commands will download and install the latest binary of uv in your system. If you’d like to install a specific version of the tool instead of the latest, then you can add the version number to the download URL right after theuv/part:WindowsLinux + macOShttps://astral.sh/uv/0.6.12/install.ps1https://astral.sh/uv/0.6.12/install.shWith this addition to the download URL, you request the installation of uv version0.6.12. Once you’ve downloaded and installed uv with the appropriate command, you can verify the installation by running the following command:Shell$uv--versionuv 0.6.12 (e4e03833f 2025-04-02)Now you’re all set up with uv. In this case, you’re using version0.6.12. Of course, your specific version may differ slightly depending on when you read this tutorial.You can run theuv --helpcommand at any time to display the help page, which provides detailed information about each command and option the tool offers. Go ahead and give it a try!Installing From PyPIYou can also install uv from thePython Package Index (PyPI)usingpipx. As with the standalone installer, the uvcommand-line-interface (CLI)will be available globally on your system.To install uv usingpipx, run the following command:Shell$pipxinstalluvNote that for this command to work, you needpipxto be available in your environment. This involves an extra step. If you don’t want to install an additional app, then you can usepip, which is typically shipped by default with most Python distributions.However, to have system-wide access to uv, you’ll have to install it in your Python system installation. This isn’t recommended because it could clutter your system with packages that you may not use.Remove adsUpgrading to the Latest uv VersionAs you know, time flies. The uv project is currently under active development, which means that new versions are released regularly.If you’ve installed uv using thestandalone installerand would like to be up to date with the latest version, then you can run the following command:Shell$uvselfupdateinfo: Checking for updates...success: Upgraded uv from v0.6.10 to v0.6.12!⮑ https://github.com/astral-sh/uv/releases/tag/0.6.12Theuv self updatecommand checks whether a new version is available. If that’s the case, the command downloads the new package and installs it for you.If you’ve installed uv withpipxand want to upgrade it, then you can run the command below:Shell$pipxupgradeuvThis command allows you to upgrade your uv installation to the latest version if you usedpipx.Handling Python Projects With uvNow comes the fun part—the part where you create and manage a Python project with uv. In this section, you’ll explore the uv features and commands that allow you to do this quickly and efficiently.For this section and the rest of the tutorial, you’ll use a sample CLI application that retrieves cat information from theCat API.Click theShow/Hidetoggle below to reveal the app’s code:Cats CLI AppShow/HidePythonmain.pyimportargparseimportsysimportrequestsdefget_breeds_info():response=requests.get(""https://api.thecatapi.com/v1/breeds"")response.raise_for_status()returnresponse.json()deffind_breed_info(breed_name):json_response=get_breeds_info()forbreedinjson_response:ifbreed[""name""]==breed_name:returnbreedreturnNonedefdisplay_breed_profile(breed):print(f""\n{breed['name']:-^30s}"")print(f""Origin:{breed['origin']}"")print(f""Temperament:{breed['temperament']}"")print(f""Life Span:{breed['life_span']}years"")print(f""Weight:{breed['weight']['imperial']}lbs"")ifbreed.get(""wikipedia_url""):print(f""\nLearn more:{breed['wikipedia_url']}"")defparse_args():parser=argparse.ArgumentParser(description=""Get information about cat breeds"")parser.add_argument(""breed"",help=""Name of cat breed (e.g., 'Siamese')"",)returnparser.parse_args()defmain():args=parse_args()try:breed=find_breed_info(args.breed)ifnotbreed:print(""Breed not found. Try another breed name."")return0display_breed_profile(breed)exceptExceptionase:print(f""Error:{e}"")return1return0if__name__==""__main__"":sys.exit(main())Keep this code handy! You’ll use it to spice up your first Python project with uv. Are you ready?Creating a Python ProjectTo create and initialize a Python project with uv, navigate to the directory where you want to store the project. Once there, you can run the following command to create and initialize the project:Shell$uvinitrpcatsNote that the project name is up to you. In this example, you’ll userpcatsto denote that this is a Real Python project for retrieving and displaying information about cats.The command above creates the following directory structure under therpcats/folder:rpcats/
│
├── .git/
│
├── .gitignore
├── .python-version
├── README.md
├── main.py
└── pyproject.tomlThis is cool! First, you have the.git/directory, which is the Git repository for your project. The.gitignorefile allows you to define the files and folders you want to skip in your version control workflow. By default, uv automatically populates this file with sensible entries for most Python projects, ensuring that unwanted files are excluded from version control.The.python-versionfile contains the default Python version for the current project. This file tells uv which Python version to use when creating a dedicated virtual environment for the project. Next, you have an emptyREADME.mdfile that you can use to provide basic documentation for your project.Themain.pyfile is a placeholder Python file that initially contains the following code:Pythondefmain():print(""Hello from rpcats!"")if__name__==""__main__"":main()In this case, you have amain()function that prints a message to the screen. At the bottom of the file, you have the well-knownif __name__ == ""__main__""idiom, which is common practice in executable files like this one.Finally, you have thepyproject.tomlfile with the following initial content:TOML[project]name=""rpcats""version=""0.1.0""description=""Add your description here""readme=""README.md""requires-python="">=3.13""dependencies=[]This file contains basic configuration key-value pairs under the[project]table. You can update the value of any key to meet your requirements. For example, you can change thedescriptionto something like the following:TOML[project]name=""rpcats""version=""0.1.0""description=""Display cat information for the specified breed.""readme=""README.md""requires-python="">=3.13""dependencies=[]Now, your project has a concrete description. You could also change the project’s version, the required Python version, and so on.Note:If you want to start managing an existing project with uv, then navigate to the project directory and run the following command:Shell$uvinitThis command will create the uv project structure for you. It won’t overwrite themain.pyfile if you have one, but it’ll create the file if it’s missing. It neither modifies your Git repository nor yourREADME.mdfile.However, this command won’t work if you already have apyproject.tomlfile in place. If that’s the case, then you can move the file to another location and run theuv initcommand. Finally, you can update the new file with any relevant configuration from your oldpyproject.toml.That’s it! You’ve created your first project with uv. Now you can run the project’s entry-point script,main.py, to check that everything’s working correctly.Remove adsRunning the Project’s Entry-Point ScriptOnce you’ve created the project, you can use uv to run the entry-point script, which is themain.pyfile by default. To run the script, go ahead and execute the following command:Shell$uvrunmain.pyUsing CPython 3.13.2Creating virtual environment at: .venvHello from rpcats!The first time you run this command, it’ll display the Python version you’re currently using for the project. It’ll also inform you that uv has created a dedicated Python virtual environment for the project. The final output line shows the message that results from calling themain()function defined inmain.py.Note:You can change the entry-point script’s name and location at any time. Naming itmain.pyisn’t mandatory.If you check the content of your project’s root directory again, then you’ll find a.venvfolder containing the dedicated virtual environment. You’ll also find a new file calleduv.lock, which is a cross-platformlockfilethat contains information about your project’s dependencies. This file ensures that other developers can quickly and exactly reproduce your working environment. This enhances team collaboration and code contributions.Unlikepyproject.toml, which usually specifies the direct dependencies of your project, theuv.lockfile contains the exact versions of any dependency installed in the project environment.Theuv.lockfile uses theTOMLformat. You should add this file to version control. However, you shouldn’t edit this file manually. Instead, you can let uv take care of it. You’ll learn more about this file in a moment.Using uv for Dependency ManagementWhen it comes to managing your project’s dependencies, uv makes your life easier with a clean workflow. This workflow allows you to lock your project’s dependencies so that other developers can reproduce your environment exactly and contribute to your code without much setup effort.In the following sections, you’ll learn the basic uv commands that you should use to install, update, and remove external packages and libraries. You’ll also learn how these commands create and update the corresponding configuration files to ensure reproducibility.Adding and Installing DependenciesNow, go back to the beginning of theHandling Python Projects With uvsection, expand the collapsible block, and copy the code for the sample CLI app. Paste the code into themain.pyfile in your project’s root folder.Once you have the code in place, you might be tempted to run the app with a command like the following:Shell$uvrunmain.pyPersianTraceback (most recent call last):...ModuleNotFoundError: No module named 'requests'The app fails with aModuleNotFoundErrorexception. Why? Because you haven’t installed the required dependencies in your working environment.In your cat app example, you need theRequestslibrary, which is a popular library for making HTTP requests in Python. You use this library to retrieve cat information from the Cat API.Go ahead and run the following command to make uv addrequests:Shell$uvaddrequestsThis command lets you add the Requests library to your project’s dependencies. It also installs the library in your project’s virtual environment. Once it finishes running, go ahead and check the content of yourpyproject.tomlfile:TOML[project]name=""rpcats""version=""0.1.0""description=""Display cat information for the specified breed.""readme=""README.md""requires-python="">=3.13""dependencies=[""requests>=2.32.3"",]Notice howuv addautomatically updates your list of dependencies by addingrequeststo thepyproject.tomlfile. In this case, the installed version should be greater or equal to2.32.3.Note:If you’re working on an existing project and want to migrate from arequirements.txtfile to using uv, then you can run the following command:Shell$uvadd-rrequirements.txtThis command imports the dependencies declared in your existingrequirements.txtfile into the uv infrastructure.Internally,uv addalso updates theuv.lockfile with version information for the following:Direct dependencies: Packages that your project depends on directly. For example, your cat app depends onrequests.Transitive dependencies: Packages that support your project’s direct dependencies. For example, the Requests library depends onurllib3, and you get it installed as a transitive dependency.You don’t have to worry about theuv.lockcontent and shouldn’t edit it yourself. Instead, let uv be in charge of it. However, you must version-control it.As you can conclude,uv adddoes the dependency management work for you. It installs the dependencies, edits thepyproject.tomlfile if necessary, and keeps theuv.lockfile up-to-date. This ensures that other developers can reproduce your working environment.Note:Even though uv has analternative interfacethat mimicspip, you shouldn’t use it to install dependencies because these commands won’t update theuv.lockfile orpyproject.tomlautomatically likeuv adddoes.Would you like to give your cat app another try? Go ahead and run it:Shell$uvrunmain.pyPersian-----------Persian------------Origin: Iran (Persia)Temperament: Affectionate, Loyal, Sedate, QuietLife Span: 14 - 15 yearsWeight: 9 - 14 lbsLearn more: https://en.wikipedia.org/wiki/Persian_(cat)Now, your cat app is working correctly. It makes API requests, processes the responses, and displays information for the target breed of cat.Remove adsUpgrading and Removing DependenciesYou can also use uv to update and remove dependencies. For example, say that some time has passed since you released the latest version of yourrpcatsapp, and you’d like to continue the development by adding new features. However, you realize a new version is available for the Requests library.In this situation, you can use the following command to upgraderequests:Shell$uvadd--upgraderequestsThis command upgradesrequestsand updates its version information in theuv.lockfile. This action allows you to work with the library’s latest version and ensures that other developers can do the same.If you decide at any point that your project doesn’t need a dependency anymore, then you can remove it with the following command:Shell$uvremove<package_name>For example, if you’d like yourrpcatsapp to check for multiple cats at once, you might want to use a library likeaiohttp, which is capable of makingasyncHTTP requests. In that case, you can removerequestsand addaiohttp.It’s important to note thatuv removealso removes transitive dependencies and updates thepyproject.tomlanduv.lockfiles accordingly.Managing Development DependenciesIn most development environments, you’ll have dependencies that aren’t required for running the code but are vital for developing it. For example, testing libraries likepytest, code formatters like Ruff, and static type checkers likemypymight be some of these development dependencies.You can use uv to manage these types of dependencies. This time, you’ll use theuv addcommand with the--devflag. For example, say that you want to write tests for the cats app. To do this, you want to usepytest. Because your project doesn’t need this library to run, you can install it as a development dependency:Shell$uvadd--devpytestThis command will installpytestin your project’s virtual environment and add the library as a development dependency to yourpyproject.tomlanduv.lockfiles.If you check the content ofpyproject.tomlafter running the command above, then you’ll find the following:TOMLpyproject.toml[project]name=""rpcats""version=""0.1.0""description=""Display cat information for the specified breed.""readme=""README.md""requires-python="">=3.13""dependencies=[""requests>=2.32.3"",][dependency-groups]dev=[""pytest>=8.3.5"",]The highlighted lines show how uv automatically updated the file to includepytestin your list of development dependencies. You can also check the content ofuv.lockif you want to confirm thatpytestis there as well.Now you can write the tests for your projects!Locking and Syncing the EnvironmentAs you’ve already learned, uv uses theuv.lockfile to lock a project’s dependencies.Lockingconsists of capturing your project’s specific dependencies in the lockfile. This process makes it possible to reproduce your working environment in all possible configurations, including the Python version and distribution, the operating system, and the architecture.As a counterpart,syncingis the process of installing the required packages from the lockfile into the project’s development environment.Both locking and syncing processes are automatically handled by uv. For example, when you executeuv run, the project is locked and synced before the command is invoked. This behavior ensures that your project’s environment is always up to date.Now, imagine that you’ve pulled the cat app from a GitHub repository and would like to try it. In this scenario, you’ll only have the source code and the uv configuration files. You won’t have a proper Python virtual environment with the required dependencies to run the app.To reproduce this situation, you can go ahead and remove the.venv/folder from the project’s root directory. Then, let uv do the hard work for you:Shell$uvrunmain.py""Scottish Fold""Using CPython 3.13.2Creating virtual environment at: .venvInstalled 9 packages in 53ms--------Scottish Fold---------Origin: United KingdomTemperament: Affectionate, Intelligent, Loyal, Playful, Social, Sweet, LovingLife Span: 11 - 14 yearsWeight: 5 - 11 lbsLearn more: https://en.wikipedia.org/wiki/Scottish_FoldAs you can see, before trying to execute the app, uv creates a dedicated virtual environment at the.venv/directory. Then, it installs the dependencies and finally runs the app.To make sure that uv has reproduced the environment correctly, you can run the following command:Shell$uvpiplistPackage            Version------------------ ---------certifi            2025.1.31charset-normalizer 3.4.1idna               3.10iniconfig          2.1.0packaging          24.2pluggy             1.5.0pytest             8.3.5requests           2.32.3urllib3            2.3.0This is the list of packages installed in the project’s virtual environment and their specific versions. You can compare this list with the content of theuv.lockfile. The packages and versions will coincide, which ensures the exact reproduction of the original development environment.Note:In the example above, you used thepipinterface of uv. In this case, that’s perfectly valid because you aren’t changing the environment but retrieving information from it.Finally, you can explicitly lock and sync your project with the following commands:Shell$uvlock$uvsyncThese commands are helpful if you encounter issues with running the project and want to ensure that you’re using the correct version of each dependency.Remove adsBuilding and Publishing PackagesNow, say that your cat project is polished and ready to release a new version. You can also use uv to build and publish the project to a package repository like PyPI. First, you need to set some final options in theproject.tomlfile. Next, you can build a distribution. You’ll learn about both topics in the following sections.Configuring the ProjectYour cat app has a command-line interface (CLI), so you need to explicitly set the project’s entry-point script so that the build system can properly set up the executable file for the app. Go to thepyproject.tomlfile and add the following:TOMLpyproject.toml[project]name=""rpcats""version=""0.1.0""description=""Display cat information for the specified breed.""readme=""README.md""requires-python="">=3.13""dependencies=[""requests>=2.32.3"",][dependency-groups]dev=[""pytest>=8.3.5"",][project.scripts]rpcats=""main:main""With these two additional lines, you ensure that when someone installs your app, they can run therpcatscommand from their terminal to execute the code from themain()function, which is stored in themain.pyfile.Next, you need to define a build system. In this tutorial, you’ll useSetuptoolsas the build system. Go ahead and add the following lines to the end of yourpyproject.tomlfile:TOMLpyproject.toml[project]name=""rpcats""version=""0.1.0""description=""Display cat information for the specified breed.""readme=""README.md""requires-python="">=3.13""dependencies=[""requests>=2.32.3"",][dependency-groups]dev=[""pytest>=8.3.5"",][project.scripts]rpcats=""main:main""[build-system]requires=[""setuptools>=78.1.0"",""wheel>=0.45.1""]build-backend=""setuptools.build_meta""The first highlighted line specifies that the build system will requiresetuptoolsandwheel. The second highlighted line defines the build backend. With these two additions to theproject.tomlfile, you’re ready to build a distribution for your app.Building a DistributionYou can use theuv buildcommand to build source and binary distributions for your Python project. By default,uv buildwill build the project and place the distributions in adist/subdirectory under the project’s root:Shell$uvbuildBuilding source distribution...running egg_infocreating rpcats.egg-info...Successfully built dist/rpcats-0.1.0.tar.gzSuccessfully built dist/rpcats-0.1.0-py3-none-any.whlWhen you type in theuv buildcommand and pressEnter, the building process starts. You’ll see a detailed output on your terminal screen. At the end of the output, you’ll get a message telling you that the package has been successfully built.You also have the following build options:uv build --sdistuv build --wheelThe first command builds asource distributiononly, while the second command builds abinary distribution. Note that usinguv buildwithout any flags will build both the source and binary distributions.Publishing a DistributionThe final step is to publish the built package to a package repository like PyPI so that your users can download and install it on their systems.Beforepublishing a package to PyPI, you should make sure that everything works correctly. To this end, you can publish your package to theTestPyPIindex, which is a special repository designed for testing purposes. You’ll need to set up anaccount in TestPyPIand generate anAPI token. Once you’ve done that, you can manually edit yourpyproject.tomlfile as shown below:TOML[project]name=""rpcats""version=""0.1.0""description=""Display cat information for the specified breed.""readme=""README.md""requires-python="">=3.13""dependencies=[""requests>=2.32.3"",][dependency-groups]dev=[""pytest>=8.3.5"",][project.scripts]rpcats=""main:main""[build-system]requires=[""setuptools>=78.1.0"",""wheel>=0.45.1""]build-backend=""setuptools.build_meta""[[tool.uv.index]]name=""testpypi""url=""https://test.pypi.org/simple/""publish-url=""https://test.pypi.org/legacy/""explicit=trueWith these additions, you set up a custom index calledtestpypi. You must also change thenamekey to something unique that doesn’t exist in TestPyPI. Otherwise, you won’t be able to upload the package because the name already exists.Now, you can useuv publishwith the--indexoption to upload your app to TestPyPI:Shell$uvpublish--indextestpypi--tokenyour_token_hereTo run this command, you’ll need to add your personal API token for TestPyPI following the--tokenoption. Once you’ve entered all the information, pressEnterto upload the app to TestPyPI. That should be it!To try the app, you’ll create a new virtual environment in a different directory. So, go ahead and open a terminal window in any other directory on your hard drive. Then, run the following commands:Shell$uvvenvUsing CPython 3.13.2Creating virtual environment at: .venvActivate with: source .venv/bin/activate$uvpipinstall-ihttps://test.pypi.org/simple/rpcats× No solution found when resolving dependencies:╰─▶ Because only requests==2.5.4.1 is available and rpcats==0.1.0 depends onrequests>=2.32.3, we can conclude that rpcats==0.1.0 cannot be used.And because only rpcats==0.1.0 is available and you require rpcats, wecan conclude that your requirements are unsatisfiable.With theuv venvcommand, you create a fresh virtual environment in your working directory under the.venvfolder.Note:In the example above, you fall back on using thepipinterface for uv because you’re not managing a project. Instead, you’re just creating a virtual environment and installing a package for testing purposes. While thepipinterface is available for use cases like this, it’s not intended for project management.Next, you try to installrpcatsfrom TestPyPI using the-ioption ofuv pip. The installation fails because uv is trying to install arequestsversion greater than or equal to2.32.3, as your dependencies state. However, the latestrequestsversion in TestPyPI is2.5.4.1, which doesn’t fulfill your needs.To work around this issue, you can installrequestsfrom PyPI and then installrpcatsas before:Shell$uvpipinstallrequests$uvpipinstall-ihttps://test.pypi.org/simple/rpcats$uvrunrpcatsPersian-----------Persian------------Origin: Iran (Persia)Temperament: Affectionate, Loyal, Sedate, QuietLife Span: 14 - 15 yearsWeight: 9 - 14 lbsLearn more: https://en.wikipedia.org/wiki/Persian_(cat)Here, you manually install Requests from PyPI. Next, you installrpcatsfrom TestPyPI with the same command as before. Finally, you runrpcatswith theuv runcommand to make sure it works properly. Note that you’re not runningmain.py, butrpcatsas a command instead.Once you’re sure your project works correctly, you can upload it to PyPI’s main index. Again, you need to have anaccountand an API token.Note:To keep PyPI unpolluted, you shouldn’t uploadrpcatsto the index. Remember that this is just a sample project for learning purposes, not a fully functional app.Once you have the account and the token at hand, run the following command to publish your package:Shell$uvpublish--tokenyour_token_hereThis command uses PyPI as its default package index. As with TestPyPI, you need to enter yourAPI token. Once the command is done, your app will be available in PyPI, and you’ll be able to install it like any other Python package.Remove adsConclusionYou’ve learned all about uv, a fast, Rust-based package and project manager for Python. You’ve explored its features for creating projects, setting up virtual environments, managing dependencies, building and publishing projects, and more.Understanding how to manage Python projects effectively is crucial for any Python developer. With uv, you have an all-in-one solution that speeds up your workflow and simplifies project management, making it an invaluable tool for both beginners and experienced developers.In this tutorial, you’ve learned how to:Install uvon your operating systemCreate and manage Pythonprojectswith uvHandledependenciesefficiently with uv commandsBuild and publishPython packages to PyPI or private indexesSet updeveloper toolswithin uv for a streamlined workflowWith these skills, you’ll manage your Python projects more efficiently, ensuring smooth development and deployment processes. You can use uv to handle project dependencies, automate environment setup, and improve collaboration across your development team.Get Your Code:Click here to download the free sample codeyou’ll use to learn about managing Python projects with uv.Frequently Asked QuestionsNow that you have some experience with managing Python projects using uv, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.How do I install uv for managing Python projects?Show/HideYou can install uv using a standalone installer or from PyPI using tools likepipxorpip. Depending on your operating system, you can also use tools like Homebrew and Cargo.Can uv manage virtual environments automatically?Show/HideYes, uv automatically creates and manages virtual environments for your projects.How can I build and publish a Python package using uv?Show/HideYou can build a package using theuv buildcommand, and publish it to a package repository like PyPI or a private index with theuv publishcommand.Does uv support Python version management?Show/HideYes, uv allows you to install and manage multiple Python versions within your projects using theuv python installcommand. However, because Python doesn’t publish official distributable binaries, uv uses distributions from the Astral project.Take the Quiz:Test your knowledge with our interactive “Managing Python Projects With uv: An All-in-One Solution” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizManaging Python Projects With uv: An All-in-One SolutionIn this quiz, you'll test your understanding of the uv tool, a high-speed package and project manager for Python.Mark as CompletedShare"
Getting Started With Python IDLE,https://realpython.com/python-idle/,"Apr 23, 2025",N/A,"basics, editors","Table of ContentsOpen Python’s IDLE for the First TimeGet to Know the Python IDLE ShellUnderstanding the Interactive InterpreterInteracting With the IDLE ShellInterrupting ProcessesWork With Python Files in IDLEOpening a FileSaving a FileEditing a FileShowing Line NumbersExecuting a FileImprove Your IDLE WorkflowAutomatic IndentationCode Completion and Call TipsCode ContextDebug in IDLEInterpreter DEBUG ModeBreakpointsHandle Errors and ExceptionsGet Notifications Before Running CodeJump to the Error SourceUse the Stack ViewerCustomize Settings in Python IDLEFontsHighlightsKeysWindowsShell and EditorExtensionsConclusionFrequently Asked QuestionsRemove adsWatch NowThis tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding:Starting With Python IDLEPython IDLE is the default integrated development environment (IDE) that comes bundled with every Python installation, helping you to start coding right out of the box. In this tutorial, you’ll explore how to interact with Python directly in IDLE, edit and execute Python files, and even customize the environment to suit your preferences.By the end of this tutorial, you’ll understand that:Python IDLEis completelyfreeand comes packaged with the Python language itself.Python IDLEis an IDE included with Python installations, designed for basic editing, execution, and debugging of Python code.Youopen IDLEthrough your system’s application launcher or terminal, depending on your operating system.You cancustomize IDLEto make it a useful tool for writing Python.Understanding the basics of Python IDLE will allow you to write, test, and debug Python programs without installing any additional software.Get Your Cheat Sheet:Click here to download your free cheat sheetthat will help you find the best coding font when starting with IDLE.Take the Quiz:Test your knowledge with our interactive “Getting Started With Python IDLE” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizGetting Started With Python IDLEIn this quiz, you'll test your understanding of Python IDLE, the default integrated development environment (IDE) that comes bundled with every Python installation. You'll revisit how to interact with Python directly in IDLE, edit and execute Python files.Open Python’s IDLE for the First TimePython IDLE is free and comes included in Python installations on Windows and macOS. If you’re a Linux user, then you should be able to find and download Python IDLE using your package manager. Once you’ve installed it, you can then open Python IDLE and use it as an interactive interpreter or as a file editor.Note:IDLE stands for “Integrated Development and Learning Environment.” It’s a wordplay with IDE, which stands for Integrated Development Environment.The procedure for opening IDLE depends on how you installed Python and varies from one operating system to another. Select your operating system below and follow the steps to open IDLE:WindowsLinuxmacOSOpen the Start menu and clickAll ProgramsorAll Apps. There should be a program icon labeledIDLE (Python 3.x). This will vary slightly between different versions of Windows. The IDLE icon may be in a program group folder namedPython 3.x.You can also find the IDLE program icon by using the Windows search from the Start menu and typing inIDLE.
Click on the icon to start the program.IDLE is available with the Python distribution but may not have been installed by default. To find out whether it’s installed, open a terminal window.In the terminal window, typeidle3and pressEnter.
If you get an error telling you that the command wasn’t found, then IDLE isn’t installed and you’ll need to install it.The method for installing apps varies from one Linux distribution to the next. For example, with Ubuntu Linux, you can install IDLE using the package managerapt:Shell$sudoaptinstallidle3Many Linux distributions have GUI-based application managers that you can use to install apps as well.Follow whatever procedure is appropriate for your distribution to install IDLE. Then, typeidle3in a terminal window and pressEnterto run it. Your installation procedure may have also set up a program icon on the desktop that you can alternatively click to start IDLE.Open Spotlight Search and search forIDLE. Alternatively, you can open a terminal window, typeidle3and pressEnter.Once you’ve started IDLE successfully, you should see a window titledIDLE Shell 3.x.x, where 3.x.x corresponds to your version of Python:The window that you’re seeing is the IDLE shell, which is aninteractive interpreterthat IDLE opens by default.Remove adsGet to Know the Python IDLE ShellWhen you open IDLE, theshellis the first thing that you see. The shell is the default mode of operation for Python IDLE. It’s a blank Python interpreter window, which you can use  tointeract with Pythonimmediately.Understanding the Interactive InterpreterThe interactive interpreter is a basicRead-Eval-Print Loop (REPL). It reads a Python statement, evaluates the result of that statement, and then prints the result on the screen. Then, it loops back to read the next statement.Note:For a full guide to the standard Python REPL, check outThe Python Standard REPL: Try Out Code and Ideas Quickly.The IDLE shell is an excellent place to experiment with small code snippets and test short lines of code.Interacting With the IDLE ShellWhen you launch Python’s IDLE, it will immediately start a Python shell for you. Go ahead and write some Python code in the shell:Here, you usedprint()to output the string""Hello, from IDLE!""to your screen. This is the most basic way to interact with Python IDLE. You type in commands one at a time and Python responds with the result of each command.Next, take a look at the menu bar. You’ll see a few options for using the shell:You can restart the shell from this menu. If you select the restart option, then you’ll clear the state of the shell. It will act as though you’ve started a fresh instance of Python IDLE. The shell will forget about everything from its previous state:In the image above, you first declare avariable,x = 5. When you callprint(x), the shell shows the correct output, which is the number5. However, when you restart the shell and try to callprint(x)again, you can see that the shell prints atraceback. This is an error message that says the variablexis not defined. The shell has forgotten about everything that came before it was restarted.Interrupting ProcessesYou can also interrupt the execution of the shell from this menu. SelectingInterrupt Executionwill stop any program or statement that’s running in the shell at the time of interruption:In the video above, you create aninfinitewhileloop. When you selectInterrupt Executionfrom theShellmenu, the program receives the interrupt and stops executing. Then, IDLE shows aKeyboardInterrupterror message:Instead of using the menu, you can also use theinterrupt key combination, which isCtrl+C.An interactive interpreter is a great place to try things out. However, the IDLE shell really shows its true potential when you’re using it together with IDLE’s file editor.Remove adsWork With Python Files in IDLEAs a programmer, you need to be able to edit and save text files. Python programs are files with the.pyextension that contain lines of Python code. Python IDLE gives you the ability to create and edit these files with ease.Python IDLE also provides several useful features that you’ll see in a professionalintegrated development environment (IDE). These features include basic syntax highlighting, code completion, and auto-indentation.If you’re just beginning your Python programming journey, then Python IDLE is a great alternative toother IDEs.Opening a FilePython IDLE offers a full-fledged file editor with itsedit window. The edit window gives you the ability to write and execute Python programs from within this program.To start a new Python file, selectFile → New Filefrom the menu bar. This will open a blank file in the editor, like this:From this window, you can write a new Python file or open an existing one by selecting File → Open… from the menu bar. This will open your operating system’s file browser, where you can select the Python file you want to open.If you’re interested in reading the source code for a Python module, then you can selectFile → Path Browser. The content of this window will be the same as the paths that are returned when you accesssys.path. You can traverse through the folder tree and explore the inner structure of Python. When you double-click a Python file, the file editor will open up and you’ll be able to read the source code:In the screenshot above, you can see the source code of Python’sthis.py. If you’re curious about thisEaster egg in Python, then you can check out theWhat’s the Zen of Python?tutorial.If you know the name of a specific module you want to view, then you can selectFile → Module Browserand type in the name of the module in the box that appears.As you can see, IDLE is a great tool for exploring Python’s inner workings. Of course, you can create your own files from scratch and save them for later.Saving a FileTo save a file, you need a file first. If you don’t have a blank file open, then you can selectFile → New Filefrom the menu bar.Even when your Python file is empty, you can save it. Go ahead and save your Python file by selectingFile → Save:Once you clickSave, you’ll see your system’s file dialog. If you want to follow along closely, then you can name the filehello.py.Editing a FileOnce you’ve opened a file in Python IDLE, you can then make changes to it. The contents of your file are displayed in the open window. The bar along the top of the window contains the name of the file that you’re editing.There are also two numbers in the bottom right corner of the window:Ln:Displays the line number that your cursor is on.Col:Displays the column number that your cursor is on.These numbers can help you locate errors quickly and make sure you’re staying within a certain line width.There are a few visual cues in this window that will help you remember to save your work. If you look closely, then you’ll see that Python IDLE uses asterisks (*) to let you know that your file has unsaved changes:The filename shown at the top of the IDLE window has asterisks on either side. This means that there are unsaved changes in your editor. You can save these changes with your system’s standard keyboard shortcut, or you can selectFile → Savefrom the menu bar. Make sure that you save your file with the.pyextension so that syntax highlighting will be enabled.Remove adsShowing Line NumbersSeeing the line number of your cursor position in the lower right corner is helpful. However, line numbers are even more useful when they appear next to the line.Add a few more lines of code to yourhello.pyfile. For example, agreet()function:Pythonhello.pydefgreet(name):returnf""Hello,{name}!""greeting=greet(""Tappan"")print(greeting)While you’re typing the code, you can see theLnandColnumbers changing in the lower right corner.Next, selectOptions → Show Line Numbersfrom the menu bar. Once selected, you’ll see the line numbers next to your code:By enabling line numbers, you can conveniently refer to parts of your code without first moving the cursor to the line. The line numbers will also help you to investigateerrors and exceptionsmore conveniently.Executing a FileWhen you want to execute a file that you’ve created in IDLE, you should first make sure that it’s saved. Remember, you can see if your file is properly saved by looking for asterisks around the filename at the top of the file editor window.Note:Don’t worry if you forget to save your Python file. IDLE will remind you to save whenever you attempt to execute an unsaved file.To execute a file in IDLE, you can press theF5key on your keyboard. You can also selectRun → Run Modulefrom the menu bar. Either option will restart the Python interpreter, and then run the code that you’ve written with a fresh interpreter:When your code is done executing, the interpreter will know everything about your code, including any global variables, functions, and classes:After running your Python code, you can explore your Python code further. For example, you can run a Pythonfunctionwith different arguments.The IDLE shell and the IDLE file window are a powerful team. These two IDLE windows make Python IDLE a great place to inspect your Python code and support you in your development workflow.Improve Your IDLE WorkflowThe Python IDLE editor offers a few features that you’ll see in most professional IDEs to help you code faster. These features include automatic indentation, code completion and call tips, and code context.In this section, you’ll explore some of these features so you can decide if you want to incorporate them into your IDLE coding workflow for improved productivity.Remove adsAutomatic IndentationIDLE will automatically indent your code when it needs to start a new block. This usually happens after you type a colon (:). When you hit theEnterkey after the colon, your cursor will automatically move over a certain number of spaces and begin a new code block.The default indentation is four spaces, and it’s a good idea to stick with that.Note:The developers of Python agreed on a standard style for well-written Python code, and this includes rules on indentation, whitespace, and more. This standard style was formalized and is now known asPEP 8. To learn more about it, check outHow to Write Beautiful Python Code With PEP 8.However, there can be situations where you’ll want to deviate from the default setting—for example, when you’re makingprogramming videosand your horizontal screen space is sparse.You can configure how many spaces the cursor will move in the settings:When you go toSettings → Windows, also accessible through theOptions→Configure IDLEmenu, you can adjust theIndent spacesamount. While you’re in theWindowssettings, it’s worth exploring other options as well.Code Completion and Call TipsWhen you’re writing code for a large project or a complicated problem, you can spend a lot of time just typing out all of the code you need.Code completioncan save you typing time by helping to finish your code for you. Python IDLE has basic code completion functionality, which can autocomplete the names of functions and classes. To use autocompletion in the editor, just press theTabkey after typing a sequence of text:Python IDLE will also provide call tips. Acall tipis like a hint for a certain part of your code to help you remember what that element needs. After you type the left parenthesis to begin a function call, a call tip will appear if you don’t type anything for a few seconds. For example, if you can’t quite remember how to append to alist, then you can pause after the opening parenthesis to bring up the call tip:The call tip will display as a popup note, reminding you how to append to a list. Call tips like these provide useful information as you’re writing code.Code ContextThecode contextfunctionality is a neat feature of the Python IDLE file editor. It will show you the scope of a function, class, loop, or other construct. This is particularly useful when you’re scrolling through a lengthy file and need to keep track of where you are while reviewing code in the editor.To turn it on, selectOptions → Show Code Contextin the menu bar. You’ll see a gray bar appear at the top of the editor window:As you scroll down through your code, thecontextthat contains each line of code will stay inside of this gray bar. When you reach a line that’s outside the scope of this function, the content in the bar will disappear.Debug in IDLEAbugis an unexpected problem in your program. They can appear in many forms, and some are more difficult to fix than others. Some bugs are tricky enough that you won’t be able to catch them by just reading through your code. Luckily, Python IDLE provides somebasic toolsthat will help youdebugyour programs!Remove adsInterpreter DEBUG ModeIf you want to run your code with the built-in debugger, then you’ll need to turn this feature on. To do so, you must have an IDLE shell open. Then, you can selectDebug → Debuggerfrom the Python IDLE menu bar:In the interpreter, you should see[DEBUG ON]appear in the IDLE shell and the debugger window displayed:In this window, you can inspect the values of yourlocalandglobalvariables as your code executes. This gives you insight into how your data is being manipulated as your code runs.You can also click the following buttons to move through your code:Go:Click this to advance execution to the nextbreakpoint. You’ll learn about these in the next section.Step:Click this to execute the current line and go to the next one.Over:If the current line of code contains a function call, then click this to stepoverthat function. In other words, execute that function and go to the next line, but don’t pause while executing the function, unless there is a breakpoint.Out:If the current line of code is in a function, then click this to stepoutof this function. In other words, continue the execution of the function until you return from it.Be careful, because there’s no reverse button! You can only step forward in time through your program’s execution.You’ll also see four checkboxes in the debug window:Globals:Displays your program’s global information.Locals:Shows your program’s local information during execution.Stack:Lists the functions running during execution.Source:Displays your file in the IDLE editor.When you select one of these, you’ll see the relevant information in your debug window.BreakpointsAbreakpointis a line of code that you’ve identified as a place where the interpreter should pause while running your code.To set a breakpoint, right-click on the line of code that you wish to pause:Setting a breakpoint will highlight the line of code in yellow as a visual indication of a set breakpoint. You can set as many breakpoints in your code as you like. To undo a breakpoint, right-click the same line again and selectClear Breakpoint:Once you’ve set your breakpoints and turned onDEBUGmode, you can run your code as you would normally. The debugger window will pop up, and you can start stepping through your code manually.Handle Errors and ExceptionsDealing with errors is a fundamental part of programming. Errors and exceptions can happen when you least expect them, so you need to learn how to spot them if you want robust and reliable code.Luckily, Python’s IDLE editor has a few features in place that help you handle errors and exceptions in your code.Remove adsGet Notifications Before Running CodeSince IDLE is so closely connected to Python, IDLE checks your code before running it and informs you about aSyntaxErrorright away:In this code example, you forgot to add a closing parenthesis in yourprint()call. When you try running your code, you get a notification, and you can go back to your code to fix the error before continuing.Other errors are not as easy to spot and only get raised when Python executes the code. Fortunately, IDLE comes with some handy features to help you find the lines where errors occur.Jump to the Error SourceWhen you see an error reported to you in the interpreter, Python IDLE lets you jump right to the offending file or line from the menu bar. All you have to do is put your cursor over the error message with the reported filename and line number and selectDebug → Go to File/Linefrom the menu bar:Alternatively, you can also right-click the highlighted text and selectGo to file/linefrom there:This will open up the offending file and take you to the line that contains the error. This feature works regardless of whether or notDEBUGmode is turned on.Use the Stack ViewerPython IDLE also provides a tool called astack viewer. You can access it under theDebugoption in the menu bar. This tool will show you thetracebackof an error as it appears on the stack of the last error orexceptionthat Python IDLE encountered while running your code:When an unexpected or interesting error occurs, you might find it helpful to take a look at the stack. This feature can be useful when you’re writing very complicated code and you really want to investigate the source of your problem.Customize Settings in Python IDLEThere are many ways that you can customize IDLE to suit you better. While you can adjust some parts in theOptionsmenu, you can perform more impactful customizations in the settings window.To access the settings window, you need to go to theSettingsmenu. On macOS, you can find this under the IDLE menu at the top of the screen. On Windows and Linux, you can access it by selectingOptionsand then choosingConfigure IDLE.To preview the result of a change you want to make, clickApply. When you’re done customizing Python IDLE, clickOKto save all of your changes. If you don’t want to save your changes, then simply clickCancel.There are six areas of Python IDLE that you can customize:FontsHighlightsKeysWindowsShell and EditorExtensionsYou’ll take a look at each of them now.Remove adsFontsThe first tab allows you to change things like font color, font size, and font style. You can change thefontto almost any style you like, depending on what’s available for your operating system.You can use the scrolling pane on the left to select which font you prefer. Ideally, you should choose a fixed-width font. Once you’ve selected a font, you can see a preview in theFont Samplepane:Notice that it saysEditablenext toFont Sample. That means you can paste in your own code to preview a font.Here’s a useful snippet to evaluate your coding font:Pythonprint([{}])chars="""""",._ :; 1!IL1 2Z 5S 7T38B 6b 0O""""""# The quick brown fox# jumps over# the lazy dog.With the snippet above, you can get a good impression of how legible your selected font is and how different characters look.Get Your Cheat Sheet:Click here to download your free cheat sheetthat will help you find the best coding font when starting with IDLE.HighlightsThe second customization tab will let you change highlights.Syntax highlightingis an important feature of any IDE, as it highlights the syntax of the language you’re working in. This helps you visually distinguish between the different Python constructs and the data used in your code.Python IDLE allows you to fully customize the appearance of your Python code. It comes pre-installed with three different highlight themes:IDLE ClassicIDLE DarkIDLE NewYou can select from these pre-installed themes, or you can even create your own custom theme right in this window:Unfortunately, IDLE doesn’t allow you to import custom themes from a file. Any custom themes that you create in this window will stay in your IDLE installation. If that works for you, then you can start changing the colors for different items.To customize a theme, select an item in the text or the drop-down menu, and then selectChoose Color for. You’ll be brought to a color picker, where you can select the exact color that you want to use.You’ll then be prompted to save this theme as a new custom theme, and you can enter a name of your choosing. You can then continue changing the colors of different items if you’d like. Remember to clickApplyto see your changes in action!KeysThe third customization tab lets you map different key presses to actions, also known askeyboard shortcuts. These are a vital component of your productivity whenever you use an IDE. You can either come up with your own keyboard shortcuts, or you can use the ones that come with IDLE. The pre-installed shortcuts are a good place to start:The keyboard shortcuts are listed in alphabetical order by action. They’re listed in the formatAction - Key(s), whereActionis what will happen when you press the key combination. If you want to use a built-in key set, then select a mapping that matches your operating system.You can create a custom set of shortcuts from theKeystab. To do so, select one pair from the list and clickGet New Keys for Selection. A new window will pop up where you can use the checkboxes and scrolling menu to select the combination of keys that you want to use for this shortcut.Remove adsWindowsThe fourth tab of the settings is a place for general window settings. Most of the settings are visual settings that affect you. The only exception is the indent level:If you change the indentation level, the effect will take place on all indentations you set from now on. As mentioned earlier, the standard is four spaces, and it’s a good idea to keep it that way.Other than that, you can customize things like the window size and whether the shell or the file editor opens when you first start Python IDLE. These settings are safe to play around with.Shell and EditorTheShell/Edtab contains the settings for the shell and the editor. Here, you find some settings that you can otherwise find in theOptionsmenu bar of IDLE:The two most notable settings are probably to show line numbers in new windows by default and to notify you when running unsaved code.ExtensionsThe sixth tab of the customization window lets you add extensions to Python IDLE. Extensions allow you to add features to the editor and the interpreter window:By default, you can find a mysterious extension namedZzDummyin theFeature Extensionspane:The only current default extension is zzdummy, an example also used for testing.
(Source)If you feel adventurous, then you can visit theIdleX website, which contains over twenty extensions that you can install for IDLE. However, keep in mind that there haven’t been any updates to the package since 2022.Alternatively, you can write your own extensions by following the instructions onwriting IDLE extensions. If you do write your own extension for IDLE, then make sure to let the Real Python community know in the comments below!ConclusionIn this tutorial, you’ve learned all the basics of usingIDLEto write Python programs. You know what Python IDLE is and how you can use it to interact with Python directly. You’ve also learned how to work with Python files and customize Python IDLE to your liking.You’ve learned how to:Work with the Python IDLE shellUse Python IDLE as a file editorImprove your workflow with features to help you code fasterDebug your code and view errors and exceptionsCustomize Python IDLE to your likingNow you’re armed with a free tool that will let you write Python code without needing to install additional software.Remove adsFrequently Asked QuestionsNow that you have some experience with Python IDLE, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What is Python IDLE?Show/HidePython IDLE is Python’s default integrated development environment (IDE) that comes bundled with every Python installation, allowing you to write, edit, and execute Python code.How do you run Python IDLE?Show/HideYou can run Python IDLE by searching for “IDLE” in your operating system’s search function or by using the terminal command likeidle3, depending on your OS.Is Python IDLE free?Show/HideYes, Python IDLE is free and comes included with every Python installation.What is the ZzDummy extension in Python's IDLE?Show/HideThe ZzDummy extension in Python’s IDLE is an example extension used for testing and does not provide any functional features.Take the Quiz:Test your knowledge with our interactive “Getting Started With Python IDLE” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizGetting Started With Python IDLEIn this quiz, you'll test your understanding of Python IDLE, the default integrated development environment (IDE) that comes bundled with every Python installation. You'll revisit how to interact with Python directly in IDLE, edit and execute Python files.Mark as CompletedShareWatch NowThis tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding:Starting With Python IDLE"
MySQL Databases and Python,https://realpython.com/courses/mysql-databases-python/,"Apr 22, 2025",1h 7m,"intermediate, databases, data-science","MySQLis one of the most populardatabase management systems (DBMSs)on the market today. It ranked second only to theOracle DBMSin this year’sDB-Engines Ranking. As most software applications need to interact with data in some form, programming languages like Python provide tools for storing and accessing these data sources.Using the techniques discussed in this video course, you’ll be able to efficiently integrate a MySQL database with a Python application. You’ll develop a small MySQL database for a movie rating system and learn how to query it directly from your Python code.By the end of this video course, you’ll be able to:Identify unique features ofMySQLConnect your applicationto a MySQL databaseQuery the database tofetch required dataHandle exceptionsthat occur while accessing the databaseUsebest practiceswhile building database applicationsWhat’s Included:13 LessonsVideo Subtitles and Full Transcripts2 Downloadable ResourcesAccompanying Text-Based TutorialQ&A With Python Experts: Ask a QuestionCertificate of CompletionDownloadable Resources:Course Slides (.pdf)Sample Code (.zip)Related Learning Paths:Database Access With Python"
How to Copy Objects in Python: Shallow vs Deep Copy Explained,https://realpython.com/python-copy/,"Apr 21, 2025",N/A,"advanced, python","Table of ContentsGetting the Big Picture of Object CopyingScalar vs Composite TypesMutable vs Immutable ObjectsValue vs Reference CopyingPython’s Reference BindingMore on AssignmentsUnderstanding Shallow and Deep CopyingShallow Copy: Duplicating Object ReferencesExposing the Pitfalls of Shallow CopyingDeep Copy: Creating Independent ClonesComparing Shallow and Deep CopyingExploring the Techniques of Copying in PythonCalling the Class ConstructorSlicing a Python SequenceCalling the .copy() MethodUsing copy() and deepcopy()Customizing the Copy Behavior of Python ObjectsRelying on the Default BehaviorManaging Resources in CopiesCopying Attributes SelectivelySupporting Attribute ReplacementConclusionFrequently Asked QuestionsRemove adsWhen working with Python objects, you’ll often need to make copies rather than modify the originals. In this tutorial, you’ll explore various ways to copy objects in Python, including using the built-incopymodule. You’ll also learn the key differences between shallow and deep copies, with practical examples so you can safely duplicate objects in your own code.By the end of this tutorial, you’ll understand that:Shallow copyingcreates a new object but references the same nested objects, leading to shared changes.Deep copyingrecursively duplicates all objects, ensuring full independence from the original.Python’scopymoduleprovides thecopy()function for shallow copies anddeepcopy()for deep copies.Custom classescan implement.__copy__()and.__deepcopy__()for specific copying behavior.Assignment in Pythonbinds variable names to objects without copying, unlike some lower-level languages.Explore the nuances of copying objects in Python and learn how to apply these techniques to manage mutable data structures effectively.Get Your Code:Click here to download the free sample codethat you’ll use to learn about shallow vs deep copying in Python.Take the Quiz:Test your knowledge with our interactive “Shallow vs Deep Copying of Python Objects” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizShallow vs Deep Copying of Python ObjectsIn this quiz, you'll test your understanding of Python's copy module, which provides tools for creating shallow and deep copies of objects. This knowledge is crucial for managing complex, mutable data structures safely and effectively.Getting the Big Picture of Object CopyingCopying an object means creating itsexact duplicatein memory. While there are many good reasons for doing so, at the end of the day, it allows you tomodifythe cloned objects independently of each other.For example, agetter methodmay return sensitive information like the balance of someone’s bank account. To prevent unauthorized modifications of the bank account’s state, whether accidental or intentional, you’ll typically return a copy of the original data as adefensive programmingmeasure. That way, you’ll have two separate objects safely representing the same piece of information.Sometimes, you may need to work with multiple snapshots of the same data. In3D computer graphics, transformations like rotation and scaling rely onmatrix multiplicationto update a model’s vertices. Rather than permanently changing the original model, you can duplicate its vertices and apply transformations to the copy. This will allow you to animate the model in a non-destructive way.The following section provides an overview of the fundamental concepts and challenges associated with object copying in general. If you’d like to jump straight tocopying objects in Python, then feel free to skip ahead.Remove adsScalar vs Composite TypesIn programming, objects can be classified into two broad categories of data types:ScalarCompositeScalar data typesrepresent simple, indivisible values that can’t be decomposed into smaller parts, much like atoms were once thought to be. Examples of scalars in Python includenumbers,dates, andUUID-type identifiers:Python>>>fromdatetimeimportdate>>>fromuuidimportuuid4>>>numbers=42,3.14,3+2j>>>dates=date.today(),date(1991,2,20)>>>ids=uuid4(),uuid4(),uuid4()Each of these objects holds a single value representing a basic unit of data. By combining these fundamental building blocks, you can create more complex data structures.Composite data types, on the other hand, are containers made up of other elements. Some of them are merely collections of scalar values, while others contain other composites or both, forming a complex hierarchy of objects:Python>>>importarray>>>audio_frames=array.array(""h"",[2644,2814,3001])>>>audio_data=(...(""PCM"",2,44100,16),...[...(15975,28928),...(-86,15858),...(31999,-3),...]...)In this case, the""h""argument in thearray.array()call specifies that the array will store numbers as two-byte signed integers. As you can see, aPython arrayaggregates scalar numbers into a flat sequence, whereas alist and tuplecan contain deeply nested structures arranged in a particular way.Note:Python types can sometimes fall into a gray area. For example, strings have a dual nature, as they’re technically sequences of characters. At the same time, they behave like scalars in specific contexts because they don’t allow element-wise operations—you must treat them as a whole.These two categories of data types are closely related to the concept ofobject mutability, which you’ll learn more about now.Mutable vs Immutable ObjectsIn high-level programming languages likeJavaandJavaScript,scalar typestypically represent read-only values that can’t change over time. Such objects don’t allowin-placestate mutation during their lifetime. So, if you want to modify a scalar value, then your only option is to disregard it and create another instance with a different value. In contrast,composite typescan be eithermutable or immutable, depending on their implementation.Note:Immutable types have several advantages, includingthread safetyand improvedmemory efficiency, as they let you reuse objects without copying. On the other hand, whenperformanceis vital, mutable types can reduce the overhead associated with object creation, especially when you tend to modify your objects frequently.This correlation largely holds true in Python, as all scalar types built into the language are immutable, while compound types can be either mutable or immutable. For example, aBoolean valuelikeTrueorFalseis read-only, but you’ll find both mutable and immutablesequencesin Python:APython listrepresents a mutable sequence of arbitrary elements.APython stringis an immutable sequence of characters.That being said, youcandefine your ownmutable scalar typesin Python if you really want to. Here’s an example of a customclassthat leverages apropertyto allow in-place state mutation:Python>>>importunicodedata>>>classEmoji:...def__init__(self,name):...self.name=name......def__repr__(self):...returnself._glyph......@property...defname(self):...returnunicodedata.name(self._glyph).title()......@name.setter...defname(self,value):...self._glyph=unicodedata.lookup(value)...>>>emoji=Emoji(""tangerine"")>>>emoji🍊>>>emoji.name=""clown face"">>>emoji🤡TheEmojiclass above encapsulates a singleUnicode characterthat can change dynamically at runtime. Notice how you modify the object’s appearance by setting the.nameattribute with a valid symbol name from theUnicode Character Database.One surprising edge case involving immutable types in Python has to do withimmutable container typesliketuples. While you can’t add or remove elements from such immutable containers after creation, if they include a mutable item, then you can still modify that item. Here’s an example:Python>>>row=(42,""John Doe"",{""Python"",""Data Science""})>>>row[-1].add(""Machine Learning"")>>>row(42, 'John Doe', {'Machine Learning', 'Python', 'Data Science'})You define a tuple of three elements representing a row fetched from adatabasetable or another tabular data source like aCSV file. The first element in the tuple is a numeric ID of the data record. The second element is a textual name of an individual associated with that record. Finally, the third element is aPython setcontaining the skills of the individual.Even though the tuple itself isimmutable, meaning you can’t change its structure or replace its elements, you can still modify themutableset within that tuple, for example, by adding a new skill. This has implications for copying, as you’ll discover later.Although it doesn’t always guarantee it,hashabilityis often a good indicator of immutability. In general, most immutable objects in Python are inherentlyhashable, while mutable objects typically aren’t. As a result, you can take advantage of the built-inhash()function as a quick proxy to test whether an object is likely immutable:Python>>>hash((42,""John Doe"",frozenset({""Python"",""Data Science""})))-6716780242542814007>>>hash((42,""John Doe"",{""Python"",""Data Science""}))Traceback (most recent call last):...TypeError:unhashable type: 'set'The first tuple contains only immutable elements, including afrozenset, so thehash()function successfully calculates ahash valuebased on the tuple’s contents. This strongly suggests that the tuple is indeed read-only. Conversely, callinghash()on the tuple with asetas an element raises an error because regular sets are mutable and therefore unhashable. This indicates that the second tuple, although immutable itself, can be modified in place.Understanding the difference between mutable and immutable types becomes essential when you copy an object, whether intentional or not. Before exploring how Python handles this, you’ll step back to see the traditional distinction between copyingvalues and references. This comparison will shed light on key differences that often surprise Python developers.Remove adsValue vs Reference CopyingBefore you dive in, here’s a quick word of caution. This section touches on advanced topics beyond Python to give you a broader perspective and clarify common misconceptions about object copying. Unless you’re interested in these details, you might prefer to move directly to thenext section, which focuses on Python. However, learning about these concepts may help you better understand the difference betweenshallow and deep copyinglater on.If you’re familiar with lower-level languages likeCorC++, then you might expect Python’sassignment statementandvariablesto behave similarly. However, nothing could be further from the truth! To see why, take a look at the following interactive session in theClinginterpreter, which is the C/C++ equivalent of thePython REPL—and don’t worry if you don’t fully understand the syntax:C1[cling]$inta=42;&a2(int*)0x7f1e5369400034[cling]$intb=a;&b5(int*)0x7f1e52f3400067[cling]$a=438(int)43910[cling]$b11(int)421213[cling]$&a14(int*)0x7f1e536940001516[cling]$&b17(int*)0x7f1e52f34000You declare two integer variables namedaandb, initializingato 42 and makingba copy ofa. The assignment statement online 4effectively creates a clone ofaat another memory location. Despite storing the same value, both variables reside at distinctmemory addresses, as indicated by thehexadecimalnumbers onlines 2 and 5.Note:Everystatementin C and C++ must end with a semicolon (;). However, Cling allows you to skip the semicolon, in which case it’ll evaluate the lastexpressionthat appears on the same line. Here, you place the semicolon after your assignment statements to evaluate expressions&aand&b, which reveal the memory addresses of variablesaandb.Later, when you assign a new value toaonline 7,bremains unchanged online 10, still holding 42. Onlines 13 and 16, you verify thataandbcontinue to exist at the same memory locations as before, demonstrating that scalar types likeintin C and C++ are mutable by default—although you could make them immutable with theconstkeyword.Now, consider a slightly different example involvingpointersin C/C++:C1[cling]$inta=42;&a2(int*)0x7d0bafbfb00034[cling]$int*b=&a5(int*)0x7d0bafbfb00067[cling]$a=438(int)43910[cling]$*b11(int)43You define an integer variableawith the value 42, just like before. But then, instead of creating another regular variable, you declarebas a pointer to an integer value (int*) and use the ampersand operator (&) to store the address ofainb. This means thatbholds the memory address ofa, effectively referencing the same memory location.As a result, when you change the value ofaonline 7, dereferencing the pointer with an asterisk (*) online 10also reflects this updated value, showing 43.The addresses printed onlines 2 and 5confirm that both variables refer to a single entity. However, notice a tiny detail distinguishing the two assignments. Online 1, you explicitly evaluate theaddressof variableausing the ampersand operator (&a), but later, you evaluate the whole ofline 4, showing thevaluestored inb. This time, the assignment statement didn’t copy the value—it copied the address of the assigned variable!In C and C++, the assignment statement behaves differently depending on whether you’re working with avalue type or a reference type, particularly when aliasing a variable. Forprimitive typeslikeint, the assignment creates a copy of the assignedvalue. However, when assigning a variable of a reference type—such as a C pointer or aC++ reference—the assignment copies thereferenceitself rather than duplicating the underlying value.Now, it’s time to explore how the assignment statement and variables in C/C++ compare to their Python counterparts.Python’s Reference BindingUnlike in C and C++, Python’s assignment statementnevercreates a copy of the object specified on the right side of the equals operator (=). That’s particularly true when you alias a variable like in this example:Python>>>a=42>>>b=a>>>aisbTrueAssignments are best understood when you read them from right to left. So, the first assignment,a = 42, starts by allocating memory for an object representing an integer and populates it with the specified value 42. Python then associates the newly created object’s address with your variablea, effectively making that variable animplicit reference.Note:The description above is intentionally simplified for illustrative purposes. In reality, the number42already exists in memory even before your first assignment statement due to Python’s caching mechanism, which you’ll touch upon later.The second assignment,b = a, behaves like the reference copying you saw earlier. Sinceaandbshare the sameidentity, as indicated by theisoperator, they both point to the same object in memory. To better understand this, you’ll peek under the surface to see how variables work.In C/C++, variables can be thought of asboxeswith a fixed shape and size determined by their underlying data type. The type is inherently tied to the variable itself, which means that you can only fit values of a certain type in such variables. Moreover, these variables take space regardless of whether they’re actually holding any value or not:C/C++ Variable Imagined as a BoxFor example, declaring a variable asunsigned shortin C/C++ allocates a memory block capable of storing only integers within a specific range of values. Because such a variable is designed forshort integers, you won’t be able to assign values of other types to it. This would be just like trying to fit a cube into a circular slot in a shape-sorting toy.In contrast, Python variables resemblesticky labelsthat can be put on any object because the type information is tied to the object, not the variable. Consequently, a Python variable serves as a flexible and lightweight nickname that you can give to arbitrary objects:Python Variables Depicted as Sticky LabelsMultiple variables are allowed to reference the same Python object without copying it, but a single variable always references exactly one object at a time. That said, you may reassign your variables freely throughout their lifetime. The process of associating variables with objects is known asname binding.Note:In C/C++, you can declare anuninitialized variablewithout assigning any value during its definition, essentially leaving your metaphorical box empty. This can lead to unpredictable behavior when you attempt to use such a variable before explicitly assigning a value.On the other hand, Python variables can’t exist on their own without referencing some value:Python>>>age:int>>>type(age)Traceback (most recent call last):...NameError:name 'age' is not defined>>>age:int|None>>>age=None>>>type(age)<class 'NoneType'>Although you can make aforward declarationusingtype hints, you’ll need to explicitly assign a value to a Python variable at some point, even if it’s justNone.By now, you know thatPython variablesare references rather than value containers. Additionally, theassignment statementin Python binds the variable on the left to the object on the right without copying it. However, there are nuances to this behavior that you should understand.Remove adsMore on AssignmentsWhile the plain assignment doesn’t create a copy of a Python object, this isn’t necessarily true for theaugmented assignment operators, such as Python’sincrement operator(+=). To demonstrate this, you’ll define the following helper function:Python>>>defreveal_vars(*names):...print(f""{'Variable':>10}{'Value':>10}{'Address':>20}"")...print(""-""*40)...fornameinnames:...value=globals().get(name,None)...print(f""{name:>10}{value!s:>10}{hex(id(value)):>20}"")...print()...This function prints the names of the specifiedglobal variables, along with values and memory addresses of the objects they’re bound to. The output will be neatly formatted thanks toPython’s f-stringliterals.You’ll now reproduce the code example from the previous section, and call your new function to display information about the variablesbeforeandafterusing the increment operator:Python>>>a=42>>>b=a>>>reveal_vars(""a"",""b"")Variable     Value             Address----------------------------------------a        42      0x7eab3cd4a0d0b        42      0x7eab3cd4a0d0>>>a+=1>>>reveal_vars(""a"",""b"")Variable     Value             Address----------------------------------------a        43      0x7eab3cd4a0f0b        42      0x7eab3cd4a0d0Initially, bothaandbpoint to the same memory address because they reference the same object. However, after incrementingaby one, the variableais suddenly bound to a new object with a different memory address, whilebremains unchanged. This seems to contradict the claim that assignment statements never create copies.The expressiona += 1is shorthand fora = a + 1, so Python first retrieves the current value ofa, which is 42, and adds1to it. Since integers in Python are immutable, this produces a new integer instance rather than modifying the existing one. Finally, the resulting value gets reassigned to the same variable, detachingafrom the original object and binding it to the newly created integer.In this case, the augmented assignment operator didn’t exactly clone your original object but instead produced a new one with an updated value. Such behavior is typical for immutable data types.Keep in mind that an operator’s behavior depends on how the underlying data type implements it. You could very well define a custommutable integer typewith aspecial methodthatoverloads the operatorto modify the same instance in place, rather than returning a new copy. The following class is a highly simplified integer implementation that demonstrates this concept:Python>>>classMutableInt:...def__init__(self,value):...self.value=value......def__iadd__(self,other):...self.value+=other...returnself......def__str__(self):...returnstr(self.value)...TheMutableIntclass above wraps a standard integer value, storing it as aninstance attribute. The class also implements the.__iadd__()method, which gets called when you use the+=operator on the corresponding object. This method is implemented such that it updates the object’s.valueattribute directly and returns the same object, which can be reassigned to a variable.Note:Unlike its augmented counterparts, you can’t overload the plain assignment operator (=), which is a core part of Python’s syntax. This restriction helps ensure predictable variable assignment, which would otherwise become confusing and error-prone.Repeat your last example, replacing the immutableintvalue with aMutableIntinstance. When you do, an identical expression,a += 1, will update the object in place, affecting bothaandb:Python>>>a=MutableInt(42)>>>b=a>>>reveal_vars(""a"",""b"")Variable     Value             Address----------------------------------------a        42      0x79ac59320ec0b        42      0x79ac59320ec0>>>a+=1>>>reveal_vars(""a"",""b"")Variable     Value             Address----------------------------------------a        43      0x79ac59320ec0b        43      0x79ac59320ec0Notice how both variables mirror the updated value of 43 after incrementinga, which means that no new objects have been created as a result of the assignment this time.This goes to show that mutability plays an important role in how objects are copied and shared in memory. Without further ado, it’s time to dive into copying objects in Python!Understanding Shallow and Deep CopyingNow that you understand how Python handlesassignmentandreference binding, you’ll explore the actual process of copying objects. Immutable objects don’t typically need explicit copying since you can’t modify them in place. However,mutable objectsrequire more careful handling.If a mutable object is referenced by many variables, then changes made through one reference will affect all others. Copying can, therefore, prevent such unintendedside effectsduring state mutation.Python provides two primary ways to copy an object:Shallow copyDeep copyA shallow copy creates a new object but doesn’t fully duplicate its contents, so any nested objects inside are still shared between the original and the copy. In contrast, a deep copyrecursivelyduplicates everything, ensuring that even deeply nested objects are cloned, effectively breaking all links to the original structure.The distinction between these two approaches matters when working with complex data structures like lists of lists, dictionaries containing other dictionaries, or custom objects with deeply nested attributes. In the following sections, you’ll see how to create both shallow and deep copies, when to use each approach, and potential pitfalls to watch out for.Remove adsShallow Copy: Duplicating Object ReferencesTo grasp the difference between shallow and deep copying, it’s a good idea to choose a mutable data type that can contain elements or nested objects. Consider the followingPythondict, which represents the inventory of a local grocery store:Python>>>inventory={...""fruits"":{...""apple"":50,...""banana"":30,...},...""dairy"":{...""cheese"":15,...""milk"":20,...}...}This dictionary holds two key-value pairs: one for fruits and one for dairy products, both of which are dictionaries themselves. Each of the nested dictionaries contains the product names and their respective quantities.There are a few ways toget a copyof such an object in Python, but you’ll learn about them later. For now, you can stick with the most universalcopy.copy()function from Python’s standard library. However, because the function’s name can be ambiguous, you’ll rename it to the more descriptiveshallow_copy()using theaskeywordfor clarity:Python>>>fromcopyimportcopyasshallow_copyNow, you can call this function to back up your inventory and assign the newly created object to another variable. Later, you’ll run a fewsanity checksto verify that you’ve successfully made a copy. If the resulting dictionary becomes too large to display comfortably on the screen, then you canpretty printit for a clearer view:Python>>>frompprintimportpp>>>backup=shallow_copy(inventory)>>>pp(backup,width=50){'fruits': {'apple': 50, 'banana': 30},'dairy': {'cheese': 15, 'milk': 20}}>>>pp(inventory,width=50){'fruits': {'apple': 50, 'banana': 30},'dairy': {'cheese': 15, 'milk': 20}}>>>type(backup)<class 'dict'>>>>backup==inventoryTrue>>>backupisinventoryFalseThe resulting object looks like your original inventory when you print them side by side. Still, it could be amappingother than a Pythondict, so you check if the backup has the sametype()as the cloned object. Both dictionaries compare equal (==), which means they currently have the same value. To confirm thatbackupandinventorydon’t actually reference the same object in memory, you check their identities, which turn out to be different.To further illustrate that your backup is an independent copy of the store’s inventory, try modifying the primary stock by adding a new category of products:Python>>>inventory[""seafood""]={...""shrimp"":12,...""salmon"":10,...""tuna"":8,...}>>>pp(inventory,depth=1){'fruits': {...}, 'dairy': {...}, 'seafood': {...}}>>>pp(backup,depth=1){'fruits': {...}, 'dairy': {...}}First, you add a third key-value pair into the inventory by putting another nested dictionary with seafood items under the aptly named""seafood""key. Then, you pretty print both dictionaries with thedepth=1parameter to limit the level of detail displayed, showing only the top-level keys. Since both objects have now diverged, this proves that modifying one instance has no effect on the copy.Depending on the business rules, this might be the desired behavior. For example, when a backup represents a snapshot of data taken at a specific time, you want to continue mutating your inventory without affecting any of the past copies. So far, things appear to be working as expected. However, because you’ve made ashallow copy, you may run into surprising issues, which you’ll explore next.Exposing the Pitfalls of Shallow CopyingIntroducing a new category of products to the store’s inventory didn’t affect the backup you created earlier. Now, try something different by adding oranges to the existing collection of fruits in the inventory. This will show you why a shallow copy isn’t the best choice in this scenario:Python>>>pp(inventory[""fruits""]){'apple': 50, 'banana': 30}>>>pp(backup[""fruits""]){'apple': 50, 'banana': 30}>>>inventory[""fruits""][""orange""]=40>>>pp(inventory[""fruits""]){'apple': 50, 'banana': 30, 'orange': 40}>>>pp(backup[""fruits""]){'apple': 50, 'banana': 30, 'orange': 40}Notice that oranges have been added to both the inventory and its backup, even though you’ve only modified one of them. But how is this possible?The difference between adding or removing a whole product category and modifying an existing category lies in the concept ofvalue vs reference copyingdiscussed earlier. When you make a shallow copy of an object, only the parent object is cloned as a distinct entity, while its descendants remain the same objects, shared between copies through duplicated references. In other words, a shallow copy is onlyone level deep:Python>>>backupisinventoryFalse>>>backup[""fruits""]isinventory[""fruits""]True>>>backup[""dairy""]isinventory[""dairy""]TrueThe top-level container objects referenced by thebackupandinventoryvariables are separate instances of the Python dictionary. However, their common children stored under the keys""fruits""and""dairy""are bound to the same two nested dictionaries. As a result, any in-place changes made to those children in the original dictionary are also reflected in the shallow copy.To help visualize this concept, have a look at the diagram below, which depicts thegraph of referencesand the Python objects they point to:Shallow Copy DiagramOn the far left, you can see the original dictionary, referenced by yourinventoryvariable, with three product categories inside. Each category is bound to a sub-dictionary with the corresponding product quantities.Note:Although dictionaries conceptually store key-value pairs, they’re implemented ashash tablesin Python, where each key is hashed to a specific location in memory. That location holds a reference to the corresponding value. So, in practice, you can think of a dictionary as a collection of named pointers.When you took a snapshot of the store’s inventory, only two categories were present:""fruits""and""dairy"". That’s why the backup dictionary on the far right is missing the""seafood""category, which you added later to the main dictionary.Theinventoryandbackupshare some of the same nested dictionaries, shown in the middle of the diagram. This explains why adding oranges to the store’s inventory also updated the copy, as they both reference the same underlying object.When you create a shallow copy, Python duplicates only thetop-level container—in this case, adictobject with its keys—leaving the nested elements alone. Instead of copying their values, Python copies thereferencesthat point to them.Such behavior can lead to unintended consequences if you expect the copy to remain unchanged. To ensure that mutations of an object’s descendants don’t affect its copy, considerdeep copying, which clones the complete hierarchy of objects rooted in the top-level prototype.Remove adsDeep Copy: Creating Independent ClonesWhile you can make shallow copies in various ways, Python provides only one generic method for creating a deep copy, which is thecopy.deepcopy()function. Go ahead and import this function now, along with the pretty printer you used before, and revisit the initial grocery store example from the previous section:Python>>>fromcopyimportdeepcopy>>>frompprintimportpp>>>inventory={...""fruits"":{...""apple"":50,...""banana"":30,...},...""dairy"":{...""cheese"":15,...""milk"":20,...}...}Your inventory is a freshly made Pythondictwith two nested dictionaries as elements. To demonstrate that deep copying produces fully independent clones of the original objects, calldeepcopy()on the top-level dictionary and then modify it the same way as you did before:Python>>>backup=deepcopy(inventory)>>>inventory[""fruits""][""orange""]=40>>>inventory[""seafood""]={...""shrimp"":12,...""salmon"":10,...""tuna"":8,...}After creating a backup copy, you put a new""orange""entry into the""fruits""category and add an entirely new""seafood""category to your inventory. Now, compare the originalinventorydictionary with its deep copy,backup, to see how they differ:Python>>>pp(inventory,width=50){'fruits': {'apple': 50,'banana': 30,'orange': 40},'dairy': {'cheese': 15, 'milk': 20},'seafood': {'shrimp': 12,'salmon': 10,'tuna': 8}}>>>pp(backup,width=50){'fruits': {'apple': 50, 'banana': 30},'dairy': {'cheese': 15, 'milk': 20}}Theinventorydictionary now includes a new entry under""fruits""and has a brand new product category. However, thebackupremains unchanged, which shows that the deep copy is indeed independent of the original.To drive the point home, here’s what the corresponding graph of Python references looks like this time:Deep Copy DiagramNotice how you ended up with two separate hierarchies of objects that no longer share their children. This can be attributed torecursion, which allows Python to systematically duplicate each object and its descendants. As a result, you may safely modify any object within one reference tree without affecting the other. On the flip side, you now have nearly twice as many new objects as before, which takes up extra space in memory.Having explored the concepts of shallow and deep copying in Python, it’s good to know their pros and cons. Up next, you’ll compare these two methods, looking at scenarios where each works best, and decide when to pick one over the other.Comparing Shallow and Deep CopyingAs long as your top-level composite object consists of onlyimmutable descendants, then shallow copying should be your default choice. Copying an object shallowly is faster and takes much less memory compared to a deep copy since you don’t duplicate the object’s internal structure. Take this shopping cart as an example:Python>>>fromcopyimportcopyasshallow_copy>>>shopping_cart=[""milk"",""eggs"",""banana"",""banana""]>>>discounted_shopping_cart=shallow_copy(shopping_cart)>>>shopping_cart.append(""sardines"")>>>shopping_cart[0]+="" chocolate"">>>print(shopping_cart)['milk chocolate', 'eggs', 'banana', 'banana', 'sardines']>>>print(discounted_shopping_cart)['milk', 'eggs', 'banana', 'banana']The shopping cart above is a list of immutable strings representing product names. While you can add or remove items from the cart, you can’t alter any of its elements in place. Any attempt to change an element directly will result in replacing it with a new string, so the original string in the copy remains unchanged. That’s why a shallow copy is sufficient in this case, as it creates a new list that references the same immutable string objects.Note:If your composite object is immutable itself, then copying it becomes generally unnecessary because all references to it will always point to the same fixed data. However, you might still need to copy a read-only container if some of its children are mutable. Recall theearlier exampleof a tuple containing a Python set as an element.Aside frommutable descendantsinside containers,recursive data typeswithcircular references, such as alinked list, are another use case where shallow copies fall apart. To illustrate this, consider an example where a Python list contains itself as an element:Python>>>continued_fraction=[1]>>>continued_fraction.append(continued_fraction)>>>print(continued_fraction)[1, [...]]>>>frompprintimportpp>>>pp(continued_fraction)[1, <Recursion on list with id=126201036952640>]>>>id(continued_fraction)126201036952640>>>id(continued_fraction[1])126201036952640This particular list represents asimple continued fractionthat repeats itself infinitely, approximating the irrational constant known as thegolden ratioaccording to this formula:The first element in the list is an integer equal to one, corresponding to the first term of the equation above. The second element is a reference to the list itself, creating a recursive cycle. Such a structure doesn’t exactly reflect the formula, but it still captures its recursive nature.Note that outputting the list using the standardprint()function displays a simplified representation to prevent aninfinite recursion errorduring printing. However, thepprintmodule provides a more detailed output, revealing the identity of the recursive list. By callingid(), you confirm that both the parent and its child are the same object.Exercise: Golden Ratio ApproximationShow/HideJust for fun, you can try evaluating the continued fraction to approximate the golden ratio and compare your solution with the one in the next collapsible section.Solution: Golden Ratio ApproximationShow/HideThe code below takes advantage of theFractiondata type and uses a recursive function to evaluate the approximation up to the specified depth:Python>>>fromfractionsimportFraction>>>cf=[1]>>>cf.append(cf)>>>defevaluate(depth):...ifdepth>0:...returncf[0]+Fraction(1,evaluate(depth-1))...returncf[0]...>>>golden_ratio=(1+5**0.5)/2>>>forninrange(21):...fraction=evaluate(n)...approximation=float(fraction)...error=abs(golden_ratio-approximation)...print(...f""n={n:<3}"",...f""{fraction:>11}"",...""\N{almost equal to}"",...f""{approximation:.15f}"",...f""(\N{greek capital letter delta}={error:<11.10f})"",...)...n=0             1 ≈ 1.000000000000000 (Δ = 0.6180339887)n=1             2 ≈ 2.000000000000000 (Δ = 0.3819660113)n=2           3/2 ≈ 1.500000000000000 (Δ = 0.1180339887)n=3           5/3 ≈ 1.666666666666667 (Δ = 0.0486326779)n=4           8/5 ≈ 1.600000000000000 (Δ = 0.0180339887)n=5          13/8 ≈ 1.625000000000000 (Δ = 0.0069660113)n=6         21/13 ≈ 1.615384615384615 (Δ = 0.0026493734)n=7         34/21 ≈ 1.619047619047619 (Δ = 0.0010136303)n=8         55/34 ≈ 1.617647058823529 (Δ = 0.0003869299)n=9         89/55 ≈ 1.618181818181818 (Δ = 0.0001478294)n=10       144/89 ≈ 1.617977528089888 (Δ = 0.0000564607)n=11      233/144 ≈ 1.618055555555556 (Δ = 0.0000215668)n=12      377/233 ≈ 1.618025751072961 (Δ = 0.0000082377)n=13      610/377 ≈ 1.618037135278515 (Δ = 0.0000031465)n=14      987/610 ≈ 1.618032786885246 (Δ = 0.0000012019)n=15     1597/987 ≈ 1.618034447821682 (Δ = 0.0000004591)n=16    2584/1597 ≈ 1.618033813400125 (Δ = 0.0000001753)n=17    4181/2584 ≈ 1.618034055727554 (Δ = 0.0000000670)n=18    6765/4181 ≈ 1.618033963166706 (Δ = 0.0000000256)n=19   10946/6765 ≈ 1.618033998521803 (Δ = 0.0000000098)n=20  17711/10946 ≈ 1.618033985017358 (Δ = 0.0000000037)When you compare the last result (n=20) with the actual golden ratio, you’ll find that this solution approximates it correctly up to eight decimal places.Now, watch closely what happens when you create both a shallow and a deep copy of your recursive data structure:Python>>>fromcopyimportcopyasshallow_copy,deepcopy>>>broken_copy=shallow_copy(continued_fraction)>>>deep_copy=deepcopy(continued_fraction)>>>pp(continued_fraction)[1, <Recursion on list with id=126201036952640>]>>>pp(broken_copy)[1, [1, <Recursion on list with id=126201036952640>]]>>>pp(deep_copy)[1, <Recursion on list with id=126201037321536>]The string representation of the shallow copy differs from the other two, as it’s a new list referencing both elements of its prototype. The first element of the shallowly copied list points to an integer, but the second element points to adifferentlist rather than its immediate parent. On the other hand, deep copying cleverly duplicated the nested list, preserving the recursive relationship between the copy and its own child element.Check out the diagram below to get an idea of how the references are structured in both cases:Shallow vs Deep Copy of a Recursive Data StructureThebroken_copydepicted in the bottom right corner is a shallow copy of thecontinued_fractionon the left. Although it’s a separate entity occupying a distinct memory region, the shallow copy only contains duplicates of thereferencesfrom its prototype. So, the shallow copy isn’t cyclic itself because its second element—located at index one—points to the original list.Conversely, thedeep_copyat the top of the diagram is a fully independent clone, with most of its descendants duplicated recursively. But why is the integer shared between all three lists? It’s an optimization technique to conserve memory. Since integers are immutable, Python can reuse the same object across multiplereferentsthat need to access the same value for reading.Note:Due tointeger interning, most integers typed into the Python REPL are usually copied despite their immutability. Only fairly small values are cached while larger integers typically aren’t:Python>>>x=256>>>y=256>>>xisyTrue>>>a=1024>>>b=1024>>>aisbFalseIn this case, variablesxandyrefer to the same shared instance, whereasaandbare distinct objects with the same value. There are exceptions to these rules. However, they’re implementation details ofCPythonthat have no practical effect on your code’s behavior.In summary, choose shallow copying for efficiency when dealing with immutable elements, and opt for deep copying when you need to ensure complete independence between the original and copied objects. This is especially true when your container object has mutable elements or when you work with recursive data structures.Remove adsExploring the Techniques of Copying in PythonIn this section, you’ll get a summary of four different approaches to copying Python objects, covering both shallow and deep copies. Along the way, you’ll gain insight into how each method works and how it impacts performance, helping you choose the most suitable option for your specific use case.Calling the Class ConstructorMany built-in types in Python provide an overloadedclass constructorthat accepts another instance of the same data type. These include scalars like Boolean values and numbers, as well as mutable and immutable composites:ConstructorTypeMutabilityBehaviorbool()ScalarImmutableNo copyint(),float(),complex()ScalarImmutableNo copystr()Scalar/CompositeImmutableNo copybytes()CompositeImmutableNo copyfrozenset()CompositeImmutableNo copytuple()CompositeImmutableNo copybytearray()CompositeMutableShallow copydict()CompositeMutableShallow copylist()CompositeMutableShallow copyset()CompositeMutableShallow copyNotice that onlymutable containers, such asbyte arrays, dictionaries, lists, and sets, have constructors that actually return a copy of the supplied argument:Python>>>fruits=[""apple"",""banana"",""orange""]>>>dairy={""cheese"":15,""milk"":20}>>>seafood={""shrimp"",""salmon"",""tuna""}>>>fruits_copy=list(fruits)>>>dairy_copy=dict(dairy)>>>seafood_copy=set(seafood)>>>fruits_copyisfruits,fruits_copy==fruits(False, True)>>>dairy_copyisdairy,dairy_copy==dairy(False, True)>>>seafood_copyisseafood,seafood_copy==seafood(False, True)These constructors act as factory functions that build ashallow copyof the prototype passed as their only argument—with the same elements as the original. This is conceptually similar to a defaultcopy constructorgenerated by the C++ compiler. In each case, the copy is a separate object, which compares equal to the original.Note:To make a deep copy of these mutable containers, you’ll still need to call thedeepcopy()function from thecopymodule, which is covered later.In contrast, read-only composites likebytes, frozen sets, and tuples never clone the parent object, retaining its original identity:Python>>>veggies=(""carrot"",[""spinach"",""kale""],""beans"")>>>veggies_copy=tuple(veggies)>>>print(veggies_copy)('carrot', ['spinach', 'kale'], 'beans')>>>veggies_copyisveggiesTrueCallingtuple()with an existing tuple as an argument returns the same tuple, even though it contains a reference to a mutable object. This is different from callinglist(), which always creates a new list instance.In most situations, shallow copying of an immutable container is unnecessary because you can usually reuse such objects safely—unless they contain mutable elements like in the example above. If that’s the case, then you should create a deep copy anyway.For scalar objects, which are predominantly immutable in Python, the behavior of their copy constructors is analogous. They always return the same object, regardless of whether the underlying data type allows distinct copies to exist at different memory locations. Take strings as an example:Python>>>text=""Hello, World!"">>>copy=""Hello, World!"">>>copyistextFalse>>>str(text)istextTrue>>>str(copy)iscopyTrueWhen you initialize two variables using sufficiently long but identicalstring literals, Python might allocate separate objects for both of them. Simultaneously, callingstr()on one of those variables will instead return a reference to the corresponding object without making a copy.Note:If you run this code from aPython scriptrather than an interactive REPL session, then you may observe a different behavior. That’s because Python cuts corners by caching repeated string literals when it finds them in your source code. On the other hand, the interpreter can’t make any assumptions upfront when you’re typing code interactively in the REPL.That said, strings that arevalid Python identifiers—consisting of only ASCII letters, digits, and underscores (_)—still getinternedin the REPL to boost performance of dictionary lookups for common keys. Anyway, these are technical details of the CPython interpreter, which you should never rely on!It’s worth noting that the class constructors discussed in this section are actually more flexible. They allow you to create a new object not just from another instance of their own kind but, in fact, from anyiterable object. This could be a completely different container or even agenerator:Python>>>set(""Hello, World!""){'H', ',', 'o', 'l', 'r', '!', ' ', 'W', 'e', 'd'}>>>set(reversed(""Hello, World!"")){'H', 'o', ',', 'e', 'l', 'r', '!', ' ', 'W', 'd'}>>>set(character.upper()forcharacterin""Hello, World""){'H', 'D', ',', 'R', 'O', ' ', 'L', 'E', 'W'}These examples show you how to create a set of characters from a string literal, areversed string, and a generator expression. Because sets may only contain unique elements, calling theset()constructor on an iterable is a common idiom for removing duplicates in Python.Okay. You’ve seen some built-in mutable containers with a shallow copy constructor, but what about other composite data types that don’t have one? In the next section, you’ll take a closer look at one such type, which supports its own syntax for copying.Remove adsSlicing a Python SequencePython comes with numerous data types and offers dedicated syntax to manipulate them. Among the most commonly used container types aresequences, which includebasic sequence types,character sequences, andbinary sequences, all built into the core language. Beyond these, standard and third-party libraries provide higher-level sequences, such as thePython array. Lastly, you can build your own sequence types from scratch!Regardless of which sequence type you’re working with, it’ll most likely support a powerful feature known asslicing. This feature allows you to carve out asubsequencefrom any object that implements thesequence protocol. You slice a sequence by using the square bracket syntax and passing aslice objectas a parameter.To define a slice, you can either call theslice()function explicitly, or use a more common approach and delimit itsstart,stop, andstepvalues with colons (:) as a shorthand notation:Python>>>fruits=[""apple"",""banana"",""fig"",""kiwi"",""mango"",""orange"",""plum""]>>>fruits[slice(1,6,2)]['banana', 'kiwi', 'orange']>>>fruits[1:6:2]['banana', 'kiwi', 'orange']The first number represents thestarting index, so a value of1means that slicing begins at thesecondelement,""banana"". The next number is theending index, which is exclusive. Therefore, a value of6stops the slicing right before theseventhelement, at""orange"". The third number is thestep, indicating how many elements to advance at a time. A value of2means that every second element should be selected, skipping over""fig""and""mango"".Note that when you specify all three values, you define what’s known as anextended slice, whereas standard slicing only requires the start and end indices:Python>>>fruits[slice(1,6)]['banana', 'fig', 'kiwi', 'mango', 'orange']>>>fruits[1:6]['banana', 'fig', 'kiwi', 'mango', 'orange']In fact, all three numbers are optional, defaulting to the first element’s index, the last element’s index, and a step of one, respectively. You can omit any combination of these numbers to achieve different slicing behaviors. However, from the object copying perspective, the following two variants are the most interesting:Python>>>fruits[::]['apple', 'banana', 'fig', 'kiwi', 'mango', 'orange', 'plum']>>>fruits[:]['apple', 'banana', 'fig', 'kiwi', 'mango', 'orange', 'plum']Although both approaches are equivalent, the highlighted line represents the most idiomatic way to create ashallow copyof a Python sequence. When you omit all three numbers, you’re slicing the entire sequence, effectively creating its copy. However, whether you’ll actually end up with a true clone or just another reference to the same object depends on the underlying sequence type. For example, compare mutable lists with immutable tuples:Python>>>fruits[:]isfruitsFalse>>>fixed_fruits=tuple(fruits)>>>fixed_fruits[:]isfixed_fruitsTrueA shallow copy of a list is a separate object that references the original elements, but a copy of an equivalent tuple with identical items isn’t. Just as with the class constructor discussed in the previous section, onlymutable sequenceslead to the creation of a new parent when you slice them with square brackets ([:]).Moreover, each slice is a sequence of a concrete type. This means that when you slice a list, you’ll get another list. However, slicing a byte array won’t give you a list—instead, you’ll create a new byte array. When it comes to immutable sequences, such as strings, you’ll always get exactly the same object:Python>>>text=""Hello, World!"">>>text[:]istextTrueThis behavior is consistent with thestr()constructor. However, what about sequence types that don’t have an equivalentcopy constructor? This is where using the slicing syntax comes in handy.For example, the Pythonrangeobject is alazily evaluatedimmutable sequence of numbers, which supports nearly all thecommon sequence operations, including slicing. Unfortunately, unlike other built-in sequence types, its constructor doesn’t accept another instance of its own type. Instead, therange()constructor resembles that of aslice(), taking between one and three integer arguments:Python>>>range(10)range(0, 10)>>>range(1,10)range(1, 10)>>>range(1,10,2)range(1, 10, 2)The most common way of evaluating arangeobject involves looping through it by hand. Alternatively, you can turn it into a sequence of your choice by letting Python iterate over it for you behind the scenes:Python>>>foriinrange(1,10,2):...print(i)...13579>>>tuple(range(1,10,2))(1, 3, 5, 7, 9)>>>bytearray(range(1,10,2))bytearray(b'\x01\x03\x05\x07\t')When you slice an entirerangeobject, it doesn’t short-circuit to return the original object like other immutable sequences do. Instead, it creates a new, equivalent copy:Python>>>signed_byte=range(-128,128)>>>signed_byte[:]issigned_byteFalseThat’s irrelevant, though, as the sequence of numbers generated by arangeobject remains fixed until you potentially wrap it in a different container. Note that slicing onerangeobject may sometimes produce another one with marginally different attribute values:Python>>>range(0,3,2)[:]range(0, 4, 2)>>>range(0,3,2)==range(0,4,2)True>>>list(range(0,3,2))[0, 2]>>>list(range(0,4,2))[0, 2]In this case, the resultingrangeobject has a slightly different stop value computed by Python. Still, both objects are considered equal because they generate the same sequence of numbers.Note:If you don’t like slicing and want to be more explicit, then consider using alist comprehensionor agenerator expressionto make a shallow copy of any iterable object:Python>>>veggies=(""carrot"",[""spinach"",""kale""],""beans"")>>>veggies_copy=tuple(itemforiteminveggies)>>>veggies_copyisveggies,veggies_copy==veggies(False, True)Unlike list comprehensions, a generator expression doesn’t create an intermediate container, saving memory. Notice that you can even use this approach to enforce a shallow copy of a tuple, which wasn’t possible with thetuple()constructor alone.While slicing offers a quick and straightforward way to copy a Python sequence, the.copy()method is often preferred for containers that support it, particularly mutable ones like lists and dictionaries. In the next section, you’ll explore how this method works and compares to other copying techniques.Remove adsCalling the.copy()MethodIn addition to thecopy constructorandslicingfor sequences, many of Python’s container types provide a convenient.copy()method, which you can call to create ashallow copyof an existing instance. This method is mainly available for mutable containers, such as lists, dictionaries, sets, byte arrays, anddeques. Here’s how you’d call it on a list, for example:Python>>>fruits=[""apple"",""banana"",""orange""]>>>fruits.copy()['apple', 'banana', 'orange']>>>fruits.copy()isfruitsFalseThe.copy()method delivers on the promise implied by its name—it returns a copy of the object. However, while it achieves the same result as the other two techniques, it does so differently.Note:You’ll also find the.copy()method in the read-only frozen set. Calling this method just returns a new reference to the same object without actually making a copy:Python>>>fruits=frozenset({""apple"",""banana"",""orange""})>>>fruits.copy()isfruitsTrueThis makes sense given that frozen sets are immutable and can only contain hashable values, which you already know are a good proxy for immutability. Although this may seem useless, it ensures interface consistency, allowing a frozen set to serve as a drop-in replacement for a regular set.Because.copy()is designed only for copying, it should outperform its more versatile competitors. To test this theory, you canbenchmark the performanceof those different copying tools using Python’stimeitmodule and see how they stack up:Python>>>fromcopyimportcopy>>>fromrandomimportchoices,randint>>>fromstringimportascii_letters>>>fromtimeitimporttimeit>>>random_strings=[..."""".join(choices(ascii_letters,k=randint(3,15)))...for_inrange(10)...]>>>timeit(lambda:random_strings.copy())0.10630368399870349>>>timeit(lambda:list(random_strings))0.13554470200142532>>>timeit(lambda:random_strings[:])0.1418512300006114>>>timeit(lambda:copy(random_strings))0.19122224100101448First, you populate a Python list with tenrandomly generatedstrings of variable length. You then measure the time it takes to create a shallow copy of this list using four different methods wrapped in alambda expression. The.copy()method is indeed an outright winner, although not by a large enough margin to make a real difference in practice.Note:You might be getting different results on your machine due to various factors like system noise. To reduce the variability, try increasing the number of executions, which is equal to one million by default:Python>>>timeit(lambda:random_strings.copy(),number=10_000_000)0.9921009059980861For even more consistent results, you can calltimeit.repeat(), which runs each benchmark a few times and returns a list of measurements. You can then take the smallest measurement to account for any fluctuations:Python>>>fromtimeitimportrepeat>>>repeat(lambda:random_strings.copy(),repeat=10,number=10_000_000)[1.0349072919998434, 1.0297772740013897, 1.0266390329998103, (...)]>>>min(_)0.9754441199984285Here, you use themin()function on the implicitunderscore (_)variable, which stores the value of the last expression in the REPL. The fastest execution has the least amount of noise.But that was just a small sample. Since the performance of algorithms can vary based on the size of the input data, you should zoom out to see the bigger picture and try to identify trends:Shallow Copy Performance (One Million Iterations)The chart on the left shows almost perfectly straight lines that overlap with each other. This tells you that all list copying methods run inlinear time, with execution time increasing proportionally to the list length. The chart on the right uses alogarithmic scaleon both axes to highlight performance differences for smaller inputs.Overall, the.copy()method is the fastest approach, which tends to come first in most of the benchmarks for small and medium-sized lists. That said, differences in execution time of the various methods are pretty narrow and roughly uniform throughout the spectrum, becoming less significant as the list grows.Exercise: Other Mutable ContainersShow/HideYou can repeat the same experiment for other mutable containers yourself. Remember that only sequences, such as lists and byte arrays, support the slicing syntax, so you’ll need to take this limitation into account.Solution: Other Mutable ContainersShow/HideHere’s a benchmarking script that evaluates the performance of different methods for copying containers in Python. It measures the time taken to copy dictionaries, sets, and lists using various techniques, including the.copy()method, the constructor, thecopy.copy()function, and slicing where applicable:Pythonbenchmark.pyfromcopyimportcopyfromrandomimportchoices,randintfromstringimportascii_lettersfromtimeitimporttimeitEXECUTIONS=10_000SIZE=1_000defmain():print(f"" Size={SIZE:,}({EXECUTIONS:,}x) "".center(50,""=""))forcontainer_typeinrandom_dict,random_set,random_list:container=container_type(size=SIZE)formethod,secondsinbenchmark(container,EXECUTIONS).items():print(f""{seconds:.5f}{method}"")print()defbenchmark(container,executions):type_=type(container)name=type_.__name__results={f""{name}.copy()"":timeit(container.copy,number=executions),f""{name}()"":timeit(lambda:type_(container),number=executions),f""copy({name})"":timeit(lambda:copy(container),number=executions),}ifsliceable(container):results[f""{name}[:]""]=timeit(lambda:container[:],number=executions)returnresultsdefsliceable(instance):try:instance[0:1]except(TypeError,KeyError):returnFalseelse:returnTruedefrandom_dict(size):keys=random_set(size)values=random_set(size)returndict(zip(keys,values))defrandom_set(size):returnset(random_list(size))defrandom_list(size,shortest=3,longest=15):return["""".join(choices(ascii_letters,k=randint(shortest,longest)))for_inrange(size)]if__name__==""__main__"":main()When you run this script, you’ll notice that the.copy()method in the other containers behaves similarly to its counterpart in a Python list.If you need a fast shallow copy in Python, then the.copy()method is your best option. But for larger containers, where you spend most of your time copying the elements anyway, the performance difference between the available techniques is negligible. Ultimately, it won’t make much difference which one you choose.It’s also worth noting that thecopy()function from thecopymodule is consistently the slowest, as it carries more overhead due to its universal applicability. You’ll take a closer look at this module now.Usingcopy()anddeepcopy()Thecopymodule, which belongs to Python’s standard library, is the most versatile tool for copying almost any object. With the exception of a few data types, such asfiles,network sockets, andmodules, you can use it to make bothshallow and deep copiesof arbitrary Python objects.You’ll typically want to call one of the functions from thecopymodule in these scenarios:Shallow Copy:To create a shallow copy of a Python object that lacks its own copy functionality, unlike sequences and other standard containers.Deep Copy:When you need a deep copy of an object, as no other built-in mechanism in Python provides this capability.Replace:If you want to shallowly copy a compatible type—for example, anamed tuple,data class, ordate and time—with only specific attributes replaced.Consider aStringIOinstance as an example. It’s a mutablefile-like object, which doesn’t provide a copy constructor, nor is it a Python sequence, meaning that you can’t slice it. Coincidentally, this object also doesn’t have the.copy()method, so you’re left with thecopymodule as your only option to clone it:Python>>>importcopy>>>fromioimportStringIO>>>fromcontextlibimportredirect_stdout>>>withredirect_stdout(StringIO())asstdout:...print(""Before"")...shallow_copy=copy.copy(stdout)...deep_copy=copy.deepcopy(stdout)...print(""Shallow copy modified"",file=shallow_copy)...print(""Deep copy modified"",file=deep_copy)...print(""After"")...>>>stdout.getvalue()'Before\nAfter\n'>>>shallow_copy.getvalue()'Before\nShallow copy modified\n'>>>deep_copy.getvalue()'Before\nDeep copy modified\n'In this example, you use acontext managerto redirect thestandard output (stdout)to a newStringIOinstance, capturing the printed text that would otherwise appear on the screen. Next, you create shallow and deep copies of the captured stream while printing additional messages to each copy.Although aStringIOobject is mutable, as a scalar type, it has no children of its own. Thus, callingcopy.deepcopy()has the same effect as callingcopy.copy()on it, making each replica independent. To observe an actual difference between the two functions, you’ll need to use a mutable composite, such as aSimpleNamespaceobject:Python>>>importcopy>>>frompprintimportpp>>>fromtypesimportSimpleNamespace>>>settings=SimpleNamespace(...debug=True,...urls=[...""https://192.168.1.200:8000"",...""https://192.168.1.201:8000"",...],...)It’s a lightweight collection of attributes that can be added or removed dynamically, much like key-value pairs in a dictionary. However, rather than using the square bracket syntax to access them, you use the dot notation:Python>>>settings.debugTrueThe following example illustrates the difference between shallow and deep copies of such mutable composites:Python>>>shallow_copy=copy.copy(settings)>>>deep_copy=copy.deepcopy(settings)>>>settings.urls.append(""https://10.0.0.3:8000"")>>>settings.debug=False>>>pp(deep_copy,width=50)namespace(debug=True,urls=['https://192.168.1.200:8000','https://192.168.1.201:8000'])>>>pp(shallow_copy,width=50)namespace(debug=True,urls=['https://192.168.1.200:8000','https://192.168.1.201:8000','https://10.0.0.3:8000'])>>>pp(settings,width=50)namespace(debug=False,urls=['https://192.168.1.200:8000','https://192.168.1.201:8000','https://10.0.0.3:8000'])When you create a shallow copy of thesettingsobject usingcopy.copy(), the new object references the same nested list of URLs as the original. Therefore, any changes to the list insettings, such as appending a new URL, are also reflected in theshallow_copy. However, when you create a deep copy withcopy.deepcopy(), the list of URLs is duplicated, so changes to the original list don’t affect thedeep_copy.This is evident when you modify thesettingsobject by appending a new URL and toggling thedebugattribute. Thedeep_copyretains the original state of thesettingsobject, while theshallow_copyreflects the changes made to the list. Notice, however, that thedebugattribute remains unchanged in both theshallow_copyand thedeep_copysince it’s a simple, immutable value.That brings you to the third and final use case for thecopymodule. As ofPython 3.13, the module introduces a new function that lets you replace specific elements within a cloned object. Below is an example demonstrating howcopy.replace()can be used to determine a hotel’s breakfast time based on the day of the week:Python>>>importcopy>>>fromcalendarimportDay>>>fromdatetimeimportdate,time>>>defbreakfast_today():...day=Day(date.today().weekday())...returnbreakfast(day,time(hour=7))...>>>defbreakfast(day,weekday_time):...matchday:...caseDay.SATURDAY:...returncopy.replace(weekday_time,minute=30)...caseDay.SUNDAY:...returncopy.replace(weekday_time,hour=8,minute=30)...case_:...returnweekday_time...>>>print(breakfast_today())07:00:00>>>print(breakfast(Day.SATURDAY,time(10)))10:30:00>>>print(breakfast(Day.SUNDAY,time(10,45)))08:30:00Depending on when you run thebreakfast_today()function, it may return different breakfast times. In this case, it’s a weekday, so the breakfast starts at 7:00 am. However, you can simulate other days of the week by explicitly calling the other function,breakfast(), which may adjust the baseline breakfast time for the specified day.If it’s a Saturday, then the function only adjusts the.minuteattribute of thedatetime.timeinstance, leaving other attributes unchanged. On a Sunday, however, it modifies both the.hourand.minuteattributes.Likecopy()anddeepcopy(),replace()takes an object to copy as the first argument. However, this function also accepts a variable number of optionalkeyword arguments, which are used to override the corresponding attributes of the object. Regardless of whether you specify them or not,replace()will return ashallow copyof your original object.Thecopy.replace()function works with mutable types, such as data classes, and immutable ones, like named tuples. In the next section, you’ll even learn how to define custom classes that support this feature. However, be aware that when you replace certain attributes, others might still refer to shared objects, which can lead to unintended side effects!Remove adsCustomizing the Copy Behavior of Python ObjectsWhen copying instances of custom classes, you often want control beyond what Python provides by default. In this section, you’ll explore several practical techniques for fine-tuning how shallow and deep copying from thecopymodule interacts with your own Python classes.Relying on the Default BehaviorIn most cases, you don’t need to take extra steps to make your Python classes copyable. As long as they consist of built-in types that already handle copying correctly, Python’scopymodule will be clever enough to make bothshallow and deep copiesof your custom objects straight away.Note:Python’s behavior differs from that of other programming languages, where objects don’t support copying by default. For example, in Java, classes must explicitly implement theCloneableinterface and override the.clone()method to allow copying.To prove this claim, consider aRectangleclass defined by two corner points, which are represented as instances of aPointclass:Python>>>classRectangle:...def__init__(self,top_left,bottom_right):...self.top_left=top_left...self.bottom_right=bottom_right......def__repr__(self):...returnf""Rectangle({self.top_left},{self.bottom_right})""...>>>classPoint:...def__init__(self,x,y):...self.x=x...self.y=y......def__repr__(self):...returnf""Point(x={self.x}, y={self.y})""...>>>bounding_box=Rectangle(...original_top_left:=Point(10,20),...original_bottom_right:=Point(30,40)...)>>>print(bounding_box)Rectangle(Point(x=10, y=20), Point(x=30, y=40))This code combines simpler objects into more complex ones throughcomposition, which is a key principle inobject-oriented programming. Specifically, theRectangleclass is a composite of two points, and aPointis a composite of two integers.Note the use of anassignment expression(:=) to retain the twoPointinstances created at the bottom in the currentscope. This will allow you to modify them later.Now, use thecopymodule to create both a shallow and a deep copy of thebounding_boxyou just defined, and then try modifying its constituents:Python>>>importcopy>>>shallow_copy=copy.copy(bounding_box)>>>deep_copy=copy.deepcopy(bounding_box)>>>bounding_box.bottom_right=Point(500,700)>>>bounding_boxRectangle(Point(x=10, y=20), Point(x=500, y=700))>>>shallow_copyRectangle(Point(x=10, y=20), Point(x=30, y=40))>>>deep_copyRectangle(Point(x=10, y=20), Point(x=30, y=40))>>>original_bottom_right.x+=100>>>bounding_boxRectangle(Point(x=10, y=20), Point(x=500, y=700))>>>shallow_copyRectangle(Point(x=10, y=20), Point(x=130, y=40))>>>deep_copyRectangle(Point(x=10, y=20), Point(x=30, y=40))In the highlighted lines, you perform two modifications:First, you replace the bottom-right corner of the original rectangle with a newPoint(500, 700)object. At this stage, onlybounding_boxis affected while its shallow copy still references the corner atPoint(30, 40).Next, you change the horizontal coordinate of theoriginal_bottom_rightpoint. Sinceshallow_copystill references the original corner objects, this change is reflected there as well. Meanwhile,deep_copyremains unchanged, maintaining independence from the underlying parent and child objects.As you can see, thecopy.copy()andcopy.deepcopy()functions generally work as expected out of the box. However, if performance is a concern or you need custom copying behavior for specific objects, then you might consider implementing additional special methods in your classes. Up next, you’ll learn how to customize copying in Python.Managing Resources in CopiesWhen you use thecopymodule, Python creates afield-for-field copyof an object, bypassing the standard construction mechanism, which normally involves calling the.__init__()method. Instead, Python creates a blank instance of the same type and copies attributes from the original object’s.__dict__or.__slots__. This applies to both shallow and deep copies, which duplicate references or recurse into nested objects, respectively.Skipping the initializer method can become problematic when your class relies on it for crucial setup. For instance, have a look at the class below, which opens a file for reading within the initializer:Python>>>importjson>>>classDataFile:...def__init__(self,path):...self.file=open(path,mode=""r"",encoding=""utf-8"")......def__enter__(self):...returnself......def__exit__(self,exc_type,exc_val,exc_tb):...self.file.close()......defread_json(self):...self.file.seek(0)...returnjson.load(self.file)...This class accepts a file path as an argument and uses it to create a new file object stored in an instance attribute. The.read_json()method moves the open file’s position to the beginning, reads its entire content, and parses the resulting text asJSON. Finally, the.__enter__()and.__exit__()methods turn the class into a context manager, ensuring that the underlyingfile is properly closedwhen needed.Now, watch what happens when you create ashallow copyof aDataFileobject and attempt to use it after the original context manager block has exited:Python>>>importcopy>>>frompprintimportpp>>>withDataFile(""person.json"")asdata_file:...shallow_copy=copy.copy(data_file)...pp(data_file.read_json())...{'name': 'John Doe','age': 42,'email': 'johndoe@example.com','is_subscribed': True,'hobbies': ['reading', 'cycling', 'traveling'],'address': {'street': '123 Main St', 'city': 'New York', 'zip': '10001'}}>>>shallow_copy.read_json()Traceback (most recent call last):...ValueError:I/O operation on closed file.Shallow copying merely duplicates the reference to thefile handlecreated by the original object. In this case, the file was opened in the initializer method, which thecopymodule didn’t call again. As a result, the shallow copy points to a file handle already closed by the context manager.You can remedy the situation by taking control over shallow copying ofDataFileobjects. To do so, implement the.__copy__()method in your class to properly manage the internal resource:Python>>>classDataFile:...def__init__(self,path):...self.file=open(path,mode=""r"",encoding=""utf-8"")......def__copy__(self):...returntype(self)(self.file.name)......def__enter__(self):...returnself......def__exit__(self,exc_type,exc_val,exc_tb):...self.file.close()......defread_json(self):...self.file.seek(0)...returnjson.load(self.file)...This method returns a newDataFileinstance with the same file path, effectively opening a new file handle. When you callcopy.copy()on instances of your updated class, Python will invoke this special method instead of relying on the generic implementation from thecopymodule:Python>>>withDataFile(""person.json"")asdata_file:...shallow_copy=copy.copy(data_file)...pp(data_file.read_json())...{'name': 'John Doe','age': 42,'email': 'johndoe@example.com','is_subscribed': True,'hobbies': ['reading', 'cycling', 'traveling'],'address': {'street': '123 Main St', 'city': 'New York', 'zip': '10001'}}>>>pp(shallow_copy.read_json()){'name': 'John Doe','age': 42,'email': 'johndoe@example.com','is_subscribed': True,'hobbies': ['reading', 'cycling', 'traveling'],'address': {'street': '123 Main St', 'city': 'New York', 'zip': '10001'}}>>>shallow_copy.file.close()Now, both the original and the shallow copy can read from the same file without interfering with each other. Don’t forget to manually close the file when you’re done working with the shallow copy in order to avoid potential data loss!Have you noticed that you essentially implemented the logic for creating a deep copy of theDataFile? Wouldn’t it be more straightforward to directly callcopy.deepcopy()and let Python handle the details? Well, why don’t you find out:Python>>>withDataFile(""person.json"")asdata_file:...deep_copy=copy.deepcopy(data_file)...Traceback (most recent call last):...TypeError:cannot pickle 'TextIOWrapper' instancesAlas, deep copying also doesn’t work as expected withDataFileobjects, but for other reasons. The error message suggests that Python did try to recursively duplicate the file handle, but failed due to lack of support for such objects.Note:Python’s field-for-field copying shares some similarities with how thepicklemodule handles objectserializationbehind the scenes. Both rely on a common set of special methods for their customization. That’s why you’re seeing the error message related to pickling when you attempt to clone a file object.If you need to customize thedeep copycreation process, then implement the corresponding special method,.__deepcopy__(), in your class:Python>>>classDataFile:...def__init__(self,path):...self.file=open(path,mode=""r"",encoding=""utf-8"")......def__copy__(self):...returntype(self)(self.file.name)......def__deepcopy__(self,memo):...returnself.__copy__()......def__enter__(self):...returnself......def__exit__(self,exc_type,exc_val,exc_tb):...self.file.close()......defread_json(self):...self.file.seek(0)...returnjson.load(self.file)...You’ll notice two things. First, unlike.__copy__(), this method takes an argument, which must be a Python dictionary. It’s used internally by Python to avoid infinite loops when it recursively traversesreference cycles. Secondly, this particular.__deepcopy__()implementation delegates to.__copy__()since both methods use the same underlying logic to produce a deep copy. However, that won’t always be the case.In the next section, you’ll explore a different scenario for customizing shallow and deep copying of your own classes in Python.Remove adsCopying Attributes SelectivelySuppose you want to model the graphical window of a Unixterminalor a Windows console as a Python class:Python>>>fromdatetimeimportUTC,datetime>>>classConsoleWindow:...def__init__(self,tabs):...self.tabs=tabs...self.history=[]...self.created_at=datetime.now(UTC)......defrun_command(self,command):...self.history.append(command)...This class accepts a collection of the currently open tabs, which is a global registry ofConsoleWindowinstances shared among all tabs and windows. Each window keeps track of the commands executed within it using the.run_command()method. Also, the initializer method records the exact time a window was created.Here’s a short example demonstrating how you might use this class in action:Python>>>frompprintimportpp>>>shared_registry=set()>>>window=ConsoleWindow(shared_registry)>>>window.run_command(""pwd"")>>>window.run_command(""ls -l"")>>>pp(vars(window)){'tabs': set(),'history': ['pwd', 'ls -l'],'created_at': datetime.datetime(2025, (...), tzinfo=datetime.timezone.utc)}First, you create an empty set of window tabs that you’ll open in the future, passing it to the new window instance. Then, you run two Unix commands,pwdandls, which get recorded in the window’s local history. When you pretty print thevars()of your window object, you get to see its current state, including the empty set of tabs, the two historical commands, and the creation timestamp.Making ashallow copyof a window should correspond to opening a split view, where both instances share the same history. So, typing commands into the copy should be reflected in the original window and the other way around. Conversely, adeep copyshould duplicate the original commands into an independent list object. At the same time, you want all copies to share the same global tab registry.Unfortunately, the defaultcopybehavior won’t follow these rules. First of all, Python won’t automatically update the tab registry or the timestamp when creating a new copy. Secondly, making a deep copy will overwrite the tab registry in each new instance.To fix these issues, you can update your class by implementing the two special methods,.__copy__()and.__deepcopy__(), in the following way:Python>>>classConsoleWindow:...def__init__(self,tabs):...self.tabs=tabs...self.history=[]...self.created_at=datetime.now(UTC)......def__copy__(self):...instance=type(self)(self.tabs)...instance.history=self.history...self.tabs.add(instance)...returninstance......def__deepcopy__(self,memo):...instance=type(self)(self.tabs)...instance.history=copy.deepcopy(self.history,memo)...self.tabs.add(instance)...returninstance......defrun_command(self,command):...self.history.append(command)...They look nearly identical except for a small detail visible in the highlighted lines. The key difference lies in how the.historyattribute is handled.Both methods start by constructing a newConsoleWindowinstance and initializing it with the same global registry of tabs. For the shallow copy, this is almost equivalent to the default implementation provided by Python, as the copy will reference a shared mutable object. But your deep copy implementation becomes more selective, as it no longer recursively clones the mutable set of tabs, retaining the global instance.Note:At this point, the default shallow copy would also preserve the original timestamp, whereas your custom.__copy__()method updates the timestamp, reflecting the creation of the new instance.Next, in the.__copy__()method, you assign the.historyfield directly from the original instance so it shares the same list object. Again, that’s expected of a shallow copy. However, in the.__deepcopy__()method, you create a new, independent copy of.historyby explicitly callingcopy.deepcopy()on the original one with thememoargument. Python would’ve done the same by default.Finally, you add the newly created window tab to the global registry and return the new instance from both special methods. This allows you to give your class a final test drive:Python>>>importcopy>>>window=ConsoleWindow(set())>>>window.run_command(""cd ~/Projects"")>>>tab1=copy.deepcopy(window)>>>tab1.run_command(""git clone git@github.com:python/cpython.git"")>>>tab2=copy.copy(tab1)>>>tab2.run_command(""cd python/"")>>>window.run_command(""ls -l"")>>>tab1.run_command(""git checkout 3.13"")By first creating a deep copy of the main window, you ensure thatwindowandtab1maintain independent histories. However, note that you later shallowly copy the tab, making bothtab1andtab2share history with each other:Python>>>pp(vars(window)){'tabs': {<__main__.ConsoleWindow object at 0x7db2dd9aae90>,<__main__.ConsoleWindow object at 0x7db2dd9ab4d0>},'history': ['cd ~/Projects', 'ls -l'],'created_at': datetime.datetime((...), 721600, (...))}>>>pp(vars(tab1)){'tabs': {<__main__.ConsoleWindow object at 0x7db2dd9aae90>,<__main__.ConsoleWindow object at 0x7db2dd9ab4d0>},'history': ['cd ~/Projects','git clone git@github.com:python/cpython.git','cd python/','git checkout 3.13'],'created_at': datetime.datetime((...), 723718, (...))}>>>pp(vars(tab2)){'tabs': {<__main__.ConsoleWindow object at 0x7db2dd9aae90>,<__main__.ConsoleWindow object at 0x7db2dd9ab4d0>},'history': ['cd ~/Projects','git clone git@github.com:python/cpython.git','cd python/','git checkout 3.13'],'created_at': datetime.datetime((...), 726256, (...))}All threeConsoleWindowinstances share the same set of tabs with identical elements. Their.created_attimestamps correctly reflect the order in which they were opened. Finally, the two tabs—tab1andtab2—have mirrored local history, as they share the same list object under the hood.Ultimately, how you implement shallow and deep copying in custom classes is entirely up to you. Additionally, if you’re using Python 3.13 or later, then you might also tweak the implementation ofcopy.replace(), as shown in next section.Supporting Attribute ReplacementBy default, only a handful of Python types supportcopy.replace(). To use this function on your own classes, you must implement the third special method related to copying,.__replace__(), which Python triggers for you:Python Syntaxobject.__replace__(self,/,**changes)This method takes no positional arguments—becauseselfalready references the object to copy—and a variable number of optional keyword arguments that’ll overwrite the corresponding instance attributes.A straightforward way to implement this method in your class would be to modify the instance in place without returning anything:Python>>>classPerson:...def__init__(self,name,age):...self.name=name...self.age=age......def__replace__(self,**changes):...ifunknown:=changes.keys()-self.__dict__.keys():...raiseAttributeError("", "".join(unknown))...self.__dict__.update(**changes)...In this case, you update the object’s internal.__dict__attribute by overwriting its key-value pairs with their counterparts from thechangesdictionary.To prevent adding new attributes that the original object never defined, you check ifchangescontains unknown keys. You determine this by computing theset differenceof the corresponding dictionary keys and storing them in a local variable. If the resultingunknownset has any items, then you raise anAttributeErroraccordingly.This allows you to applyin-place modificationstoPersoninstances:Python>>>importcopy>>>person=Person(""John Doe"",42)>>>copy.replace(person,age=24,name=""Alice Smith"")>>>vars(person){'name': 'Alice Smith', 'age': 24}>>>copy.replace(person,name=""Bob Brown"",email=""bob.brown@example.com"")Traceback (most recent call last):...AttributeError:emailAs you can see, it’s possible to change multiple attributes at once, passing them in arbitrary order. Simultaneously, you can’t set a non-existent attribute, such as.emailin the example above.Note that your current implementation is rather odd and could be surprising, given that it breaks the promise made by thecopy.replace()function’sdocstring:Creates a new object of the same type asobj, replacing fields with values fromchanges. (Source)A more correct implementation would, therefore, return ashallow copyof the original object without making any in-place changes. Here’s how you can provide such a behavior in yourPersonclass:Python>>>classPerson:...def__init__(self,name,age):...self.name=name...self.age=age......def__replace__(self,**changes):...returntype(self)(**self.__dict__|changes)...>>>person=Person(""John Doe"",42)>>>person_copy=copy.replace(person,age=24,name=""Alice Smith"")>>>vars(person){'name': 'John Doe', 'age': 42}>>>vars(person_copy){'name': 'Alice Smith', 'age': 24}>>>copy.replace(person,email=""bob.brown@example.com"")Traceback (most recent call last):...TypeError:Person.__init__() got an unexpected keyword argument 'email'This version looks even simpler, as it returns a new instance supplied by your class constructor, which receives aunion of two dictionaries:.__dict__andchanges. If there are any overlapping keys, then the dictionary on the right of the union operator (|) overrides the corresponding key-value pairs from the dictionary on the left.Because the object’s internal state depends solely on the input arguments, you don’t have to manually check if the attributes being replaced are valid. Also, had this class defined any mutable members,copy.replace()would’ve reused them across the copies.However, this implementation will only work as long as your objects have a special.__dict__attribute. On the other hand, if your class defines.__slots__instead of the dictionary, then you’ll need to adjust for that accordingly:Python>>>classPerson:...__slots__=(""name"",""age"")......def__init__(self,name,age):...self.name=name...self.age=age......def__replace__(self,**changes):...instance=type(self)(self.name,self.age)...forname,valueinchanges.items():...ifhasattr(self,name):...setattr(instance,name,value)...returninstance...>>>person=Person(""John Doe"",42)>>>person_copy=copy.replace(person,age=24,name=""Alice Smith"")>>>vars_slots=lambdaobj:{...name:getattr(obj,name)...fornameinobj.__slots__...}>>>vars_slots(person){'name': 'John Doe', 'age': 42}>>>vars_slots(person_copy){'name': 'Alice Smith', 'age': 24}Because instances of thePersonclass no longer come with a dictionary to update, you must rely on thehasattr()andsetattr()global functions to replace attributes. Also, since the built-invars()function won’t work against objects with.__slots__, you devise a helper lambda expression as a substitute.Finally, your objects might containderived attributesorproperties, such as a person’s age calculated from their date of birth and the current date. If you’d like to keep those properties immutable while still being able to replace them in copies, then you might take the following approach:Python>>>fromdatetimeimportdate>>>classPerson:...def__init__(self,name,date_of_birth):...self.name=name...self.date_of_birth=date_of_birth......@property...defage(self):...return(date.today()-self.date_of_birth).days//365......def__replace__(self,**changes):...age=changes.pop(""age"",None)...dob=changes.pop(""date_of_birth"",None)......instance=copy.copy(self)...forname,valueinchanges.items():...ifhasattr(self,name):...setattr(instance,name,value)......ifageanddob:...raiseAttributeError(""can't set both 'age' and 'date_of_birth'"")...elifage:...dob=copy.replace(date.today(),year=date.today().year-age)...instance.date_of_birth=dob...elifdob:...instance.date_of_birth=dob......returninstance...The.ageproperty is calculated dynamically—based on another attribute—within agettermethod. Since it has no companion setter method, the person’s age is effectively read-only.The.__replace__()method above creates a shallow copy of the current instance by callingcopy.copy(). It then usessetattr()to overwrite the specific attributes using values from thechangesdictionary. Finally, it includes logic to update the.date_of_birthfield based on the provided age or date of birth.The code example below demonstrates how this implementation works in practice:Python>>>person=Person(""John Doe"",date(1983,3,14))>>>vars(copy.replace(person,age=24)){'name': 'John Doe', 'date_of_birth': datetime.date(2001, 3, 26)}>>>vars(copy.replace(person,date_of_birth=date(1999,6,15))){'name': 'John Doe', 'date_of_birth': datetime.date(1999, 6, 15)}>>>vars(copy.replace(person,date_of_birth=date(1999,6,15),age=12))Traceback (most recent call last):...AttributeError:can't set both 'age' and 'date_of_birth'Notice how your.__replace__()method allows for updating either the.ageor the.date_of_birthattribute, but not both at the same time. Also, even though.ageis a read-only property derived from the date of birth, you can still update the person’s age indirectly.Python’s attribute replacement mechanism gives you a lot of flexibility to customize it. However, it works best when you use it to create modified shallow copies of an object while keeping certain properties immutable.ConclusionBy now, you’ve explored various techniques for copying Python objects, including constructors, slicing, the.copy()method, and thecopymodule. Along the way, you’ve learned aboutshallowvsdeep copiesand how Python’sassignment statementscreate bindings rather than copies. You also delved into the mechanics ofscalarandcomposite types,mutableandimmutable objects, and how these characteristics influence copying behavior.In this tutorial, you’ve learned how to:Differentiate betweenshallowanddeep copiesUsePython’scopymodulefor versatile object copyingImplementcustom copying behaviorin your own classesApply various techniques tocopy different types of objectsefficientlyWith these skills, you can now confidently manage object copying in Python. This will ensure that your programs handle data efficiently without unexpected modifications to the shared state.Get Your Code:Click here to download the free sample codethat you’ll use to learn about shallow vs deep copying in Python.Frequently Asked QuestionsNow that you have some experience with copying objects in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What is the difference between shallow and deep copying in Python?Show/HideA shallow copy creates a new object but shares references to the nested objects with the original, while a deep copy recursively duplicates all objects, including nested ones, ensuring complete independence from the original.How do you perform a shallow copy of a list in Python?Show/HideYou can perform a shallow copy of a list using slicing (list[:]), thelist()constructor, or the.copy()method.How can you make a deep copy of an object in Python?Show/HideYou can make a deep copy of an object in Python using thecopy.deepcopy()function from thecopymodule.What are some common scenarios where you need to use a deep copy?Show/HideYou need to use a deep copy when you want to ensure that the copied object and the original don’t share any mutable descendants, preventing changes in one from affecting the other.How do you customize the copy behavior of a custom class in Python?Show/HideYou can customize the copy behavior by implementing the.__copy__()and.__deepcopy__()methods in your class to control how shallow and deep copies are made.Take the Quiz:Test your knowledge with our interactive “Shallow vs Deep Copying of Python Objects” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizShallow vs Deep Copying of Python ObjectsIn this quiz, you'll test your understanding of Python's copy module, which provides tools for creating shallow and deep copies of objects. This knowledge is crucial for managing complex, mutable data structures safely and effectively.Mark as CompletedShare"
How to Exit Loops Early With the Python Break Keyword,https://realpython.com/python-break/,"Apr 16, 2025",N/A,"basics, python","Table of ContentsIntroducing the break StatementBreaking Out of a Loop With a Set Number of IterationsUsing the Python break Statement to Process User InputBreaking Out of Nested LoopsUsing the continue Keyword Instead of breakUsing break Together With an else ClauseConclusionFrequently Asked QuestionsRemove adsIn Python, thebreakstatementlets you exit a loop prematurely, transferring control to the code that follows the loop. This tutorial guides you through usingbreakin bothforandwhileloops. You’ll also briefly explore thecontinuekeyword, which complementsbreakby skipping the current loop iteration.By the end of this tutorial, you’ll understand that:Abreakin Pythonis a keyword that lets you exit a loop immediately, stopping further iterations.Usingbreakoutside of loopsdoesn’t make sense because it’s specifically designed to exit loops early.Thebreakdoesn’t exit all loops, only the innermost loop that contains it.To explore the use ofbreakin Python, you’ll determine if a student needs tutoring based on the number of failed test scores. Then, you’ll print out a given number of test scores and calculate how many students failed at least one test.You’ll also take a brief detour from this main scenario to examine how you can usebreakstatements to accept and process user input, using a number-guessing game.Get Your Code:Click here to download the free sample codethat shows you how to exit loops early with the Python break keyword.Take the Quiz:Test your knowledge with our interactive “How to Exit Loops Early With the Python Break Keyword” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizHow to Exit Loops Early With the Python Break KeywordIn this quiz, you'll test your understanding of the Python break statement. This keyword allows you to exit a loop prematurely, transferring control to the code that follows the loop.Introducing thebreakStatementBefore proceeding to the main examples, here’s a basic explanation of what thebreakstatement is and what it does. It’s a Python keyword that, when used in a loop, immediately exits the loop and transfers control to the code that would normally run after the loop’s standard conclusion.You can see the basics of thebreakstatement in a simple example. The following code demonstrates a loop that prints numbers within a range until the next number is greater than 5:Python>>>fornumberinrange(10):...ifnumber==5:...break...print(number)...01234This short code example consists of aforloopthat iterates through a range of numbers from0to9. Itprintsout each number, but when the next number is5, abreakstatement terminates the loop early. So, this code will print the numbers from0to4, and then the loop will end.Asbreakstatements end loops early, it wouldn’t make sense for you to use them in any context that doesn’t involve a loop. In fact, Python will raise aSyntaxErrorif you try to use abreakstatement outside of a loop.A key benefit of usingbreakstatements is that you can prevent unnecessary loop iterations by exiting early when appropriate. You’ll see this in action in the next section.Remove adsBreaking Out of a Loop With a Set Number of IterationsImagine you’re a teacher who evaluates the scores of your students. Based on the scores, you want to determine how many tests each student has failed. The following example demonstrates how you might accomplish this task using aforloopto iterate through the students’ test scores:Python>>>scores=[90,30,50,70,85,35]>>>num_failed_scores=0>>>pass_score=60>>>forscoreinscores:...ifscore<pass_score:...num_failed_scores+=1...>>>print(f""Number of failed tests:{num_failed_scores}"")Number of failed tests: 3You start with a list of scores for one student. Before the loop runs, you set a few variables. The variablenum_failed_scoresis set at0, because you haven’t yet found any failing scores.pass_score, the variable that stores the threshold for passing a test, is set at60, so any score less than that is considered a failed test.As theforloop begins, it will run as many times as there are scores in the list, iterating over each score. If the score is less than the failing score threshold, it increments thenum_failed_scoresvariable by1. Finally, you output the number of tests that the student failed.To support students who underperform, you decide to implement a tutoring system. Once a student has failed two tests, you want to propose tutoring to them. In this case, you don’t need to loop through all the scores. The moment a student has failed two tests, you’ve gained the information needed and can stop the iteration. Here’s how your adjusted code might look in this case, using abreakstatement:Python>>>scores=[90,30,50,70,85,35]>>>num_failed_scores=0>>>pass_score=60>>>needs_tutoring=""No"">>>forscoreinscores:...ifscore<pass_score:...num_failed_scores+=1...ifnum_failed_scores>=2:...needs_tutoring=""Yes""...break...>>>print(f""Does the student need tutoring?{needs_tutoring}"")Does the student need tutoring? YesAs before, you start with a list of scores for one student. Before the loop runs, you set a few variables. The code is pretty much the same but with a few additions. Before the loop, you add a new variable,needs_tutoring, which is initially set to""No""because you haven’t yet recommended tutoring for this student.You still iterate through the scores and increment thenum_failed_scoresvariable if the loop finds a failed test score. Next, in a new step after checking each score, the loop will check to see if there are at least two failed scores. If so, the code sets theneeds_tutoringvariable to""Yes"", and the loop exits early with abreakstatement. Finally, the code displays a message indicating whether or not the student needs tutoring.So far, you’ve seen thebreakstatement paired withforloops. As you’ll see in the next section, you can also use it withwhileloops.Using the PythonbreakStatement to Process User InputWhen you need to get input from a user, you’ll often use a loop but you won’t always know how many iterations your loop will need. In these cases, awhileloopis a good choice, and you can pair it with abreakstatement to end the loop when you’re finished getting the user’s input.Taking a slight detour from the student test scores example, you can also see this concept demonstrated in a number-guessing game. In this game, you give the player a limited amount of turns to guess a randomly generated number. Thegame loop, awhileloop in this case, will run at least as many times as the number of turns, but it can end early.At the start of each turn, you prompt the user to enter a number, or a quit character. If the player correctly guesses the number, youbreakout of the game loop and congratulate the player. If the player uses up all the turns without guessing the correct number, the game loop terminates and the code outputs the correct number.If the player enters the quit character, the loop will use abreakstatement to exit the game early:Python>>>importrandom>>>guesses_left=4>>>random_number=random.randint(1,10)>>>whileTrue:...ifguesses_left<=0:...print(...""You ran out of guesses! ""...f""The correct number was{random_number}""...)...break...guess=input(""Guess a number between 1 and 10, or enter q to quit: "")...ifguess==""q"":...print(""Successfully exited game."")...break...elifnot(guess.isnumeric()):...print(""Please enter a valid value."")...elifint(guess)==random_number:...print(""Congratulations, you picked the correct number!"")...break...else:...print(""Sorry, your guess was incorrect."")...guesses_left-=1...print(f""You have{guesses_left}guesses left."")...Guess a number between 1 and 10, or enter q to quit: 5Sorry, your guess was incorrect.You have 3 guesses left.Guess a number between 1 and 10, or enter q to quit: 3Sorry, your guess was incorrect.You have 2 guesses left.Guess a number between 1 and 10, or enter q to quit: 7Sorry, your guess was incorrect.You have 1 guesses left.Guess a number between 1 and 10, or enter q to quit: 2Sorry, your guess was incorrect.You have 0 guesses left.You ran out of guesses! The correct number was 8At the beginning of the code, you import therandommodulein order to access Python’s random number generator functionality. Next, you set up some key variables for the game. First, you create a variable to store the number of guesses that the player has remaining. Then, you create a variable and store a random integer, between1and10, inclusive, using Python’srandint()function.The next segment of the code is the game loop. You set up awhileloop with a sentinel condition ofTrue. So, you’ll need abreakstatement to exit the loop—otherwise the loop will continue running indefinitely.Inside the game loop, you first check to see if the player has any guesses left. If no guesses remain, then you print out a message informing the player that there are no guesses left and reveal the correct number. You then usebreakto break out of the game loop.If the player still has guesses remaining, then you prompt the player to enter either a number between1and10, or the characterqto quit the game. You store the player’s response in the variableguess.Next, you check the player’s response using a series ofconditional statements. If the player enters the letterqto exit the game, you print out a message alerting the player that the game has ended, and you follow up with abreakstatement to exit the game loop.To determine if the player entered a number, you use the.isnumeric()method. If the player’s response wasn’t a number, you again prompt the player to enter a valid value. Note that this check comes after you determine if the player entered the quit character, so at this point, any responses should be numeric.If the player has correctly guessed the number, you print a congratulatory message to the screen, and then end the game loop with abreakstatement. However, if the player’s guess was incorrect, you print a message explaining that the guess was wrong. You then subtract one guess, and print out the remaining number of guesses. At this point, you have reached the end of the loop iteration, so the code will begin the next iteration.This example also showcases another advantage of and common use case for thebreakstatement. As you saw, you used thebreakstatement to prevent the loop from running indefinitely. Using thebreakstatement appropriately helps to ensure that you don’t end up with aninfinite loop.Thiswhileloop andbreakcombination is a common pattern for getting user input, especially in situations where you don’t know how many times your loop will need to run before the user is finished.For example, think of a chatbot that provides customer service assistance on a commerce site. The chatbot might continue prompting users to ask questions or for relevant information until all the users’ problems are solved. The chat could use awhileloop that runs until the users indicate they no longer need assistance, at which point the loop can exit with abreakstatement.Remove adsBreaking Out of Nested LoopsYou can also usebreakstatements to exitnested loops. Used in this way, thebreakstatement will terminate the innermost enclosing loop. Returning back to your student test score analysis tool, consider the following example to illustrate this principle.In this example, your tool will examine test scores from multiple students to determine how many students received at least one failed test score. An outer loop will iterate through different lists of student scores, while an inner loop will iterate through the individual scores for each student list:Python>>>scores=[...[90,30,80,100],...[100,80,95,87],...[75,84,77,50],...]>>>pass_score=60>>>num_failed_students=0>>>forstudent_scoresinscores:...forscoreinstudent_scores:...ifscore<pass_score:...num_failed_students+=1...break...>>>print(f""Number of students who failed a test:{num_failed_students}"")Number of students who failed a test: 2You begin by creating a list of scores. This list actually contains three separate sublists, each representing one student’s test scores.You then set up a couple of integer variables. First, you set the threshold for a failed test score, which is60, as in the previous code example. Next, you set the initial number of students who failed a test to0, because you haven’t found any failed test scores yet.Next, you begin the code’s outerforloop. This loop will iterate through each of the three student score lists. Inside of that loop, you create a nestedforloop that takes one student score list, and iterates through each of the individual scores.If the inner loop finds a failed score, then you increment the number of students who have failed a test by1, and thenbreakout of that inner loop since there’s no need to check the rest of that student’s scores. Note that thebreakstatement only exits the inner loop, and the code will continue with the next list of student scores as the outer loop continues.At the end of the code, you output to the screen the number of students who have failed at least one test.Using thecontinueKeyword Instead ofbreakPython also has another keyword that allows you to reduce the number of unnecessary loop iterations. Thecontinuekeywordlets you skip specific iterations of a loop if the given conditions are met. If an iteration meets the given conditions, then the loop will skip that iteration and move on to the next one.For example, suppose you want to iterate over a range of numbers and print out only the odd numbers. You could write code with thecontinuekeyword, like in the following example:Python>>>forindexinrange(6):...ifindex%2==0:...continue...print(index)...135This code sample will print out the numbers1,3, and5. You create aforloop to iterative over the range of numbers1through6. Inside the loop, you use themodulo operatorto check each number in the range. If the remainder of the number divided by2is equal to0, the number is even, so you’ll branch to acontinuestatement. Thiscontinuestatement terminates the loop iteration, so the code aftercontinuewill not execute.However, if the remainder of the number divided by2isn’t0(it should actually be1, for odd numbers), then the code will not execute thecontinuestatement. Instead, it will print out the number.breakandcontinueare similar in that they both end the current loop iteration. However, whilebreakexits the innermost loop entirely, ending any further iterations,continueskips the rest of the current iteration and moves on to the next one. Both keywords are valuable tools for exiting a loop iteration early when necessary.UsingbreakTogether With anelseClausePython’sforandwhileloops have anelseclause. This is an unusual feature that’s not present in many other programming languages. Theelseclause triggers if you don’t hit abreakstatement inside the loop.The main use case of theelseclause is to avoid variables that only keep track of whether you usebreakto end a loop. For example, you can rewrite the previous tutoring example with anelseclause in yourforloop:Python>>>scores=[90,30,50,70,85,35]>>>num_failed_scores=0>>>pass_score=60>>>forscoreinscores:...ifscore<pass_score:...num_failed_scores+=1...ifnum_failed_scores>=2:...print(""The student needs tutoring"")...break...else:...print(""The student doesn't need tutoring"")...The student needs tutoringNote thatelseis indented to line up withfor. Thebreakstatement triggers if the student needs tutoring. In this case, theelseclause is ignored. If the loop completes without hittingbreak, then the code underelseis executed.In this example, you don’t need theneeds_tutoringvariable from earlier as you use the control flow features in Python instead.Note:You can read more about usingelsewith loops in the following tutorials:Python for Loops: The Pythonic WayPython while Loops: Repeating Tasks ConditionallyBothforandwhileloops support anelseclause that triggers whenever the loops terminates without abreak.You can also usebreakandelseto completely break out of nestedforloops. Look back at the example with multiple students. Say that you’re only interested in whether any of your students failed at least one of the tests. You can use the following code:Python>>>scores=[...[90,30,80,100],...[100,80,95,87],...[75,84,77,50],...]>>>pass_score=60>>>forstudent_scoresinscores:...forscoreinstudent_scores:...ifscore<pass_score:...print(""At least one student failed a test"")...break...else:...continue...break...At least one student failed a testHere you use anelse…continue…breakconstruction that allows you break out of bothforloops. If you break out of the inner loop, then you’ll hit the secondbreakto terminate the outer loop as well. If you don’t executebreakin the inner loop, thencontinuemakes sure that you don’t executebreakin the outer loop either.This construction is a bit convoluted, and there are often better and more readable options available. In this example, you could insteadflatten the nested listsand use a single loop to process the scores.Remove adsConclusionIn this tutorial, you explored thebreakstatement in Python and learned how to use it to exit loops early. You saw an example of a student test score analysis tool, which demonstrated how to prevent a loop from continuing after achieving the intended results, as well as how to exit a nested loop.Through the number-guessing game example, you also learned how you can usebreakstatements to take in and process user input. Then you took a brief look at thecontinuestatement, a similar keyword that allows you to skip a single iteration of a loop.Understandingbreakstatements and how to terminate loops early is an essential Python skill, as it helps you write more efficient code by reducing unnecessary iterations and preventing problematic infinite loops.Get Your Code:Click here to download the free sample codethat shows you how to exit loops early with the Python break keyword.Frequently Asked QuestionsNow that you have some experience with thebreakstatement in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned.These FAQs are related to the most important concepts you’ve covered in this tutorial. Click theShow/Hidetoggle beside each question to reveal the answer.What is abreakin Python?Show/HideYou use thebreakstatement in Python to immediately exit a loop, allowing the program to continue executing the code that follows the loop.Does it make sense to usebreakoutside of loops?Show/HideNo, it doesn’t make sense to usebreakoutside of loops because it’s specifically designed to exit loops.Does Pythonbreakexit all loops?Show/HideNo, thebreakstatement only exits the innermost loop in which it’s used, not all encapsulating loops.Take the Quiz:Test your knowledge with our interactive “How to Exit Loops Early With the Python Break Keyword” quiz. You’ll receive a score upon completion to help you track your learning progress:Interactive QuizHow to Exit Loops Early With the Python Break KeywordIn this quiz, you'll test your understanding of the Python break statement. This keyword allows you to exit a loop prematurely, transferring control to the code that follows the loop.Mark as CompletedShare"
